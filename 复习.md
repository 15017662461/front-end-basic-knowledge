# 数字媒体程序开发基础

## 数据结构

输入数组的语句：

```c++
int main()
{
  int num[100];// 用于存储输入的数组
  int a;// 用于存储输入的数组的长度
  char c;
  int i = 0;
  cin << a;//先输入数组的长度
  while(i < a)
  {
    c = getchar();
    if(c>='0' && c <= '9')
    {
      ungetc(c,stdin);
      cin >> num[i ++];
    }
  }
}
```



### 绪论

#### 什么是数据结构

数据以及数据之间的相互关系，即计算机中存储和组织数据的形式

#### 基本概念和术语

+ 数据对象：性质相同的数据元素的集合，是数据的子集。例如正整数数据对象是集合N={0,1,2,....}
+ 逻辑结构：从逻辑关系上描述数据，与数据的存储无关。四种逻辑结构有集合结构、线性结构、树形结构、图形结构
+ 存储结构：数据的逻辑结构在计算机中的存储形式。两种数据元素的存储结构：顺序存储和链式存储

#### 算法的定义

解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作

#### 算法的特性

五个基本特性：

+ 输入：算法具有0个或者多个输入
+ 输出：算法至少有一个或者多个输出
+ 有穷性：算法在执行有限的步骤之后会自动结束而不会出现无限循环，且每一个步骤都在可接受的时间内完成
+ 确定性：算法的每一步骤都具有确定的含义，不会出现二义性
+ 可行性：算法的每一步都是可行的，也就是说每一步都能通过执行有限次数完成。

#### 时间复杂度与空间复杂度

例题：求斐波那契数列函数的复杂度

```c++
// 递归方法：
long Fib1(int N){
  if(N < 3) return 1;
  else return Fib1(N-1) + Fib1(N-2);
}
// 循环方法
long Fib2(int N){
  int a = 1;
  int b = 1;
  int temp;
  while(N > 2){
    temp = a;
    a = b;
    b = temp + b;
    N --;
  }
  return b;
}
```

对于递归方法，时间复杂度为O(2^n^),空间复杂度为O(n)

对于循环方法，时间复杂度为O(n),空间复杂度为O(1)

常见的时间复杂度：O(1)<O(log~2~n)<O(n)<(nlog~2~n)<O(n^2^)<O(2^n^)<O(n!)



### 线性表

#### 顺序存储

用一段连续地址的存储单元依次存储线性表的数据元素

需要包含两个信息：当前线性表的长度，存储数据的数组

类定义：

```c++
class List{
  int size;// 当前线性表的长度
  int data[100];// 用数组存储数据
}
```

插入操作（在指定的index插入数据）：时间复杂度为O(n)

```c++
void insert(int index,int val){
  if(index < 0 || size == 100){
    cout << "插入的位置必须大于0或者线性表已满" << endl;
  }else{
    for(int i = size;i > index;i --){
      data[i] = data[i - 1];
    }
    data[index] = val;
    size ++;
  }
}
```

删除操作(包括删除指定位置和删除对应的val)：时间复杂度为O(n)、O(n^2^)

```c++
void deleteByIndex(int index){
  if(index < 0 || index >= size){
    cout << "删除位置必须大于0或必须小于长度" << endl;
  }else{
    for(int i = index;i < size - 1;i ++){
      data[i] = data[i + 1];
    }
    size --;
  }
}

void deleteByVal(int val){
  for(int i = 0;i < size;i ++){
    if(data[i] == val){
      for(int j = i;j < size - 1;j ++){
        data[j] = data[j + 1];
      }
      size --;
    }
  }
}
```



#### 链式存储

头结点的作用：在任意位置的插入或者删除的代码统一，空表和非空表表示统一

类定义：

```c++
class Node{
  int data;
  Node *next;
};
class LinkedList{
  Node* head;
  LinkedList(){
    head = new Node();
    head->next = NULL;
  }
}
```

根据输入的数组创建单链表：

```c++
void Create(int a[],int N){
  Node *temp;
  Node *x = head;
  for(int i = 0;i < N;i ++){
    temp = new Node();
    temp->data = a[i];
    temp->next = NULL;
    x->next = temp;
    x = x->next;
  }
}
```

增加节点（在末尾增加以及在头结点后面N个添加）：

```c++
void insertLast(int val){
  Node *p = new Node();
  p->data = val;
  p->next = NULL;
  Node *temp = head;
  while(temp->next != NULL){
    temp = temp->next;
  }
  temp->next = p;
}

void insertByIndex(int index,int val){
  Node *p = new Node();
  p->data = val;
  p->next = NULL;
  Node *temp = head;
  for(int i = 0;i < index;i ++){
    temp = temp->next;
  }
  p->next = temp->next;
  temp->next = p;
}
```

删除节点（根据值删除）：

```c++
void delete(int val){
  Node *pre = head;
  Node *cur = head->next;
  while(cur != NULL){
    if(cur->data == val){
      pre->next = cur->next;
      cur = cur->next;
      pre = pre->next;
    }else{
      cur = cur->next;
      pre = pre->next;
    }
  }
}
```

查找倒数第k个节点：

```c++
Node *findLast(int index){
  Node *fast = head;
  Node *slow = head;
  for(int i = 0;i < index;i ++){
    if(fast){
      fast = fast->next;
    }else{
      return nullptr;
    }
  }
  while(fast){
    slow = slow->next;
  }
  return slow;
}
```

#### 静态链表

用数组来模拟单链表的形式，数组中的每一项是一个对象，对象包含data和下一项的下标next<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201228221256671.png" alt="image-20201228221256671" style="zoom:70%;" />

#### 双向链表

由于多了一个指针，所以在插入和删除时需要更改两个指针变量

#### 循环链表

判断是否走到最后的条件为p->next == head;

应用：约瑟夫环



### 栈

#### 顺序存储

主要就是用数组模拟，用一个下标表示栈顶即可，初始为0：

```c++
class Stack{
  int data[100];// 用于存放栈的数据，最多可以存放100条数据
  int top;
  Stack(){
    top = -1;// 初始栈顶为-1
  }
};
```

判断栈空：top == -1;

入栈操作：

```c++
void push(int val){
  if(top >= 99){
    return; // 栈满了
  }else{
    data[++top] = val;
  }
}
```

出栈操作：

```c++
int pop(){
  if(top != -1){
    return data[top --];
  }
}
```

#### 链式存储

表头后一个作为栈顶元素，这样方便出栈和入栈：

```c++
class Node{
  int data;
  Node *next;
  Node(int val){
    data = val;
    next = NULL;
  }
};
class Stack{
  Node *head;
  Stack(){
    head = new Node(0);
  }
};
```

入栈操作：

```c++
void push(int val){
	Node *p = new Node(val);
  p->next = head->next;
  head->next = p;
}
```

出栈操作：

```c++
int pop(){
  if(head->next != NULL){
    Node *res = head->next;
    head->next = head->next->next;
    return res->data;
  }
}
```



###队列

#### 顺序存储

采用数组进行模拟，使用两个指针：front、rear。为了区分队空和队满，我们定义front指向队头元素，rear指向队尾的后一个元素，也就是说会空出一个元素空间，队满时数组中有一个空闲单元。

类定义：

```c++
class Queue{
  int data[MaxSize];
  int front;
  int rear;
  Queue(){
    front = MaxSize - 1;
    rear = MaxSize - 1;
  }
}
```

队空：rear == front

队满：(rear + 1) % MaxSize == front

入队：

```c++
void EnQueue(int value){
  if((rear + 1) % MaxSize == front){
    cout << "队列已满" << endl;
  }else{
    data[rear] = value;
    rear = (rear + 1) % MaxSize;
  }
}
```

出队：

```c++
int DeQueue(){
  if(rear == front){
    cout << "队空" << endl;
  }else{
    int res = data[front];
    front = (front + 1) % MaxSize;
    return res;
  }
}
```



#### 链式存储

头结点作为队首，指针front指向头结点，并有一个指针rear指向最后一个节点

类定义：

```c++
class Node{
  int data;
  Node* next;
  Node(int value){
    data = value;
    next = NULL;
  }
};
class Queue{
  Node* front;
  Node* rear;
  Queue(){
    front = new Node;
    front->next = NULL;
    rear = front;
  }
}
```

队空：rear == front;

队满：不存在满的情况

入队：

```c++
void EnQueue(int value){
  Node *p = new Node(value);
  rear->next = p;
  rear = p;
}
```

出队：

```c++
int DeQueue(){
  if(rear == front){
    cout << "队空" << endl;
    return;
  } 
  Node *p = front->next;
  int res = p->data;
  front->next = p->next;
  if(p->next == NULL) rear = front;
  delete p;
  return res;
}
```



### 树

#### 树的基本术语

+ 节点的度：节点所具有的子树的个数
+ 树的度：树中各节点的度的最大值
+ 树的路径长度：树中根节点到所有节点的路径之和
+ 叶子节点：度为0的节点，也称为终端节点
+ 分支节点：度不为0的节点，也称为非终端节点
+ 节点的层数：根节点的层数为1，其余节点以此类推
+ 树的深度：所有节点的最大层数，也称为高度
+ 森林：m棵互不相交的树的集合

一棵具有n个节点的树，其所有节点的度数之和为？(也就是所有的边之和，n-1)



#### 二叉树的基本术语

+ 满二叉树：高度为K，且有2^k^-1个节点的二叉树
+ 完全二叉树：所有的叶子都出现在k或者k-1层；k-1层的所有叶子都在非终端节点的右边；除了k-1层的最右非终端结点可能有一个（只能是左分支）或两个分支之外，其余非终端结点都有两个分支。![image-20201229222925493](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201229222925493.png)
+ + 其叶子节点只能出现在最后两层，且最下层的叶子节点都集中在二叉树的左部；如果有度为1的节点，只可能有1个且只有左孩子。
+ 二叉查找树**BST**：又叫做二叉搜索树、二叉排序树。每一个节点的左子树都小于该节点，右子树都大于该节点
+ 平衡二叉树**AVL**：根节点的左右子树的高度之差不超过1；且其左子树和右子树仍然是AVL树。简单来说就是：对于其所有节点，左右子树的高度差都不能超过1

#### 二叉树的性质

+ 二叉树的第i层，最多有2^i-1^个节点
+ 高度为k的二叉树最多有2^k^ -1个节点(满二叉树)，最少有K个节点。
+ + 注意：高度为K且只有K个节点的二叉树不一定是斜树
+ 在非空二叉树中，如果有n~0~个叶子节点，n~2~个度为2的节点，则有n~0~ = n~2~ + 1.与度为1的节点数量无关。
+ + 证明：n = n~0~ + n~1~ + n~2~ . n个节点共有n-1条边：n-1 = 2n~2~ + n~1~ 两条式子结合：n~0~ = n~2~ + 1
+ 具有n个节点的完全二叉树的高度为：log~2~(n + 1)或 log~2~ n + 1



















































































## 数据库

