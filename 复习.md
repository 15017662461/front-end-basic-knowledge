# 数字媒体程序开发基础

## 数据结构

输入数组的语句：

```c++
int main()
{
  int num[100];// 用于存储输入的数组
  int a;// 用于存储输入的数组的长度
  char c;
  int i = 0;
  cin << a;//先输入数组的长度
  while(i < a)
  {
    c = getchar();
    if(c>='0' && c <= '9')
    {
      ungetc(c,stdin);
      cin >> num[i ++];
    }
  }
}
```



### 绪论

#### 什么是数据结构

数据以及数据之间的相互关系，即计算机中存储和组织数据的形式

#### 基本概念和术语

+ 数据对象：性质相同的数据元素的集合，是数据的子集。例如正整数数据对象是集合N={0,1,2,....}
+ 逻辑结构：从逻辑关系上描述数据，与数据的存储无关。四种逻辑结构有集合结构、线性结构、树形结构、图形结构
+ 存储结构：数据的逻辑结构在计算机中的存储形式。两种数据元素的存储结构：顺序存储和链式存储

#### 算法的定义

解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作

#### 算法的特性

五个基本特性：

+ 输入：算法具有0个或者多个输入
+ 输出：算法至少有一个或者多个输出
+ 有穷性：算法在执行有限的步骤之后会自动结束而不会出现无限循环，且每一个步骤都在可接受的时间内完成
+ 确定性：算法的每一步骤都具有确定的含义，不会出现二义性
+ 可行性：算法的每一步都是可行的，也就是说每一步都能通过执行有限次数完成。

#### 时间复杂度与空间复杂度

例题：求斐波那契数列函数的复杂度

```c++
// 递归方法：
long Fib1(int N){
  if(N < 3) return 1;
  else return Fib1(N-1) + Fib1(N-2);
}
// 循环方法
long Fib2(int N){
  int a = 1;
  int b = 1;
  int temp;
  while(N > 2){
    temp = a;
    a = b;
    b = temp + b;
    N --;
  }
  return b;
}
```

对于递归方法，时间复杂度为O(2^n^),空间复杂度为O(n)

对于循环方法，时间复杂度为O(n),空间复杂度为O(1)

常见的时间复杂度：O(1)<O(log~2~n)<O(n)<(nlog~2~n)<O(n^2^)<O(2^n^)<O(n!)



### 线性表

#### 顺序存储

用一段连续地址的存储单元依次存储线性表的数据元素

需要包含两个信息：当前线性表的长度，存储数据的数组

类定义：

```c++
class List{
  int size;// 当前线性表的长度
  int data[100];// 用数组存储数据
}
```

插入操作（在指定的index插入数据）：时间复杂度为O(n)

```c++
void insert(int index,int val){
  if(index < 0 || size == 100){
    cout << "插入的位置必须大于0或者线性表已满" << endl;
  }else{
    for(int i = size;i > index;i --){
      data[i] = data[i - 1];
    }
    data[index] = val;
    size ++;
  }
}
```

删除操作(包括删除指定位置和删除对应的val)：时间复杂度为O(n)、O(n^2^)

```c++
void deleteByIndex(int index){
  if(index < 0 || index >= size){
    cout << "删除位置必须大于0或必须小于长度" << endl;
  }else{
    for(int i = index;i < size - 1;i ++){
      data[i] = data[i + 1];
    }
    size --;
  }
}

void deleteByVal(int val){
  for(int i = 0;i < size;i ++){
    if(data[i] == val){
      for(int j = i;j < size - 1;j ++){
        data[j] = data[j + 1];
      }
      size --;
    }
  }
}
```



#### 链式存储

头结点的作用：在任意位置的插入或者删除的代码统一，空表和非空表表示统一

类定义：

```c++
class Node{
  int data;
  Node *next;
};
class LinkedList{
  Node* head;
  LinkedList(){
    head = new Node();
    head->next = NULL;
  }
}
```

根据输入的数组创建单链表：

```c++
void Create(int a[],int N){
  Node *temp;
  Node *x = head;
  for(int i = 0;i < N;i ++){
    temp = new Node();
    temp->data = a[i];
    temp->next = NULL;
    x->next = temp;
    x = x->next;
  }
}
```

增加节点（在末尾增加以及在头结点后面N个添加）：

```c++
void insertLast(int val){
  Node *p = new Node();
  p->data = val;
  p->next = NULL;
  Node *temp = head;
  while(temp->next != NULL){
    temp = temp->next;
  }
  temp->next = p;
}

void insertByIndex(int index,int val){
  Node *p = new Node();
  p->data = val;
  p->next = NULL;
  Node *temp = head;
  for(int i = 0;i < index;i ++){
    temp = temp->next;
  }
  p->next = temp->next;
  temp->next = p;
}
```

删除节点（根据值删除）：

```c++
void delete(int val){
  Node *pre = head;
  Node *cur = head->next;
  while(cur != NULL){
    if(cur->data == val){
      pre->next = cur->next;
      cur = cur->next;
      pre = pre->next;
    }else{
      cur = cur->next;
      pre = pre->next;
    }
  }
}
```

查找倒数第k个节点：

```c++
Node *findLast(int index){
  Node *fast = head;
  Node *slow = head;
  for(int i = 0;i < index;i ++){
    if(fast){
      fast = fast->next;
    }else{
      return nullptr;
    }
  }
  while(fast){
    slow = slow->next;
  }
  return slow;
}
```

#### 静态链表

用数组来模拟单链表的形式，数组中的每一项是一个对象，对象包含data和下一项的下标next<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201228221256671.png" alt="image-20201228221256671" style="zoom:70%;" />

#### 双向链表

由于多了一个指针，所以在插入和删除时需要更改两个指针变量

#### 循环链表

判断是否走到最后的条件为p->next == head;

应用：约瑟夫环



### 栈

#### 顺序存储

主要就是用数组模拟，用一个下标表示栈顶即可，初始为0：

```c++
class Stack{
  int data[100];// 用于存放栈的数据，最多可以存放100条数据
  int top;
  Stack(){
    top = -1;// 初始栈顶为-1
  }
};
```

入栈操作：

```c++
void push(int val){
  if(top >= 99){
    return; // 栈满了
  }else{
    data[++top] = val;
  }
}
```

出栈操作：

```c++
int pop(){
  if(top != -1){
    return data[top --];
  }
}
```

#### 链式存储

表头后一个作为栈顶元素，这样方便出栈和入栈：

```c++
class Node{
  int data;
  Node *next;
  Node(int val){
    data = val;
    next = NULL;
  }
};
class Stack{
  Node *head;
  Stack(){
    head = new Node(0);
  }
};
```

入栈操作：

```c++
void push(int val){
	Node *p = new Node(val);
  p->next = head->next;
  head->next = p;
}
```

出栈操作：

```c++
int pop(){
  if(head->next != NULL){
    Node *res = head->next;
    head->next = head->next->next;
    return res->data;
  }
}
```



###队列





























































































## 数据库

