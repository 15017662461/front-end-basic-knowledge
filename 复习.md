# 数字媒体程序开发基础

## 数据结构

输入数组的语句：

```c++
int main()
{
  int num[100];// 用于存储输入的数组
  int a;// 用于存储输入的数组的长度
  char c;
  int i = 0;
  cin << a;//先输入数组的长度
  while(i < a)
  {
    c = getchar();
    if(c>='0' && c <= '9')
    {
      ungetc(c,stdin);
      cin >> num[i ++];
    }
  }
}
```



### 绪论

#### 什么是数据结构

数据以及数据之间的相互关系，即计算机中存储和组织数据的形式

#### 基本概念和术语

+ 数据对象：性质相同的数据元素的集合，是数据的子集。例如正整数数据对象是集合N={0,1,2,....}
+ 逻辑结构：从逻辑关系上描述数据，与数据的存储无关。四种逻辑结构有集合结构、线性结构、树形结构、图形结构
+ 存储结构：数据的逻辑结构在计算机中的存储形式。两种数据元素的存储结构：顺序存储和链式存储

#### 算法的定义

解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作

#### 算法的特性

五个基本特性：

+ 输入：算法具有0个或者多个输入
+ 输出：算法至少有一个或者多个输出
+ 有穷性：算法在执行有限的步骤之后会自动结束而不会出现无限循环，且每一个步骤都在可接受的时间内完成
+ 确定性：算法的每一步骤都具有确定的含义，不会出现二义性
+ 可行性：算法的每一步都是可行的，也就是说每一步都能通过执行有限次数完成。

#### 时间复杂度与空间复杂度

例题：求斐波那契数列函数的复杂度

```c++
// 递归方法：
long Fib1(int N){
  if(N < 3) return 1;
  else return Fib1(N-1) + Fib1(N-2);
}
// 循环方法
long Fib2(int N){
  int a = 1;
  int b = 1;
  int temp;
  while(N > 2){
    temp = a;
    a = b;
    b = temp + b;
    N --;
  }
  return b;
}
```

对于递归方法，时间复杂度为O(2^n^),空间复杂度为O(n)

对于循环方法，时间复杂度为O(n),空间复杂度为O(1)

常见的时间复杂度：O(1)<O(log~2~n)<O(n)<(nlog~2~n)<O(n^2^)<O(2^n^)<O(n!)



### 线性表

#### 顺序存储

用一段连续地址的存储单元依次存储线性表的数据元素

需要包含两个信息：当前线性表的长度，存储数据的数组

类定义：

```c++
class List{
  int size;// 当前线性表的长度
  int data[100];// 用数组存储数据
}
```

插入操作（在指定的index插入数据）：时间复杂度为O(n)

```c++
void insert(int index,int val){
  if(index < 0 || size == 100){
    cout << "插入的位置必须大于0或者线性表已满" << endl;
  }else{
    for(int i = size;i > index;i --){
      data[i] = data[i - 1];
    }
    data[index] = val;
    size ++;
  }
}
```

删除操作(包括删除指定位置和删除对应的val)：时间复杂度为O(n)、O(n^2^)

```c++
void deleteByIndex(int index){
  if(index < 0 || index >= size){
    cout << "删除位置必须大于0或必须小于长度" << endl;
  }else{
    for(int i = index;i < size - 1;i ++){
      data[i] = data[i + 1];
    }
    size --;
  }
}

void deleteByVal(int val){
  for(int i = 0;i < size;i ++){
    if(data[i] == val){
      for(int j = i;j < size - 1;j ++){
        data[j] = data[j + 1];
      }
      size --;
    }
  }
}
```



#### 链式存储

头结点的作用：在任意位置的插入或者删除的代码统一，空表和非空表表示统一

类定义：

```c++
class Node{
  int data;
  Node *next;
};
class LinkedList{
  Node* head;
  LinkedList(){
    head = new Node();
    head->next = NULL;
  }
}
```

根据输入的数组创建单链表：

```c++
void Create(int a[],int N){
  Node *temp;
  Node *x = head;
  for(int i = 0;i < N;i ++){
    temp = new Node();
    temp->data = a[i];
    temp->next = NULL;
    x->next = temp;
    x = x->next;
  }
}
```

增加节点（在末尾增加以及在头结点后面N个添加）：

```c++
void insertLast(int val){
  Node *p = new Node();
  p->data = val;
  p->next = NULL;
  Node *temp = head;
  while(temp->next != NULL){
    temp = temp->next;
  }
  temp->next = p;
}

void insertByIndex(int index,int val){
  Node *p = new Node();
  p->data = val;
  p->next = NULL;
  Node *temp = head;
  for(int i = 0;i < index;i ++){
    temp = temp->next;
  }
  p->next = temp->next;
  temp->next = p;
}
```

删除节点（根据值删除）：

```c++
void delete(int val){
  Node *pre = head;
  Node *cur = head->next;
  while(cur != NULL){
    if(cur->data == val){
      pre->next = cur->next;
      cur = cur->next;
      pre = pre->next;
    }else{
      cur = cur->next;
      pre = pre->next;
    }
  }
}
```

查找倒数第k个节点：

```c++
Node *findLast(int index){
  Node *fast = head;
  Node *slow = head;
  for(int i = 0;i < index;i ++){
    if(fast){
      fast = fast->next;
    }else{
      return nullptr;
    }
  }
  while(fast){
    slow = slow->next;
  }
  return slow;
}
```

#### 静态链表

用数组来模拟单链表的形式，数组中的每一项是一个对象，对象包含data和下一项的下标next<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201228221256671.png" alt="image-20201228221256671" style="zoom:70%;" />

#### 双向链表

由于多了一个指针，所以在插入和删除时需要更改两个指针变量

#### 循环链表

判断是否走到最后的条件为p->next == head;

应用：约瑟夫环



### 栈

#### 顺序存储

主要就是用数组模拟，用一个下标表示栈顶即可，初始为0：

```c++
class Stack{
  int data[100];// 用于存放栈的数据，最多可以存放100条数据
  int top;
  Stack(){
    top = -1;// 初始栈顶为-1
  }
};
```

判断栈空：top == -1;

入栈操作：

```c++
void push(int val){
  if(top >= 99){
    return; // 栈满了
  }else{
    data[++top] = val;
  }
}
```

出栈操作：

```c++
int pop(){
  if(top != -1){
    return data[top --];
  }
}
```

#### 链式存储

表头后一个作为栈顶元素，这样方便出栈和入栈：

```c++
class Node{
  int data;
  Node *next;
  Node(int val){
    data = val;
    next = NULL;
  }
};
class Stack{
  Node *head;
  Stack(){
    head = new Node(0);
  }
};
```

入栈操作：

```c++
void push(int val){
	Node *p = new Node(val);
  p->next = head->next;
  head->next = p;
}
```

出栈操作：

```c++
int pop(){
  if(head->next != NULL){
    Node *res = head->next;
    head->next = head->next->next;
    return res->data;
  }
}
```



###队列

#### 顺序存储

采用数组进行模拟，使用两个指针：front、rear。为了区分队空和队满，我们定义front指向队头元素，rear指向队尾的后一个元素，也就是说会空出一个元素空间，队满时数组中有一个空闲单元。

类定义：

```c++
class Queue{
  int data[MaxSize];
  int front;
  int rear;
  Queue(){
    front = MaxSize - 1;
    rear = MaxSize - 1;
  }
}
```

队空：rear == front

队满：(rear + 1) % MaxSize == front

入队：

```c++
void EnQueue(int value){
  if((rear + 1) % MaxSize == front){
    cout << "队列已满" << endl;
  }else{
    data[rear] = value;
    rear = (rear + 1) % MaxSize;
  }
}
```

出队：

```c++
int DeQueue(){
  if(rear == front){
    cout << "队空" << endl;
  }else{
    int res = data[front];
    front = (front + 1) % MaxSize;
    return res;
  }
}
```



#### 链式存储

头结点作为队首，指针front指向头结点，并有一个指针rear指向最后一个节点

类定义：

```c++
class Node{
  int data;
  Node* next;
  Node(int value){
    data = value;
    next = NULL;
  }
};
class Queue{
  Node* front;
  Node* rear;
  Queue(){
    front = new Node;
    front->next = NULL;
    rear = front;
  }
}
```

队空：rear == front;

队满：不存在满的情况

入队：

```c++
void EnQueue(int value){
  Node *p = new Node(value);
  rear->next = p;
  rear = p;
}
```

出队：

```c++
int DeQueue(){
  if(rear == front){
    cout << "队空" << endl;
    return;
  } 
  Node *p = front->next;
  int res = p->data;
  front->next = p->next;
  if(p->next == NULL) rear = front;
  delete p;
  return res;
}
```



### 树

#### 树的基本术语

+ 节点的度：节点所具有的子树的个数
+ 树的度：树中各节点的度的最大值
+ 树的路径长度：树中根节点到所有节点的路径之和
+ 叶子节点：度为0的节点，也称为终端节点
+ 分支节点：度不为0的节点，也称为非终端节点
+ 节点的层数：根节点的层数为1，其余节点以此类推
+ 树的深度：所有节点的最大层数，也称为高度
+ 森林：m棵互不相交的树的集合

一棵具有n个节点的树，其所有节点的度数之和为？(也就是所有的边之和，n-1)



#### 二叉树的基本术语

+ 满二叉树：高度为K，且有2^k^-1个节点的二叉树
+ 完全二叉树：所有的叶子都出现在k或者k-1层；k-1层的所有叶子都在非终端节点的右边；除了k-1层的最右非终端结点可能有一个（只能是左分支）或两个分支之外，其余非终端结点都有两个分支。![image-20201229222925493](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201229222925493.png)
+ + 其叶子节点只能出现在最后两层，且最下层的叶子节点都集中在二叉树的左部；如果有度为1的节点，只可能有1个且只有左孩子。
+ 二叉查找树**BST**：又叫做二叉搜索树、二叉排序树。每一个节点的左子树都小于该节点，右子树都大于该节点
+ 平衡二叉树**AVL**：根节点的左右子树的高度之差不超过1；且其左子树和右子树仍然是AVL树。简单来说就是：对于其所有节点，左右子树的高度差都不能超过1
+ 顺序存储二叉树 ：按照给出的数据的顺序依次进行存储（堆排序）
+ 线索二叉树：如果节点没有左节点则left指向其某一顺序遍历的前驱结点，如果没有右孩子，则right指向其某一顺序的后继节点

#### 二叉树的性质

+ 二叉树的第i层，最多有2^i-1^个节点
+ 高度为k的二叉树最多有2^k^ -1个节点(满二叉树)，最少有K个节点。
+ + 注意：高度为K且只有K个节点的二叉树不一定是斜树
+ 在非空二叉树中，如果有n~0~个叶子节点，n~2~个度为2的节点，则有n~0~ = n~2~ + 1.与度为1的节点数量无关。
+ + 证明：n = n~0~ + n~1~ + n~2~ . n个节点共有n-1条边：n-1 = 2n~2~ + n~1~ 两条式子结合：n~0~ = n~2~ + 1
+ 具有n个节点的完全二叉树的高度为：log~2~(n + 1)或 log~2~ n + 1
+ n个节点的二叉树，有2n-(n-1)=n+1个空指针

#### 二叉树的遍历

##### 前/先序遍历

顺序是由输出根节点，再输出左子树，最后输出右子树。代码：

```c++
void PreOrder(Node *root){
  if(root != NULL){
    cout << root->val;
    PreOrder(root->left);
    PreOrder(root->right);
  }
}
```

##### 中序遍历

顺序是由输出左子树，再输出根节点，最后输出右子树。代码：

```c++
void InOrder(Node *root){
  if(root != NULL){
    InOrder(root->left);
    cout << root->val;
    InOrder(root->right);
  }
}
```

##### 后序遍历

顺序是由输出左子树，再输出右子树，最后输出根节点。代码：

```c++
void PostOrder(Node *root){
  if(root != NULL){
    PostOrder(root->left);
    PostOrder(root->right);
    cout << root->val << endl;
  }
}
```

##### 层序遍历

顺序是一层层的输出，需要用到队列

```c++
void LevelOrder(Node *root){
  int front = 0;
  int rear = 0;
  Node *temp;
  Node *Q[100];
  Q[++rear] = root;
  while(front != rear){
    temp = Q[++front];
    cout << temp->val;
    if(temp->left) Q[++rear] = temp->left;
    if(temp->right) Q[++rear] = temp->right;
  }
}
```

##### 恢复二叉树

+ 根据前序和中序能唯一恢复一个二叉树

+ + 前序：ABCDEF、中序：CBAEDF

+ 根据中序和后序也能唯一恢复一个二叉树

+ + 中序：ABCDEFG、后序：BDCAFGE

+ 但是根据前序和后序不能唯一恢复一个二叉树

+ + 任何结点只有左子树的二叉树和任何结点只有右子树的二叉树，

    其前序序列相同，后序序列相同，但却是两棵不同的二叉树。

#### 二叉树的建立

##### 顺序式输入建立

按照顺序存储的样式进行输入，为0时代表节点为空。

先遍历，创建好节点并塞入数组中，新输入的下标为i，则它是(i+1)/2-1号下标的孩子节点。

```c++
Node* Create(int length;int a[]){
  Node *Q[100];
  Node *temp;
  Node *root;
  int j;
  for(let i = 0;i < length;i ++){
    temp = new Node(a[i]);
    if(a[i] == 0){
      Q[i] = NULL;
      continue;
    }
    if(i == 0){
      root = temp;
    }else{
      j = (i+1)/2-1;
      if((i+1)%2 == 0){
        Q[j]->left = temp;
      }else{
        Q[j]->right = temp;
      }
    }
  }
  return root;
}
```



#### 二叉树习题

##### 求二叉树的节点

```c++
int Count(Node *root){
  if(root == NULL) return 0;
  else return 1 + Count(root->left) + Count(root->right);
}
```

#####求二叉树的高度

```c++
int Height(Node *root){
  if(root == NULL) return 0;
  else return 1 + max(Height(root->lft),Height(root->right));
}
```

##### 翻转二叉树

```c++
Node *invertTree(Node *root){
  if(root == NULL) return NULL;
  Node *temp = root->right;
  root->right = root->left;
  root->left = temp;
  invertTree(root->left);
  invertTree(root->right);
  return r;
}
```

#### 树

![image-20201230222116266](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201230222116266.png)

##### 树的先序遍历

先访问根节点，按照从左到右的顺序先序遍历根节点的每一颗子树

上图的先序遍历顺序为：A B D E H I F C G

##### 树的中序遍历

中序遍历第一颗子树，然后访问根节点，再按照从左到右的顺序中序遍历根节点的其他子树

上图的中序遍历顺序为：D B H E I F A G C

##### 树的后序遍历

先按照从左到右的顺序后序遍历根节点的每一颗子树，再访问根节点

上图的后序遍历顺序为：D H I E F B G C A

##### 树的二叉树表示法

将数转换成二叉树，节点的左指针不变，依旧指向其左节点，右指针指向其兄弟节点。

![image-20201230221846076](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201230221846076.png)



#### 哈夫曼树

##### 定义

带权路径长度最小的二叉树称作哈夫曼树（最优二叉树）。

带权路径长度：树中所有叶子节点的带权路径长度之和

![image-20201230224454564](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201230224454564.png)

##### 特点

+ 权值越大的叶子节点越靠近根节点，权值越小的叶子节点越远离根节点
+ 只有度为0和度为2的节点，没有度为1的节点
+ n个叶节点的哈夫曼树的节点总数为2n-1个
+ 哈夫曼树不唯一但最小带权路径长度唯一

##### 构建方法

![image-20201230225107213](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201230225107213.png)

![image-20201231182637344](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20201231182637344.png)



### 图

#### 图的基本概念

+ 简单图：不存在顶点到其自身的边，且同一条边不重复出现
+ 无向完全图：任意两个顶点之间都存在边
+ 有向完全图：任意两个顶点之间都存在方向互为相反的两条弧
+ 邻接和依附：对于无向图来说，两个顶点如果存在边则互为邻接点，同时边称为依附于两点。对于有向图，两个顶点若存在有向边<a,b>，则称顶点a邻接到顶点b，称弧<a,b>依附于顶点a和顶点b
+ 网：带权的图
+ 度：和顶点相关联的边的数目
+ + 入度：是对于有向图来说的，边a->b对于a来说是入度
  + 出度：也是对于有向图来说的，边a->b对于b来说是出度
+ 简单路径：路径上的各顶点均互不相同
+ 连通图：图中任意两个顶点都是连通的（任意两点之间都存在路径）
+ 连通分量：**非连通图**的**极大连通子图**，极大要求连通子图包含所有的边![image-20210101203911309](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210101203911309.png)
+ 强连通图：在有向图中任意两个顶点之间都存在路径
+ 强连通分量：非强连通图的极大强连通子图
+ 连通图的生成树：包含图中全部定点的一个极小连通子图（保持图的联通且边数最小）。对于该生成树而言，若砍去一条边就会变成非连通图，若加上一条边就会形成一条回路![image-20210101205013272](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210101205013272.png)

#### 图的建立（以无向图为例）

##### 邻接矩阵

```c++
int matrix[100][100];
// 先将两点之间的距离设置为无限远9999
for(int i = 0;i < 99;i ++){
  for(int j = 0;j < 99;j ++){
    matrix[i][j] = 9999;
  }
}
// 根据输入的值：顶点a 顶点b 权值 来设置邻接矩阵
matrix[a][b] = weight;
matrix[b][a] = weight;
```



##### 邻接表

```c++
class VertexNode{
  int vertex;// 顶点的序号，如果题目给的是ABCD就是char 编号
  EdgesNode *firstEdge;// 第一条边
  VertexNode(int a){
    vertext = a;
    firstEdge = NULL;
  }
};

class EdgesNode{
  int vertex;// 顶点的序号，如果题目给的是ABCD就是char 编号
  int weight;// 权重
  EdgesNode *next;
  EdgesNode(int a,int b){
    vertex = a;
    weight = b;
    next = NULL;
  }
};

Vertex *vertexList[10];
// 根据输入的值：顶点a 顶点b 权值weight 来设置邻接表
EdgesNode *temp;
temp = new EdgesNode(b,weight);
vertexList[a]->firstEdge = temp;
temp = new EdgesNode(a,weight);
vertexList[b]->firstEdge = temp;

```

##### 两种存储结构的比较

![image-20210101213736270](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210101213736270.png)



#### 图的遍历（以邻接表为例，邻接矩阵类推）

##### 深度优先遍历

```c++
class Solution{
 	bool isVisited[10];
  void dfs(VertexNode *vertexList[],int a){
  	for(int i = 0;i < 9;i ++){
    	isVisited[i] = false;
  	}
  	if(vertexList[a] && isVisited[a] == false){
    	dfs1(vertexList,a,);
  	}
  	for(int i = 0;i < 10;i ++){
    	if(isVisited[i] == false){
      	dfs1(vertexList,i);
    	}
  	}
	}

	void dfs1(VertexNode *vertexList[],int i){
  	EdgesNode *p;
  	cout << vertexList[i]->vertex << " ";
  	isVisited[i] = true;
    p = vertexList[i]->firstEdge;
    while(p){
      if(isVisited[p->vertex] == false){
        dfs1(vertexList,p->vertex);
      }
      p = p->next;
    }
	}
}
```



##### 广度优先遍历

```c++
class Solution{
  bool isVisited[10];
  void bfs(VertexNode *vertexList[],int a){
    for(int i = 0;i < 10;i ++){
      isVisited[i] = false;
    }
    if(isVisited[a] == false && vertexList[a]){
      bfs1(vertexList,a);
    }
   	for(int i = 0;i < 10;i ++){
    	if(isVisited[i] == false){
      	bfs1(vertexList,i);
    	}
  	}
  }
  
  void bfs1(VertexNode *vertexList[],int i){
    EdgesNode *p;
    int Q[15];
    int front = 0;
    int rear = 0;
    int a;
    cout << vertexList[i]->vertex << " ";
    isVisited[vertexList[i]->vertex] = true;
    Q[++rear] = vertexList[i]->vertex;
    while(rear != front){
      a = Q[++front];
      p = vertexList[a]->firstEdge;
      while(p){
        if(isVisited[p->vertex] == false){
          cout << vertexList[p->vertex]->vertex << " ";
          isVisited[p->vertex] = true;
          Q[++rear] = p->vertex;
        }
        p = p->next;
      }
    }
  }
}
```

##### 复杂度分析

邻接矩阵的时间复杂度均为O(n^2^)

邻接表的时间复杂度为O(n+e)

空间复杂度bfs、dfs、邻接表邻接矩阵都为O(n)



#### 最小生成树

##### Prim

思想：先选取一个顶点放入集合U中。遍历集合U，找到集合U中的点到不在集合U中的顶点的距离的最小值，然后将点也塞入集合U中。重复直到U满为止。

实现：主要是两个数组LOWCOST和CLOSSET。其中LOWCOST用于存放集合U中的点到不在集合U中的点的距离的最小值，为infinity表示已经在最小生成树中；CLOSSET用于存放另一个顶点。

时间复杂度：O(n^2^)，适用于边多的图

```c++
void Prim(int C[n+1][n+1]){
  int i,j,k;
  int min;
  int LOWCOST[n+1];
  int CLOSSET[n+1];
  for(i = 2;i <= n;i ++){ // 初始化数组，先放入U的是1号顶点
    LOWCOST[1][i] = C[1][i];
    CLOSSET[i] = 1;
  }
  for(i = 2;i <= n;i ++){// 循环n-1次
    min = LOWCOST[i];
    k = i;
    for(j = 2;i <= n;j ++){// 找到LOWCOST中的最小值
      if(LOWCOST[j] < min){
        min = LOWCOST[j];
        k = j;
      }
    }
    cout << “(” << k << “,” << CLOSSET[k] << “)” << end1;
    LOWCOST[k] = Infinity;// 加入最小生成树中
    for(j = 2;j <= n;j ++){// 调整数组
      if(C[k][j] < LOWCOST[j] && LOWCOST[j]<Infinity){
        LOWCOST[j] = C[k][j];
        CLOSSET[j] = k;
      }
    }
  }
}
```

##### Kruskal

思想：将连通网的每一个顶点都看成是一个连通分量，然后按照边的权值从小到大的顺序，依次考察G的各条边。若边连接的是两个连通分量，则将边加入最小生成树中并将这两个连通分量连成一个，直到最后剩下一个连通分量。

实现：初始化U=V，TE={}；在E中选择最短边(u,v),如果u，v位于两个不同的连通分量则将边(u,v)加入TE；并把这两个连通分量合为一个，在E中标记边(u,v)使得(u,v)不参加后续最短边的选取。循环直到T中的连通分量个数为1。

整个算法的时间复杂度主要来源于排序，所以其时间复杂度为ElogE，适用于边少但是顶点多的图



#### 最短路径

##### Dijkstra

迪杰斯特拉求的是指定点到其他点的最短路径

思想：先初始化一个数组D，存储着指定点到其他点的距离，然后找出最短的，将最短的点塞入数组S中表示已经找到该点最短路径，再根据S中的点更新数组D中的最短距离，接着再选出最短的塞入S反复直到找到所有的最小值

```c++
int *Dijkstra(VertextNode *vertexList[], int a){
  int i,sum,w;
  static int D[10];
  bool S[10];
  for(i = 0;i < 10;i ++){
    if(i == a){
      D[i] = 9999;
    }else{
      D[i] = getDis(vertexList,a,i);
    } 
  }
  S[a] = true;
  for(i = 0;i < 10;i ++){
    w = minCost(D,S);
    S[w] = true;
    for(int k = 0;k < 10;k ++){
      if(S[k] == false){
        sum = D[w] + getDis(vertexList,w,k);
        if(sum < D[k]){
          D[k] = sum;
        }
      }
    }
  }
  return D;
}

int getDis(VertextNode *vertexList[], int a, int b){
  EdgesNode *temp;
  if (vertexList[a] == NULL || vertexList[b] == NULL){
      return 9999;
  }else{
    temp = vertexList[a] -> firstEdge;
    if(temp -> vertex == b){
      return temp->weight;
    }else{
      temp = temp->next;
      while(temp){
        if(temp->vertex == b){
          return temp->weight;
        }else{
          temp = temp->next;
        }
      }
    }
  }
  return 9999;
}

int minCost(int D[],bool S[]){
  int temp = 9999;
  int res = 0;
  for(int i = 0;i < 10;i ++){
    if(!S[i] && D[i] <temp){
      res = i;
      temp = D[i];
    }
  }
  return res;
}
```



##### Floyd

弗洛伊德解决的是两个顶点之间最短距离

思想：三层循环

```c++
void Floyd(int matrix[][10]){
    for (int i = 0; i < 10; i++)
    {
      for (int j = 0; j < 10; j++)
      {
        D[i][j] = matrix[i][j];
        // P[i][j] = -1;
      }
    }
    for (int k = 0; k < 10; k++)
    {
      for (int i = 0; i < 10; i++)
      {
        for (int j = 0; j < 10; j++)
        {
          if (D[i][k] + D[k][j] < D[i][j])
          {
            D[i][j] = (D[i][k] + D[k][j]);
          }
        }
      }
    }
  }
```



### 查找

<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210102142619893.png" alt="image-20210102142619893" style="zoom:67%;" />

#### 线性查找/顺序查找

就是按照index依次查找下去

时间复杂度：O(n),查找成功的平均时间复杂度：(n+1)/2，查找失败的平均时间复杂度：n+1

#### 折半查找/二分查找

```c++
int binarySearch(int a[],int target,int start,int end){
  if(start > target || end < target) return -1;
  int mid = (start+end)/2;
  if(a[mid] == target){
    return mid;
  }else if(a[mid] < target){
    return binarySearch(a,target,mid+1,end);
  }else{
    return binarySearch(a,target,start,mid-1);
  }
  
}
```

时间复杂度：O(log~2~n)，查找成功的平均时间复杂度：log~2~(n+1)-1，查找失败的平均时间复杂度：O(log~2~n)

![image-20210102152545905](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210102152545905.png)

n个元素，失败的节点有n+1个 。

成功查找的平均查找长度：1\*1+2\*2+3\*4+4\*4  / 11 = 33/11

失败查找的平均查找长度：3*4+4*8  / 12 = 44/12         

#### 分块查找

基本思想：均匀分块，块间有序，块内无序。也就是说，如果按照从小到大的顺序排列，第一块中的所有元素都要小于第二块中的所有元素。然后需要一个建块索引，存放每块中的最大/最小的元素。<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210102144730114.png" alt="image-20210102144730114" style="zoom:50%;" />

```c++
int indexSearch(int target,int last,int blocks,int index[],int a[],int length){
  // target是要查找的元素，last是结束位置，blocks是一共有几块，index[]是索引表，a[]是数组，length是每一块中的元素数量
  int i = 0,j;
  while((target > index[i]) && i < blocks){
    i ++;
  }
  if(i < blocks){
    j = i*L;
    while(k != a[j] && j <= (i+1)*L-1 && j < last){
      j ++;
    }
    if(k == a[j]) return j;
  }
  return -1;
}
```

#### 二叉查找树BST

二叉查找树的中序遍历结果是一个递增的序列

查找性能取决于二叉查找树的形态，在O(log~2~n)和O(n)之间，平均时间复杂度为O(log~2~n)

2 5 12 16 28 32 60 72



### 排序

最后一个非叶子结点：n/2 - 1,节点的序号为k，则其左子节点为2\*k+1,右子节点为2\*k+2

![image-20210102184520184](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210102184520184.png)

![image-20210102184544272](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210102184544272.png)



## 数据库

### 基本概念

+ 域：一组值的集合
+ 笛卡尔积：域与域之间每个值的组合。3*3 得到9条组合元组
+ 候选码/候选键：能唯一标识一个元组的属性组，可以是一个属性，也可以是多个属性的组合
+ 主码/主键：有多个候选码时指定一个作为主码，如果一个元组中所有属性共同构成其候选码，则成为全码
+ 外码/外键：与另一个关系的候选码相对应

### 关系代数

基本操作：并U、交∩、笛卡尔积×、连接⋈、投影π、选择σ

连接⋈包括：自然连接（两张表之间有属性项是相通的）、θ连接、等值连接



### 创建数据库/数据表

创建数据库：create database 数据库名称     例如：create database BBS

创建数据表：create table 表名(列名 数据类型，列名 数据类型，...)   例如：

```sql
create table Student(S# char(8) not null,Sname char(10),Ssex char(2),Sage integer,D# char(2),Sclass char(6));
```



### 增加数据

Insert into 表名[(列名...)] values(值)  

例如：

```sql
Insert into Student values('98030101','张三','男',20,'03','980301')
//或者
Insert into Student(S#,Sname,Ssex,Sage,D#,Sclass) values('98030101','张三','男',20,'03','980301')
```

### 删除数据

Delete From 表名 [Where 条件表达式]

例如：

```sql
Delete From Student Where S#='98030101';
```

### 更新数据

Update 表名 Set 列名=表达式|(子查询\)\[\[,列名=表达式|(子查询)]...][Where 条件表达式]

例如：

```sql
Update Teacher Set Salary = Salary*1.1 Where Tname='张三'
```

### 查询数据

Select 列名 From 表名 Where 条件

结果唯一：Distinct  加在Select语句中：Select Distinct S# From SC Where Score > 90;

结果排序：Order By 列名 ASC升序/DESC降序

模糊查询：like %(匹配0个或者多个字符)/_(匹配任意单个字符)