# 前端面试

## 大前端技术栈概览

### HTML5

1. 语义化标签
2. 音视频处理
3. canvas、webGL
4. history API（vue和react等路由的关键）
5. requestAnimationFrame（解决动画掉帧的问题）
6. 地理位置
7. web socket（长连接、轮询）
8. ......

### CSS3

1. 常规
2. 动画animation、transition
3. 盒子模型
4. 响应式布局
5. ......

### JS

1. ES3456789
2. dom
3. bom
4. 设计模式
5. 底层原理
   + 堆栈内存
   + 闭包作用域
   + 面向对象
   + this
   + 浏览器渲染原理
   + 回流、重绘

### 网络通信层

1. Ajax、Fetch、axios
2. http1.0/2.0
3. TCP
4. 跨域处理方案
5. 性能优化
6. ......

### Hybrid或者APP或者小程序

1. Hybrid
2. uni-app
3. react-native
4. flutter

### 工程化

1. webpack
2. git
3. linux、nginx



## HTML、css部分

### display：none和visibility：hidden的区别？

display会将该元素及其所有后代元素都隐藏，占据的空间消失，无法点击

visibility仍会占用空间，只是视觉上消失，仍然会影响页面的布局，给子元素设置visibility：visible会将子元素重新显示出来，这点与display不同。transition对于visibility的优化更好



### 盒子水平垂直居中的方案

1. css3的flex方案：在父元素上设置

   ```css
   display:flex;  
   justify-content:center; 
   align-items:center;
   ```

2. css3的transform方案(这个不要求盒子有固定的的宽和高)：在元素上设置：

   ```css
   position: absolute; 
   left:50%; 
   top:50%;
   transform:translate3d(-50%,-50%,0);
   ```

3. 已知盒子的大小（比如是200px*100px）：

   ```css
   position: absolute;
   left: 50%;
   right: 50%;
   margin-left:-100px;
   margin-top:-50px;
   ```

   或者有宽高，但我们不考虑的情况下,这个跟第二种transform差不多，但需要宽高：

   ```css
   position:absolute;
   left:0;
   top:0;
   right:0;
   bottom:0;
   margin:auto;
   ```

   

4. display:table-cell 的方式：在父元素设置：父元素还要有固定宽高

   ```css
   display:table-cell;
   text-align:center;
   vertical-align:center;
   width:500px;
   height:500px;
   ```

   还需要在子元素上：

   ```css
   display:inline-block
   ```



### 盒模型问题

1. 标准盒模型：box-sizing:content-box
2. IE盒模型（怪异盒模型）box-sizing:border-box   

 ==像 bootstrap等UI组件库中大多数都会设置盒模型为怪异盒模型，也就是设置box-sizing:border-box==

1. flex弹性伸缩盒模型：display:flex    



### css的几种经典布局

#### 圣杯布局

**圣杯布局就是三个元素被一个大标签包裹，中间自适应，两边有固定的宽度**

总体的思路就是：先将父元素设置一个padding为左右两边的宽度，然后设置左右两边的宽度并给center、left、right全都添加float：left。之后，对左边设置margin-left：-100%移动到center元素的最左边，然后设置position:relative; left:-200px；将左边的元素移到对应的位置。最后，给right设置margin-right:-200px将右边一过去

```css
// html部分
<div class="container clearfix">
	<div class="center"></div>
	<div class="left"></div>
	<div class="right"></div>
</div>
// css 部分
.container{
	height:100%;
  padding:0 200px; //200px就是左右两边的宽度
}
.left,
right{
  width:200px;
  min-height:200px;
  background:red;
}
.center{
  width:100%;
  min-height:400px;
  background:yellow;
}
.center,
.right,
.left{
  float:left;
}
.left{
  margin-left:-100%;// 这里就移到了center元素最左边，还需要往左边再移动200px
  positio:relative;
  left:-200px;
}
.right{
  margin-right:-200px;
}
```



#### 双飞翼布局

**双飞翼布局是中间被一个元素包裹，左右两边是单独的；两个元素**

```css
// html部分
<div class="clearfix">
	<div class="container">
		<div class="center"></div>
	</div>
	<div class="left"></div>
	<div class="right"></div>
</div>
// css部分
.container,
.left,
.right{
	float:left;
}
.container{
  width:100%;
}
.container .center{
  margin:0 200px;
  min-height:400px;
  background:red;
}
.left{
  width:200px;
  margin-left:-100%;
}
.right{
  width:200px;
  margin-left:-200px
}
```



## JS部分

### Symbol

**Symbol会生成唯一的一个值，并不会导致重复，可以解决对象中重复属性覆盖的问题**

**要创建一个Symbol不用new，因为Symbol是一种基本数据类型，直接let x = Symbol()即可**



### 对象的属性名只能是字符串吗？

**==错误！属性名还可以是Symbol类型！==**

**所有引用值作为对象的属性名，都会转换成字符串。所以，如果对象的属性名是一个另一个对象，则会默认将属性名转换为'[object Object]'，所以将多个对象作为属性名会导致被覆盖**



### alert输出

**alert输出的内容自动转换成字符串，对象会转换成[object Object]**



###经典闭包问题

```js
var a = 0,b = 0;
function A(a){
  A = function(b){
    alert(a+ b++);
  };
  alert(a++)
}
A(1);// 1
A(2);// 4

```

**为什么呢？**

**首先，在外层函数A内并没有声明A，所以内层的A函数会跑到外面去替代掉外层的A，然后，由于js函数的作用域看的是定义时候的作用域，所以第二次的a是1++也就是2，最终结果就是2+2 = 4**

```js
再来一题：
var x = 0,y = 1;
funtion fn(){
  x += 2;
  fn = function(y){
    console.log(y+(--x));
  };
  console.log(x,y)
}
fn(3);
fn(4);
console.log(x,y)
```

**答案：（2,1）、5、（1,1）**

```js
// 再做一题
var x = 2;
var y = {
    x:3,
    z:(function(x){
        this.x *= x;
        x += 2;
        return function(n){
            this.x *= n;
            x += 3;
            console.log(x)
        }
    })(x)
};
var m = y.z;
m(4);
y.z(5)
console.log(x,y.x)
```

**答案：7、10、（16,15）**

### async等执行顺序

**浏览器的执行顺序：先执行主线任务，主线任务遇到await会执行await后面的函数并等待其返回结果将await下面的所有语句塞入微任务中，然后跳到下一步继续执行主线任务，遇到setTImeout会塞入宏任务。主线任务执行完毕后，会先执行微任务最后执行宏任务**

==宏任务：事件绑定，定时器，ajax==

==微任务：async、await、promise==

```js
async function async1(){
  console.log("async1 start")
  await async2();
  console.log("async1 end")
}
async function async2(){
  console.log("async2")
}
console.log("script start")
setTimeout(() => {
  console.log("setTimeout")
},0)
async1()
new Promise(function (resolve){
  console.log("promise1")
  resolve()
}).then(function(){
  console.log("promise2")
})
console.log("script end");

最终的输出顺序为：
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

