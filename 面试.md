#  前端面试(CSIG不问算法？)

## 大前端技术栈概览

### HTML5

1. 语义化标签
2. 音视频处理
3. canvas、webGL
4. history API（vue和react等路由的关键）
5. requestAnimationFrame（解决动画掉帧的问题）
6. 地理位置
7. web socket（长连接、轮询）
8. ......

### CSS3

1. 常规
2. 动画animation、transition
3. 盒子模型
4. 响应式布局
5. ......

### JS

1. ES3456789
2. dom
3. bom
4. 设计模式
5. 底层原理
   + 堆栈内存
   + 闭包作用域
   + 面向对象
   + this
   + 浏览器渲染原理
   + 回流、重绘

### 网络通信层

1. Ajax、Fetch、axios
2. http1.0/2.0
3. TCP
4. 跨域处理方案
5. 性能优化
6. ......

### Hybrid或者APP或者小程序

1. Hybrid
2. uni-app
3. react-native
4. flutter

### 工程化

1. webpack
2. git
3. linux、nginx



## 编程思想

### 面向过程AOP

以事件为中心，按照解决问题的步骤来实现代码。优点是流程化，步骤清晰明了。缺点是不易维护、不易复用、不易扩展。

### 面向对象OOP

以对象为中心，将问题拆解为一个个对象的实现，对象有自己的属性和方法，对象之间可以通过方法来进行交互。对象的目的不是要完成问题的某一个步骤，而是为了描述该对象在问题中的属性和行为。优点是易扩展、易维护、结构清晰。缺点是开销大，需要实例化对象以及定义一些对象中的逻辑方法（如不能直接从外部存取）。特性是封装、继承、多态。

### 函数式编程FP

函数式编程将函数作为一等公民，一切皆由函数实现，函数多采用纯函数（同样的输入得到同样的输出，不能引用外部变量）、

在js中实现函数式编程FP常用的函数有compose、curry

其中compose接收无数个参数，每个参数都是函数，会按照从右到左的顺序执行，并把执行结果传递给下一个函数，最后返回一个函数：

```js
// 通过 find 函数找到学生
var find = curry(function(db, id) {
    var obj = db.get(id)
    if(obj === null) {
        throw new Error('not fount')
    }
    
    return obj
})
// 将学生对象 format
var csv = (student) => `${student.id},${student.name},${student.lastname}`
// 在屏幕上显示
var append = curry(function(elementId, info) {
    document.querySelector(elementId).innerHTML = info
})
var showStudent = compose(append('#student-info')(), csv, find(db))

showStudent('666')
 //相当于以下代码：
append('#studenet-info')(csv(find(db)('666')))

```

### 命令式编程

最常见的：jquery

### 声明式编程

Vue





## 设计模式

### 创造型模式

+ 单例模式
+ 工厂模式（简单工厂、抽象工厂）
+ 原型模式

### 结构型模式

+ 装饰器模式
+ 适配器模式

### 行为型模式

+ 命令模式
+ 迭代器模式
+ 观察者模式（发布订阅模式）
+ 策略模式



## HTML、css部分

PWA

全称是 Progressive Web App，翻译过来就是渐进式网页应用。根据字面意思，它就是“渐进式 +Web 应用”。对于 Web 应用很好理解了，就是目前我们普通的 Web 页面，所以 PWA 所支持的首先是一个 Web 页面。

Web页面与本地应用的差距

+ 首先，Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。
+ 其次，Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。
+ 最后，Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。

上面两个缺陷可以通过Service Worker解决；最后一个可以通过manifest.json文件解决。



### WebComponent组件化开发

WebComponent 提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。

WebComponent 是一套技术的组合，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和HTML templates（HTML 模板）

```html
<!DOCTYPE html>
<html>
<body>
    <!--
            一：定义模板
            二：定义内部CSS样式
            三：定义JavaScript行为
    -->
    <template id="geekbang-t">
        <style>
            p {
                background-color: brown;
                color: cornsilk
            }

            div {
                width: 200px;
                background-color: bisque;
                border: 3px solid chocolate;
                border-radius: 10px;
            }
        </style>
        <div>
            <p>time.geekbang.org</p>
            <p>time1.geekbang.org</p>
        </div>
        <script>
            function foo() {
                console.log('inner log')
            }
        </script>
    </template>
    <script>
        class GeekBang extends HTMLElement {
            constructor() {
                super()
                //获取组件模板
                const content = document.querySelector('#geekbang-t').content
                //创建影子DOM节点
                const shadowDOM = this.attachShadow({ mode: 'open' })
                //将模板添加到影子DOM上
               shadowDOM.appendChild(content.cloneNode(true))
            }
        }
        customElements.define('geek-bang', GeekBang)
    </script>


    <geek-bang></geek-bang>
    <div>
        <p>time.geekbang.org</p>
        <p>time1.geekbang.org</p>
    </div>
    <geek-bang></geek-bang>
</body>
</html>
```



### 浏览器发展史

#### 单进程

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：

![img](https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png)

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。

+ 问题 1：不稳定。早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。
+ 问题 2：不流畅。从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。
+ 问题 3：不安全。这里依然可以从插件和页面脚本两个方面来解释该原因。插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。

#### 多进程

![img](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png)

从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

+ 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
+ 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
+ GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
+ 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
+ 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。



### 在浏览器输入网址到页面展示经历了什么

主要分为以下六个步骤：查找强缓存、DNS域名解析、建立TCP连接、发送HTTP请求、关闭TCP连接、浏览器渲染。会先在本地查找是否有强缓存，如果有且没过期就直接显示。

#### 查找强缓存

会先检查强缓存，如果命中则直接使用否则进入下一步

#### DNS域名解析

在客户端输入URL后，会有递归查找的过程。从浏览器缓存中查找->本地的hosts文件查找->找本地DNS解析器缓存查找->本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下：<img src="https://user-gold-cdn.xitu.io/2020/1/30/16ff45e132f02931?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="GitHub" style="zoom:67%;" />





#### 建立TCP连接

首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL / TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。

进行三次握手，建立TCP连接。

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

SSL握手过程

1. 第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数
2. 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
3. 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
4. 第四阶段 变更密码构件和结束握手协议



#### 发送HTTP请求

TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.



#### 准备渲染（提交文档）

1. 根据是否同一站点（相同的协议和根域名），决定是否复用渲染进程
2. 浏览器进程接收到网络进程的响应头数据后会向渲染进程发送“提交文档”消息
3. 渲染进程接收到“提交文档”消息后，与网络进程建立传输数据管道
4. 传输完成后，渲染进程返回“确认提交”的消息给浏览器进程
5. 浏览器进程接收“确认提交”消息后，移除旧文档，更新界面、地址栏和导航历史状态等，进入渲染阶段



#### 浏览器渲染

按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图：

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff48eeecb52d79?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



1. 渲染进程将 HTML 内容转换为能够读懂DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分图块，并栅格化将图块转换成位图。
7. 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

##### 构建 DOM 树

浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树,先将HTML的原始字节数据转换为文件指定编码的字符,然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45efe1080a3b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



具体步骤：

1. Tokens 化（Bytes-> Tokens）—— 通过分词器将字节流转换成一个个的Token，分为Tag Token和文本Token
2. 解析并构建DOM树(Tokens->Nodes->DOM Tree)—— 解析阶段维护了一个栈结构，第一阶段生成的Token会根据顺序压入，具体规则如下：
   + 如果是StartTag Token，会创建一个DOM节点并将该节点加入到DOM树中，其父节点就是栈中相邻的元素生成的节点
   + 如果是文本Token，则不会压入栈中，而是生成一个文本节点并加入到DOM树中，其父节点就是当前栈顶的Token所对应的DOM节点
   + 如果是EndTag Token，会将栈顶的StartTag弹出，表示当前的DOM解析完成

##### 样式计算

渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

CSS 样式来源主要有 3 种，分别是`通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。`,其样式计算过程主要为：

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45e91f199812?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为CSSOM的构建过程。



##### 页面布局

布局过程，即排除 `script、meta` 等功能化、非视觉节点，排除 `display: none` 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45e923b3d786?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

布局树的基本结构搭建完成后，渲染引擎会给对应的DOM元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终的布局树的构建。



##### 生成分层树

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），如图：

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45e925391019?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。在浏览器中，你可以打开 Chrome 的"开发者工具"，选择"Layers"标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？



##### 图层绘制

渲染引擎将一个图层的绘制拆分成很多小的绘制指令，然后将这些指令按照顺序组成一个待绘制列表。接下来会将该绘制列表提交给合成线程



##### 栅格化

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。在首次合成的时候回使用一个低分辨率的而图片，然后展示这个低分辨率的图片，等到正常的内容绘制完成后会替换掉当前显示的低分辨率内容。



![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45f311bb8934?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

##### 显示

最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令将页面绘制到内存中，再将内存显示到显示器上，渲染过程完成。



### 回流(又叫重排)和重绘

#### 回流(又叫重排)

当render tree中的某一部分由于某种原因(元素尺寸、布局、显示与隐藏等)需要重新构建，就会触发回流。每个页面都需要至少一次回流，就是在页面第一次加载的时候，这时候一定会发生回流，因为要构建render tree。在回流的时候，浏览器会将render tree中受到影响的部分失效并重新绘制。当我们使用js进行读写offset、scroll、client属性的时候也会触发回流操作

#### 重绘

当render tree中一些元素更新属性，但这些属性只是影响元素的外观而不影响其他元素的布局的，（例如background-color），称为重绘

#### 区别

回流一定会引起重绘，重绘不一定会引起回流



### BFC

全称Block Formatting Context，块级格式化上下文。

（1）内部的盒子会在垂直方向，一个个地放置； （2）盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠； （3）每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此； （4）BFC的区域不会与float重叠； （5）BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此； （6）计算BFC的高度时，浮动元素也参与计算。

#### 触发条件

（1）float的属性不为none； （2）position为absolute或fixed； （3）display为inline-block，table-cell，table-caption，flex； （4）overflow不为visible



### meta标签属性

meta标签有以下三大类属性：charset属性、name+content属性、http-equiv属性：

#### charset属性

用于定义文档的字符集

```html
<meta charset="utf-8">
```

#### name+content属性

```html
<!-- 网页作者 -->
<meta name="author" content="开源技术团队"/>
<!-- 网页地址 -->
<meta name="website" content="https://sanyuan0704.github.io/frontend_daily_question/"/>
<!-- 网页版权信息 -->
<meta name="copyright" content="2018-2019 demo.com"/>
<!-- 网页关键字, 用于SEO -->
<meta name="keywords" content="meta,html" />
<!-- 网页描述 -->
<meta name="description" content="网页描述" />
<!-- 搜索引擎索引方式，一般为all，不用深究 -->
<meta name="robots" content="all" />
<!-- 移动端常用视口设置 -->
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no" />
<!-- 
  viewport参数详解：
  width：宽度（数值 / device-width）（默认为980 像素）
  height：高度（数值 / device-height）
  initial-scale：初始的缩放比例 （范围从>0 到10）
  minimum-scale：允许用户缩放到的最小比例
  maximum-scale：允许用户缩放到的最大比例
  user-scalable：用户是否可以手动缩 (no,yes)
 -->
```

#### http-equiv属性

```html
<!-- expires指定网页的过期时间。一旦网页过期，必须从服务器上下载。 -->
<meta http-equiv="expires" content="Fri, 12 Jan 2020 18:18:18 GMT"/>
<!-- 等待一定的时间刷新或跳转到其他url。下面1表示1秒 -->
<meta http-equiv="refresh" content="1; url=https://www.baidu.com"/>
<!-- 禁止浏览器从本地缓存中读取网页，即浏览器一旦离开网页在无法连接网络的情况下就无法访问到页面。 -->
<meta http-equiv="pragma" content="no-cache"/>
<!-- 也是设置cookie的一种方式，并且可以指定过期时间 -->
<meta http-equiv="set-cookie" content="name=value expires=Fri, 12 Jan 2001 18:18:18 GMT,path=/"/>
<!-- 使用浏览器版本 -->
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<!-- 针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色，content的值为default | black | black-translucent -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
```



### src和href的区别

src是source的简写，目的是将文件下载到html页面中去

href是Hypertext Reference的简写，表示超文本引用

src常见于img、script、iframe；href常见于a、link（css）

src用于替换当前内容，href用于建立联系

**浏览器在遇到href时会并行的下载资源且不会停止对当前文档的处理，这也就是建议使用link而不是import的原因。遇到src时会暂停其他资源的下载和处理并直到该资源加载或者执行完毕，这也就是将script标签放在最后的原因（有defer和sync的除外）**



### async和defer

这两个属性都会使得script的加载过程异步，也就是加载的过程不会阻塞html的解析。但加载完成后二者的执行顺序不一致

#### async

async 的脚本会在加载完成后立即执行，也就是说加载完成后会阻塞html 的解析

#### defer

defer的脚本在加载完成后不会立即执行，而是会在整个文档解析完毕后（DOMContentLoaded事件发生）再执行，不会阻塞html的解析。



### 浏览器兼容问题及解决方案

首先说一下兼容性问题产生的原因，主要是内核的不一致导致的。IE使用的是Trident，Chrome是Blink，Firefox是Gecko，Opera以前是Presto，现在也是Blink。

常见的兼容性问题有：

1. 不同内核浏览器下部分标签默认的margin和padding不同。解决方案：通配符\*{padding:0;margin:0}

2. IE双边距问题，在IE6？中同时设置float 和 margin会出现边距问题。解决方案：display：inline

3. 图片默认存在间距问题。解决方案：可以使用float布局

4. 边距重叠问题，就是当相邻的两个元素都设置了margin时，margin将取最大值。解决方案：给子元素增加一个父级元素，并设置父元素overflow：hidden

5. css书写样式的兼容性问题，解决方案：在前面加上前缀，内核名称

6. 获取视口宽高问题

   ```js
   // 大部分浏览器：
   var w = window.innerWidth;
   var h = window.innerHeight;
   // IE浏览器：
   var w = document.documentElement.clientWidth;
   var h = document.documentElement.clientHeight;
   //或者
   var w = document.body.clientWidth;
   var h = document.body.clientHeight;
   ```
   
7. 获取滚动条滚动距离

   ```js
   function getScrollOffset(){
   	if(window.pageXOffset){
       return {
         x:window.pageXOffset,
         y:window.pageYOffset
       }
     }else{
       return {
         x: document.body.scrollLeft + document.documentElement.scrollLeft,
         y: document.body.scrollTop + document.documentElement.scrollTop,
       }
     }
   }
   ```

8. 取消冒泡

   ```js
   function stopBubble(event){
     if(event.stopPropagation){
       event.stopPropagation()
     }else{
       event.cancelBubble = true
     }
   }
   ```

9. 阻止默认事件

   ```js
   function cancelHandler(e){
     if(e.preventDefault){
       e.preventDefault()
     }else{
       e.returnValue = false,
     }
   }
   ```

   

### display：none和visibility：hidden的区别？

display会将该元素及其所有后代元素都隐藏，占据的空间消失，无法点击，不会出现在render tree中

visibility仍会占用空间，只是视觉上消失，仍然会影响页面的布局，给子元素设置visibility：visible会将子元素重新显示出来，会出现在render tree中，这点与display不同。transition对于visibility的优化更好



### 盒子水平垂直居中的方案

1. css3的flex方案：在父元素上设置

   ```css
   display:flex;  
   justify-content:center; 
   align-items:center;
   ```

2. css3的transform方案(这个不要求盒子有固定的的宽和高)：在元素上设置：

   ```css
   position: absolute; 
   left:50%; 
   top:50%;
   transform:translate3d(-50%,-50%,0);
   ```

3. 已知盒子的大小（比如是200px*100px）：

   ```css
   position: absolute;
   left: 50%;
   top: 50%;
   margin-left:-100px;
   margin-top:-50px;
   ```

   或者有宽高，但我们不考虑的情况下,这个跟第二种transform差不多，但需要宽高：

   ```css
   position:absolute;
   left:0;
   top:0;
   right:0;
   bottom:0;
   margin:auto;
   ```

   

4. display:table-cell 的方式：在父元素设置：父元素还要有固定宽高

   ```css
   display:table-cell;
   text-align:center;
   vertical-align:center;
   width:500px;
   height:500px;
   ```

   还需要在子元素上：

   ```css
   display:inline-block
   ```

### 可继承的css属性

+ 字体系列：font-family、font-weight、font-size、font-style
+ 文本系列：text-indent、text-align、line-height、color、word-spacing、letter-spacing
+ 元素可见性：visibility
+ 列表布局属性：list-style
+ 光标属性：cursor

### rem和em

rem是相对于html根元素的大小，即html根元素字体是16px则10rem=160px

em是相对于父元素的大小

在移动端适配问题上，可以采用rem的方式来做。统一采用rem，再添加脚本根据浏览器的视口宽改变html根元素的字体大小达到移动端适配的目的

```js
// 下面写一个设置rem的方式，html根元素的字体大小为视口宽的十分之一
function setRem(){
  let winWidth = document.documentElement.offsetWidth
  document.documentElement.style.fontSize = winWidth/10
}
```



### 盒模型问题

1. 标准盒模型：box-sizing:content-box
2. IE盒模型（怪异盒模型）box-sizing:border-box   

 ==像 bootstrap等UI组件库中大多数都会设置盒模型为怪异盒模型，也就是设置box-sizing:border-box==

1. flex弹性伸缩盒模型：display:flex    



### 当相邻的两个元素都设置inline-block时的留白问题

当两个相邻元素都设置了inline-block时会出现一段空隙

原因是元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据CSS中white-space属性的处理方式（默认是normal，合并多余空白），原来`HTML代码中的回车换行被转成一个空白符`，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。

解决方式：

1. 将两个元素紧挨着写：

   ```html
   <div class="container">
     <div class="left">
         左
     </div><div class="right">
         右
     </div>
   </div>
   ```

2. 设置父元素的font-size=0，子元素设置为正常值

   ```css
   .container{
     width:800px;
     height:200px;
     font-size: 0;
   }
   ```

3. 给子元素设置float：left

   ```css
   .left{
     float: left;
     font-size: 14px;
     background: red;
     display: inline-block;
     width: 100px;
     height: 100px;
   }
   //right是同理
   ```



### css的几种经典布局

#### 圣杯布局

**圣杯布局就是三个元素被一个大标签包裹，中间自适应，两边有固定的宽度**

总体的思路就是：先将父元素设置一个padding为左右两边的宽度，然后设置左右两边的宽度并给center、left、right全都添加float：left。之后，对左边设置margin-left：-100%移动到center元素的最左边，然后设置position:relative; left:-200px；将左边的元素移到对应的位置。最后，给right设置margin-right:-200px将右边一过去

```css
// html部分
<div class="container clearfix">
	<div class="center"></div>
	<div class="left"></div>
	<div class="right"></div>
</div>
// css 部分
.container{
	height:100%;
  padding:0 200px; /*200px就是左右两边的宽度*/
}
.left,
.right{
  width:200px;
  min-height:200px;
  background:red;
}
.center{
  width:100%;
  min-height:400px;
  background:yellow;
}
.center,
.right,
.left{
  float:left;
}
.left{
  margin-left:-100%;// 这里就移到了center元素最左边，还需要往左边再移动200px
  position:relative;
  left:-200px;
}
.right{
  margin-right:-200px;
}
```



#### 双飞翼布局

**双飞翼布局是中间被一个元素包裹，左右两边是单独的；两个元素**

```css
// html部分
<div class="clearfix">
	<div class="container">
		<div class="center"></div>
	</div>
	<div class="left"></div>
	<div class="right"></div>
</div>
// css部分
.container,
.left,
.right{
	float:left;
}
.container{
  width:100%;
}
.container .center{
  margin:0 200px;
  min-height:400px;
  background:red;
}
.left{
  width:200px;
  margin-left:-100%;
}
.right{
  width:200px;
  margin-left:-200px
}
```

### 多种方式实现两栏布局

+ 左边浮动，右边给margin-left

  ```html
  // html部分
  <body>
    <div class="left"></div>
    <div class="main"></div>
  </body>
  
  // css部分
  html,body {
      /*width: 100%;*/
      height: 100%;   // html,body 默认高度为 0
      margin: 0;
      padding: 0;
  }
  .left {
      width: 200px;
      height: 100%;	// 撑满整个页面高度
      float: left;	// 左边浮动
      background: orange;
  }
  .main {
      height: 100%;	// 撑满整个页面高度
      margin-left: 200px;	//距左边距200px
      background: green;
  }
  ```

+ 左边浮动，右边设置overflow：hidden开启BFC

  ```html
  // html部分
  <body>
    <div class="left"></div>
    <div class="main"></div>
  </body>
  
  // css部分
  html,body {
      /*width: 100%;*/
      height: 100%;   // html,body 默认高度为 0
      margin: 0;
      padding: 0;
  }
  .left {
      width: 200px;
      height: 100%;	// 撑满整个页面高度
      float: left;	// 左边浮动
      background: orange;
  }
  .main {
      height: 100%;	// 撑满整个页面高度
      overflow:hidden; // 开启BFC
      background: green;
  }
  ```

+ 左边设置absolute，右边设置marginleft

  ```
  // html部分
  <body>
    <div class="left"></div>
    <div class="main"></div>
  </body>
  
  // css部分
  html,body {
      /*width: 100%;*/
      height: 100%;   // html,body 默认高度为 0
      margin: 0;
      padding: 0;
      position:relative;
  }
  .left {
      width: 200px;
      height: 100%;	// 撑满整个页面高度
      position: absolute; // 设置绝对定位
      background: orange;
  }
  .main {
      height: 100%;	// 撑满整个页面高度
      margin-left: 200px;	//距左边距200px
      background: green;
  }
  ```

+ flex布局，右边给flex：1

  ```html
  // html部分
  <body>
    <div class="left"></div>
    <div class="main"></div>
  </body>
  
  // css部分
  html,body {
      /*width: 100%;*/
      height: 100%;   // html,body 默认高度为 0
      margin: 0;
      padding: 0;
      display:flex;
  }
  .left {
      width: 200px;
      height: 100%;	// 撑满整个页面高度
      background: orange;
  }
  .main {
      height: 100%;	// 撑满整个页面高度
      flex:1; // 自动占满剩余空间
      background: green;
  }
  ```


### 实现骰子布局

大概是这样的结构：    

​          X

​    X

X

主要使用到的是flex布局的align-self

```html
<style>
  .main{
    width:500px;
    height:500px;
    display:flex;
    justify-content:space-between;
  }
  .child{
    width:50px;
    height:50px;
    background-color:red;
  }
  .child1{
    align-self:flex-end;
  }
  .child2{
    align-self:center;
  }
  .child1{
    align-self:flex-start;
  }
</style>
<div class="main">
  <div class="child child1"></div>
  <div class="child child2"></div>
  <div class="child child3"></div>
</div>
```

​               

### requestAnimationFrame

这个API通常是用来代替setTimeout或者setInterval做动画的，会默认将内部的函数在1000/ 60 ms后执行一次

与SetTimeout和setInterval不同的是，requestAnimationFrame性能更高，且会将一帧内所有的dom操作都集中在一起完成，具体使用如下：

```js
function clg(){
	consoloe.log(1);
	requestAnimationFrame(clg)
}
clg()
// 这样就实现了每16.6ms输出一次1
```

同时还可以取消：let timer = requestAnimationFrame(xxx);  cancelAnimationFrame(timer);



### css实现0.5px的线

设置border-width=0.5px会自动转为1px

+ 使用background-image+渐变。设置线性渐变，从透明到有颜色：

  ```css
  .five{
    backbround-imgae:linear-gradinet(bottom,black 50%,transparent 50%);
    background-size:100% 1px;
    
  }
  ```

+ 使用伪元素+scale：

  ```css
  .five::before{
    content:"";
    display:block;
    width:100%;
    height:1px;
    transform:scaleY(0.5);
    background:black
  }
  ```

###js获取css属性的方法

+ getComputedStyle(dom元素).name。可以获取到当前元素所有的css属性值，是一个只读属性，并且与offset一样，会引起回流
+ dom元素.currentStyle.name。这个是IE上相对于getComputedStyle的做法
+ dom.offsetLeft/offsetWidth  获取，其中会算上padding+width+border
+ dom.getClientRects()[0].name 获取

## JS部分

### 语言的类型区分

+ 静态语言vs动态语言：在使用之前需要确认其变量数据类型的称为静态语言（例如c++、c、java）；在运行过程中检查数据类型的语言称为动态语言（例如js、python）
+ 强类型vs弱类型：不支持隐式类型转换的叫做强类型语言（python、java），支持隐式类型转换的语言叫做弱类型语言（例如c、js、c++）
+ 编译型语言vs解释型语言：编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。



### JS的执行过程

首先js是一门解释性语言，对于解释性语言来说，执行过程一般是这样的：解释器先通过词法分析和语法分析生成AST抽象语法树，然后生成字节码，最后解释器根据字节码来执行程序。

#### 生成AST

生成 AST 分为两步——词法分析和语法分析。

词法分析即分词，它的工作就是将一行行的代码分解成一个个token。 比如下面一行代码:

```js
let name = 'sanyuan'
```

其中会把句子分解成四个部分:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b7d3513ebf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

即解析成了四个token，这就是词法分析的作用。

接下来语法分析阶段，将生成的这些 token 数据，根据一定的语法规则转化为AST。举个例子：

```js
let name = 'sanyuan'
console.log(name)
```

最后生成的 AST 是这样的:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b7ff6b0f513?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码。顺便补充一句，babel 的工作原理就是将 ES6 的代码解析生成`ES6的AST`，然后将 ES6 的 AST 转换为 `ES5 的AST`,最后才将 ES5 的 AST 转化为具体的 ES5 代码。

回到 V8 本身，生成 AST 后，接下来会生成执行上下文。

#### 生成字节码

开头就已经提到过了，生成 AST 之后，直接通过 V8 的解释器(也叫Ignition)来生成字节码。但是`字节码`并不能让机器直接运行，那你可能就会说了，不能执行还转成字节码干嘛，直接把 AST 转换成机器码不就得了，让机器直接执行。确实，在 V8 的早期是这么做的，但后来因为机器码的体积太大，引发了严重的内存占用问题。

给一张对比图让大家直观地感受以下三者代码量的差异:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b822da9857c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

很容易得出，字节码是比机器码轻量得多的代码。那 V8 为什么要使用字节码，字节码到底是个什么东西？

> 字节码是介于AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。

字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。

#### 执行代码

接下来，就进入到字节码解释执行的阶段啦！

在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做`热点代码`(HotSpot)，然后将这么代码编译成`机器码`保存起来，这个用来编译的工具就是V8的`编译器`(也叫做`TurboFan`) , 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为`热点代码`，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。

其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。而编译器和解释器的 根本区别在于前者会编译生成二进制文件但后者不会。

并且，这种字节码跟编译器和解释器结合的技术，我们称之为`即时编译`, 也就是我们经常听到的`JIT`。

这就是 V8 中执行一段JS代码的整个过程，梳理一下:

1. 首先通过词法分析和语法分析生成 `AST`
2. 将 AST 转换为字节码
3. 由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率



### EventLoop

**宏任务：setTimeout、setInterval、setImmediate(Node)、requestAnimation(浏览器)、IO、UI rendering**

**微任务：process.nextTick(Node)、Promise、Object.observe、MutationObserver**

#### 浏览器中的EventLoop

1. 一开始整段脚本作为第一个**宏任务**执行
2. 执行过程中同步代码直接执行，**宏任务**进入宏任务队列，**微任务**进入微任务队列
3. 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空
4. 执行浏览器 UI 线程的渲染工作
5. 执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

#### Node中的EventLoop

首先，明确Node中的宏任务主要有四个队列：

+ Timer Queue：setTimeout、setInterval
+ IO Callbacks Queue：除了close、timer、setImmediate之外的callbacks
+ Check Queue：setImmediate
+ Close Callbacks Queue：socket.on('close',...)这些callbacks

微任务也有两个队列：

+ Next Tick Queue：process.nextTick
+ Other Micro Queue：其他微任务，如Promise等

**总体的EventLoop如下：**

1. 执行全局Script的同步代码
2. 执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务
3. 开始执行macrotask宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段macrotask中的所有任务，最新版本的Node中和浏览器的Event Loop一样，只取宏队列的第一个任务出来执行，每一个小任务执行完成后会继续步骤2
4. Timers Queue -> 步骤2 -> I/O Queue -> 步骤2 -> Check Queue -> 步骤2 -> Close Callback Queue -> 步骤2 -> Timers Queue ......

从上面的顺序看应该是先setTimeout再setImmediate，但要注意一个问题，setTimeout(callbacks,0)和setImmediate(callbacks)的执行顺序是随机的。实际上有两种情况：

第一种情况，同步代码执行完了，Timer还没到期，setImmediate回调先注册到Check Queue中，开始执行微队列，然后是宏队列，先从Timers Queue中开始，发现没回调，往下走直到Check Queue中有回调，执行，然后timer到期（只要在执行完Timer Queue后到期效果就都一样），timer回调注册到Timers Queue中，下一轮循环执行到Timers Queue中才能执行那个timer 回调；**所以，这种情况下，setImmediate(fn)回调先于setTimeout(fn, 0)回调执行**。

第二种情况，同步代码还没执行完，timer先到期，timer回调先注册到Timers Queue中，执行到setImmediate了，它的回调再注册到Check Queue中。 然后，同步代码执行完了，执行微队列，然后开始先执行Timers Queue，先执行Timer 回调，再到Check Queue，执行setImmediate回调；**所以，这种情况下，setTimeout(fn, 0)回调先于setImmediate(fn)回调执行**。

但是如果把他们放在一个IO的回调，比如readFile('xx', function () {// ....})回调中，那么IO回调是在IO Queue中，setTimeout到期回调注册到Timers Queue，setImmediate回调注册到Check Queue，IO Queue执行完到Check Queue，timer Queue得到下个周期，所以setImmediate回调这种情况下肯定比setTimeout(fn, 0)回调先执行。

```js
console.log('start');

setTimeout(() => {          // callback1
  console.log(111);
  setTimeout(() => {        // callback2
    console.log(222);
  }, 0);
  setImmediate(() => {      // callback3
    console.log(333);
  })
  process.nextTick(() => {  // callback4
    console.log(444);  
  })
  console.log('xxx')
}, 0);

setImmediate(() => {        // callback5
  console.log(555);
  process.nextTick(() => {  // callback6
    console.log(666);  
  })
})

setTimeout(() => {          // callback7           
  console.log(777);
  process.nextTick(() => {  // callback8
    console.log(888);   
  })
}, 0);

process.nextTick(() => {    // callback9
  console.log(999);  
})

console.log('end');
// 结果：
//start
//end
//999
//111
//444
//777
//888
//555
//666
//333
//222
```

### 事件流/事件代理

比如说将子dom节点的点击事件绑定在父dom节点上，例如一个ul下面包含了若干个li，将点击事件绑定在ul上，点击li也会触发。

**触发的e.target指向的是对应点击的li，e.currentTarget指向的是当前绑定事件的dom节点也就是ul**

### setTimeout问题

+ 如果当前任务执行时间过久，会影响定时器任务的执行。这个不用细说
+ 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒。也就是说在定时器函数里面嵌套调用定时器，也会延长定时器的执行时间。嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。
+ 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒。被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。
+ 延时执行时间有最大值。Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行



### ES6新增

+ 变量声明：let、const
+ 函数：箭头函数，函数默认值，对象方法简写
+ 数组方法：新增了map、reduce、find、findIndex、includes、解构赋值
+ API：promise、async、await
+ 数据结构：map、set、symbol
+ 对象：新增了keys/values/entries/assign、解构赋值
+ 字符串：新增了includes、startsWith、endsWith、模板字符串



### 隐式类型转换

+ {} == {} （false）两个对象比较，比较的是内存地址
+ undefined == null (true)   undefined === null(false)
+ NaN == NaN   (false)   NaN和谁都不相等，包括自己
+ [12] == "12"  (true)   数组(对象)和字符串比较，是将它们toString()后进行比较
+ 剩余所有情况都是转换为数字在进行比较的
+ + 对象转数字，是将它先toString转换为字符串然后在转换为数字
  + 字符串转数字，只要出现一个非数字字符，就是NaN
  + 布尔转数字：true->1   false ->0
  + null 转数字 0
  + undefined转数字 NaN

```js
[] == false   //0 == 0 true
[] == 1 //0 == 1 false
"1" == [1] // 1 == 1 true
```

几种有趣的情况：

```js
{} + [] // 0  第一个{}会被当做代码块忽略，就计算+[]转换为数字就是0
[] + {} // "[object Object]"  都转换为字符串
{} - [] // -0 第一个{}会被当做代码块忽略，就计算-[]转换为数字就是0
[] - {} // NaN 
```



### Symbol

**Symbol会生成唯一的一个值，并不会导致重复，可以解决对象中重复属性覆盖的问题**

**要创建一个Symbol不用new，因为Symbol是一种基本数据类型，直接let x = Symbol()即可**



### Map/Set/WeakMap/WeakSet

+ Set:成员是唯一的**不能重复**，可以遍历，常用方法有：add/has/delete/clear
+ WeakSet: 在Set的基础上还保证了成员都是对象，成员只是弱引用，可以被垃圾回收机制回收，常用来保存Dom节点(当dom节点被删除时Set中也被删除)，不能被遍历
+ Map：键值对的集合，可以被遍历，key值可以是任意数据类型，常用方法有：set/has/delete/get/clear
+ WeakMap: 在Map的基础上还保证了键名是对象，键名是弱引用可以被垃圾回收，不能被遍历



### 原型与原型链

#### 一、prototype

prototype是函数才有的属性，比如Object、Array和构造函数等，它们都有着prototype，它们的prototype.constructor就是自己本身：

```js
function Person(){}
Person == Person.prototype.constructor  //true
```

构造函数通过new 出来的实例对象的\__proto__就是构造函数的prototype，实例化对象的constructor就是其构造函数

```js
function Person(){}
const per = new Person()
per.__proto__ = Person.prototype
```

任何一个函数的prototype的\__proto__都是Object.prototype:

```js
function a(){}
a.prototype.__proto__ == Object.prototype  //true
```

![](https://upload-images.jianshu.io/upload_images/1490251-3089c135df71c956.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

### 实现继承的几种方式

#### 原型链继承

```js
// 父类
function Parent(){}
// 子类
function Child(){
  
}
Child.prototype = new Parent()
Child.prototype.constructor = Child
```

这种方式将父类的实例作为子类的原型，子类原型上继承了父类中的所有属性和方法，缺点是无法传参，且一个实例修改了原型链上的属性则其他实例的属性也会被修改。

#### call继承（构造继承）

```js
// 父类
function Parent(){}
// 子类
function Child(){
  Parent.call(this)
}
```

这种方式把父类的私有属性和方法克隆一份给子类，子类不会继承到父类原型prototype上的属性和方法

#### 组合继承

```js
// 父类
function Parent(){}
// 子类
function Child(){
  	Parent.call(this)
}
Child.prototype = new Parent()
Child.prototype.constructor = Child
```

结合了上面两种方式的优点，但调用了两次父类构造函数，消耗内存

#### 优化组合继承

```js
// 父类
function Parent(){}
// 子类
function Child(){
  	Parent.call(this)
}
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child
```

解决了组合继承中调用两次构造函数的缺陷

#### ES6 Class继承

```js
class Parent{
  constructor(){}
}
class Child extends Parent{
  constructor(){}
}
```



### 对象的属性名只能是字符串吗？

**==错误！属性名还可以是Symbol类型！==**

**所有引用值作为对象的属性名，都会转换成字符串。所以，如果对象的属性名是一个另一个对象，则会默认将属性名转换为'[object Object]'，所以将多个对象作为属性名会导致被覆盖**



### forEach相关问题

forEach中使用return不能中断代码执行，也就是说return没有任何效果。如果想要中断forEach，可以使用trycatch在需要中断的地方抛出异常即可中断forEach。或者使用官方的推荐方法：用every或者some替代forEach



### new 关键字

**在执行new创造实例对象时，内部其实在构造函数中线创建了一个空对象{},然后将this指向这个空对象，并将这个空对象的\__proto__指向构造函数的prototype，最后将这个对象返回**

下面自行实现一个与new一样功能的\_new:

```js
// 需要实现的功能：const obj = _new(构造函数，构造函数的传参)，且obj跟照常new出来的对象拥有一样的功能
fuction _new(Func,...args){
  let obj = {}
  Func.call(obj,...args)
  obj.__proto__ = Func.prototype
  return obj
}
```

**new 一个构造函数，如果函数返回 `return {}` 、 `return null` ， `return 1` ， `return true` 会发生什么情况？**

**如果函数返回一个对象，那么new 这个函数调用返回这个函数的返回对象，否则返回 new 创建的新对象**



### 箭头函数和普通函数的区别

+ 箭头函数是一种匿名函数，不能使用new，会报错
+ 箭头函数不绑定arguments
+ 箭头函数不绑定自己的this，会捕获自己上下文的this.**箭头函数的this不会被bind、call、apply更改**
+ 箭头函数没有原型属性，a.prototype=undefined
+ 箭头函数不能作为生成器函数，不能使用yield关键字



### 暂存性死区/暂时死区

使用 let和const声明的变量，在声明之前的区域就是暂存性死区，在这个区域内使用这些变量会报错。例如：

```js
// 第一种情况：
let i = 1
{
  console.log(i) // 报错，因为后面使用let 声明了i
  let i = 2
}
// 第二种情况：
var i = 1
{
  console.log(i) // 报错，因为后面使用let 声明了i
  let i = 2
}
// 第三种情况：
var foo = 33
{
  let foo = foo + 55 // 报错，也是因为在let声明之前就使用了foo
}
// 第四种情况：
let i = 0;
{
  console.log(i) // 报错，但原因是重复声明了i，因为var存在变量提升，在let之前就已经有了var i = undefined，下面再let就会报错
  var i = 2
}
```



### 经典闭包问题

**闭包是什么？闭包就是有权访问另外一个函数作用域中的变量的函数**

**闭包的本质：当前环境中存在指向父级作用域的引用**

**闭包的作用：1.模拟块级作用域（let）。2. 保留外部函数的变量。3.封装私有变量。4. 同时也是webpack实现模块化的手段(使得每个模块中的全局变量不会被暴露出来)**

```js
var a = 0,b = 0;
function A(a){
  A = function(b){
    alert(a+ b++);
  };
  alert(a++)
}
A(1);// 1
A(2);// 4

// 改写闭包：
for(var i = 0; i < 6; i++){
  setTimeout(function(){
      console.log(i)
  },1000)
}
// 最终改写为：
for(var i = 0;i < 6;i ++){
  (function(j){
    setTimeout(() => {
      console.log(j)
    },1000)
  }(i))
}

```

**为什么呢？**

**首先，在外层函数A内并没有声明A，所以内层的A函数会跑到外面去替代掉外层的A，然后，由于js函数的作用域看的是定义时候的作用域，所以第二次的a是1++也就是2，最终结果就是2+2 = 4**

```js
// 再来一题：
var x = 0,y = 1;
funtion fn(){
  x += 2;
  fn = function(y){
    console.log(y+(--x));
  };
  console.log(x,y)
}
fn(3);
fn(4);
console.log(x,y)
```

**答案：（2,1）、5、（1,1）**

```js
// 再做一题
var x = 2;
var y = {
    x:3,
    z:(function(x){
        this.x *= x;
        x += 2;
        return function(n){
            this.x *= n;
            x += 3;
            console.log(x)
        }
    })(x)
};
var m = y.z;
m(4);
y.z(5)
console.log(x,y.x)
```

**答案：7、10、（16,15）**

```js
var test = 'global'
const b = (function (){
  var test = 'scope'
  return {
    test:'111',
    say(){
      console.log(test)
    }
  }
}())
b.say() // 结果是scope
```

### async 和 await详解
#### async
async用于修饰一个函数，如果该函数的返回值是一个Promise，则不做处理，依旧是返回这个promise

如果函数的返回值不是一个promise，则会对返回值使用promise进行一层包装:`return Promise.resolve(原返回值)`或者`return new Promise(resolve => resolve(原返回值))`

#### await
await只能在async函数中使用，用于等待一个async函数(或者一个返回Promise的函数)的返回值。如果等待的async函数原本返回的值不是一个Promise那么其结果就是源返回值

如果等待的async函数原来返回的就是一个Promise，则会阻塞住后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。

**但要注意的是由于await只能在async函数中使用，而async函数整体并不会阻塞住整个代码的执行，即async函数后面的代码会正常进行，不会被阻塞住。**



### async等执行顺序

**浏览器的执行顺序：先将脚本作为一个宏任务来执行，宏任务遇到await会执行await后面的函数并等待其返回结果将await下面的所有语句塞入微任务中，然后跳到下一步继续执行主线任务，遇到setTImeout会塞入宏任务。主线任务执行完毕后，会先执行微任务再接着执行宏任务**

==宏任务：事件绑定，定时器，ajax==

==微任务：async、await、promise、V8的垃圾回收过程==

```js
async function async1(){
  console.log("async1 start")
  await async2();
  console.log("async1 end")
}
async function async2(){
  console.log("async2")
}
console.log("script start")
setTimeout(() => {
  console.log("setTimeout")
},0)
async1()
new Promise(function (resolve){
  console.log("promise1")
  resolve()
}).then(function(){
  console.log("promise2")
})
console.log("script end");

最终的输出顺序为：
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout


// 注意这里的return 如果没有return 结果就不一样
async function async1() {
  console.log('async1 start');
  await async2()
  console.log('async end');
}
async function async2() {
  return new Promise((resolve, reject) => {
    console.log('async2 start');
    resolve()
  }).then(res => {
    console.log('async2 end');
  })
}
 
async1()
 
new Promise(resolve => {
  console.log('Promise');
  resolve()
}).then(res => {
  console.log('Promise end');
})
 
console.log('script end');
//async1 start
//async2 start
//Promise
//script end
//async2 end
//Promise end
//async end
```



### 跨域问题

**主要可以分为两大块，第一种就是绕过去，第二种从根源上解决（cors）**

#### 手写AJAX

介绍一下readyState状态码：0->刚创建还没发送;1->执行了open;2->已经发送，响应头已经被接收到;3->正在接受响应主体部分;4->响应主体已经被接收完毕;

**使用xhr.abort（）可以强制中断ajax请求**

**在xhr.open（）中的第三个参数设置为false就可以将ajax变成同步，为true表示ajax是异步**

```js
function myAjax({url,method,data,success,error}){
  let xhr = new XMLHttpRequest()
  let params = ''
  if(data){
    for(let i in data){
      params += i + '=' + data[i] + '&'
    }
    const reg = /['&']$/
    params = params.replace(reg,'')
  }
  if(method == 'get'){
    url += '?' + parmas
  }
  xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){
      if((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304){
        success && success(xhr.responeText)
      }else{
        error && error()
      }
    }
  }
  xhr.open(method,url,true)
  xhr.setRequestHeader('Content-type','x-www-form-urlencoded')
  xhr.send(params)
}
```



#### 第一阶段JSONP

jsonp的原理：由于script标签请求的资源不受跨域的影响，我们就创建一个script标签，将src设置为接口的地址，然后在后面加上一个callback=func；在js代码中定义这个func：function func(data){这样data就是我们从接口请求来的数据：}

```js
js代码生成一个script：<script src="www.baidu/api/user/info?callback=func"><script>并插入到html页面中
在js代码中：function func(data){这里的data就是请求来的数据}
```

==局限：接口的请求方式只能是get请求，且需要后端将数据拼接成："func({这里是数据})"==

#### 第二阶段iframe

使用window.name/document.domin/location.hash/postMessage....+IFrame..(15~16年)

#### cors跨域资源共享

只需要在后端设置cors即可，设置header：Access-Control-Allow-Origin。还有一些跨域的头：Access-Control-Allow-Credentials、Access-Control-Allow-Headers、Access-Control-Allow-Methods

cors跨域分为两种请求，简单请求和非简单请求（又称复杂请求）。

简单请求需要同时满足以下两大条件：1.请求方法是head/get/post之一。2.头信息不超出以下字段：Accept/Accept-Language/Content-Language/Content-Type(只限于application/x-www-form-urlencoded、multipart/form-data、text/plain)。简单请求会在请求头中加上一个Origin字段表示请求来自哪个源，服务器会在响应头添加Access-Control-Allow-Origin字段，如果Origin不在这个字段中就会被浏览器拦截。

非简单请求会发送两次请求，第一次预检请求，询问服务器网页是否在许可名单中以及可以使用哪些HTTP动词和头信息。得到肯定答复后发出正式的XMLHTTPRequest，过程和简单请求一样。

#### 基于http proxy实现跨域请求(开发阶段)+nginx反向代理(部署阶段)

只需要在webpack中进行配置即可，如果是vue项目，新建一个vue.config.js：

```js
module.exports = {
  devServer: {
    port: 9988, // 启动代理服务器的本地端口
    proxy: {
      '/api': { //请求路径关键字，这样后面就可以使用/api代替后面target写的一长串地址
        	target: 'http://api.vikingship.xyz/api', //对应自己需要跨域的接口
        	changeOrigin: true,//是否允许跨域,在本地会创建一个虚拟服务端，然后发送请求的数据，
        	// 并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题
        	ws: true,
        	pathRewrite: {
          	'^/api': ''      //这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替
          	// 比如我要调用'http://meituan:8024/management/user/add'，直接写‘/api/user/add’即可
        	}
      }
    }
  },
  // lintOnSave: false // 取消 eslint 验证
}
```

如果是react项目，类似配置"proxy":"需要跨域的接口，例如：http://meituan:5566/api"   后面发请求直接axios.get('后缀地址，例如：/user/userInfo')，这样就会向本地localhost:3000/user/userinfo发送请求，由于设置的proxy，就会将请求通过服务器代理自动代理到上面写的接口http://meituan:5566/api中，最终拼接出来的接口就是：http://meituan:5566/api/user/userInfo

==最后，部署到服务器上时，就需要使用到nginx 的反向代理==



### call、apply、bind

#### 三者的共同点

三个都是用于改变函数的this指向，并传参。在参数少的情况下call性能更好，但是对于多个参数情况下apply性能更好，可以以3个参数为分界线。

**注意：如果传入的this是null或者undefined，this的指向将会是window(浏览器)或者global(node端)**

#### call

call用于改变函数的this指向，第一个参数是改变后的this指向，后面所有的参数都是传参.**如果第一个参数是undefine或者null，则函数的this指向是window**

```js
Object.prototype.toString.call([])
cat.eat.call(dog,'apple','banana')
// 自己实现一个call
Function.prototype.myCall = function(thisArgs,...args){
  const fn = Symbol('fn')
  thisArgs[fn] = this
  const result = thisArgs[fn](...args)
  delete thisArgs[fn]
  return result
}
```

#### apply

apply也用于改变函数的this指向，第一个参数是改变后的this指向，后面只能再有一个参数，就是传参的数组。如果第一个参数是undefine或者null，则函数的this指向是window。**所以，call和apply的区别就是：call后面是this指向以及所有参数排列，apply后面是this指向以及所有参数的数组**

```js
cat.eat.apply(dog,['apple','banana'])
// 自己实现一个apply 
Function.prototype.myApply = function(thisArgs,oArgs){
  const fn = Symbol('fn')
  thisArgs[fn] = this
  const result = thisArgs[fn](...oArgs)
  delete thisArgs[fn]
  return result
}
```

#### bind

bind用于改变函数的this指向，后面跟着一系列参数排列。**与上面两个call、apply的区别是：bind并不会像call和apply一样直接执行函数，而bind会返回一个改变完this之后的新的函数**。所以在react中绑定函数使用的是bind，这样不会自动执行，而是等到对应条件触发时才会执行。

**多次bind是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。**

```js
const dogEat = cat.eat.bind(dog,'apple','banana')
dogEat()
// 自己实现一个bind
Function.prototype.myBind = function(thisArgs,...args){
  const _this = this
  return function(...sArgs){
    _this.apply(thisArgs,args.concat(sArgs))
  }
}
```



### Web Worker

woker是H5中创建多线程的API，会开启新的js线程

#### 使用方式

主线程中开启子线程：const worker = new Worker('新的js文件地址')

主线程中监听子线程传输的信息：worker.addEventListener('message',(e) => {   },false)

主线程向子线程传输信息：worker.postMessage(要传输的信息)

主线程关闭子线程：worker.terminate()

子线程监听主线程传入的信息：onmessage = (e) =>{}

子线程向主线程传输信息：postMessage(要传输的信息)

子线程自主关闭：self.close()

子线程中加载外部脚本：importScripts('文件')

#### 注意事项

1. 主线程和子线程之间不支持跨域。也就是说子线程的js文件必须与主线程js文件在同一个域名下。
2. 两个线程之间传输的数据是值的拷贝，相当于将值复制一份进行传输。传输时会先在一端进行JSON.stringify序列化，在另一端接收到后进行JSON.parse反序列化。
3. 子线程worker中无法使用dom、window、document、parent、alert()、confirm()，所以需要使用self来代替this。

### Service Worker

#### 简介

service worker（下面简称为sw）是基于web worker 的。而且**sw是基于https的**，因为Service Worker中涉及到请求拦截，所以必须使用HTTPS协议来保障安全。如果是本地调试的话，localhost是可以的。

sw可以认为是一个服务器与浏览器之间的中间人角色，如果网站中注册了service worker那么**它可以拦截当前网站所有的请求**，进行判断（需要编写相应的判断程序），**如果需要向服务器发起请求的就转给服务器，如果可以直接使用缓存的就直接返回缓存（Cache Storage）不再转给服务器**。从而大大提高浏览体验。

**创建有效的离线体验**（将一些不常更新的内容缓存在浏览器，提高访问体验）。由事件驱动的,具有生命周期。可以访问cache和indexDB。无法访问到dom等浏览器对象。

#### 生命周期

![图片](https://mmbiz.qpic.cn/mmbiz_png/meG6Vo0MevgmdgbcE7rrU5R5G24LaI9sRs28myIMQxzCv6QiaW5YfSoLeyExxNkmJu1gygNx9YLbbOLu5uafxQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 大量数据渲染

1. 使用requestAnimationFrame，每过1000/60ms执行一次，也就是每秒60帧的动画
2. 使用虚拟列表。只对可见区域进行渲染，对不可见区域不渲染或者部分渲染。滚动时计算滚动距离然后计算出需要渲染的数据。



### 生成器和迭代器

#### 生成器

生成器是一个带*号的函数，**但特别注意生成器不是函数，使用typeof查看会返回object**，它可以通过yield关键字来暂停执行和恢复执行

```js
function* gen() {
  console.log("enter");
  let a = yield 1;
  let b = yield (function () {return 2})();
  return 3;
}
var g = gen() // 阻塞住，不会执行任何语句
console.log(typeof g)  // object  看到了吗？不是"function"

console.log(g.next())  
console.log(g.next())  
console.log(g.next())  
console.log(g.next()) 

// enter
// { value: 1, done: false }

// { value: 2, done: false }
// { value: 3, done: true }
// { value: undefined, done: true }

```

由此可以看到，生成器的执行有这样几个关键点:

1. 调用 gen() 后，程序会阻塞住，不会执行任何语句。
2. 调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停。
3. next 方法返回一个对象， 有两个属性: `value` 和 `done`。value 为`当前 yield 后面的结果`，done 表示`是否执行完`，遇到了`return` 后，`done` 会由`false`变为`true`。

而生成器的底层就是协程，协程是一种比线程更加轻量级的存在，协程处在线程的环境中，`一个线程可以存在多个协程`，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将` JS 线程的控制权转交给 B协程`，那么现在 B 执行，A 就相当于处于暂停的状态。举个例子：

```js
function* A() {
  console.log("我是A");
  yield B(); // A停住，在这里转交线程执行权给B
  console.log("结束了");
}
function B() {
  console.log("我是B");
  return 100;// 返回，并且将线程执行权还给A
}
let gen = A();
gen.next();
gen.next();

// 我是A
// 我是B
// 结束了
```

在这个过程中，A 将执行权交给 B，也就是 `A 启动 B`，我们也称 A 是 B 的**父协程**。因此 B 当中最后`return 100`其实是将 100 传给了父协程。

需要强调的是，**对于协程来说，它并不受操作系统的控制，完全由用户自定义切换，因此并没有进程/线程`上下文切换`的开销，这是`高性能`的重要原因。**

而async和await`利用`协程`和`Promise`实现了同步方式编写异步代码的效果，其中`Generator`是对`协程`的一种实现。生成器本身也是下面即将说到的迭代器。



#### 迭代器

首先介绍一下可迭代数据类型，像数组就是一种可迭代数据类型。我们把那些原生具有[Symbol.iterator]属性数据类型为可迭代数据类型。如数组、类数组（如arguments、NodeList）、Set和Map。可迭代对象可以通过迭代器进行遍历。

```js
let arr = [4, 2, 1];
// 这就是迭代器
let iterator = arr[Symbol.iterator]();
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());


// {value: 4, done: false}
// {value: 2, done: false}
// {value: 1, done: false}
// {value: undefined, done: true}

```

其实，for...of循环就是迭代器的语法糖。

**而上面提到的生成器本身也是一种迭代器**



### 模块化标准

#### AMD、CMD

##### AMD

依赖的是**RequireJS**

1. 导出(定义模块)：define(模块的标识，当前模块依赖的模块名称数组，模块要导出的函数或对象)
2. 导入(加载模块)：require(所要依赖的模块数组，依赖模块加载成功后执行的函数(加载的模块会作为参数))

例如：

```js
// 导出：（在myModule.js文件中：）
define('test',['dependency'],function(){
	function say(){
    console.log('hello')
  }
  return{
    say:say
  }
})

// 导入(在main.js文件中：)
require(['test'],function(ss){
  ss.say()
})
```



##### CMD

依赖的是**SeaJS**

1. 导出：define(function(require,exports,module){})
2. 导入：seajs.use([依赖的模块名],function(参数){})

例如：

```js
// 定义模块  myModule.js
define(function(require, exports, module) {
  var $ = require('jquery.js')
  $('div').addClass('active');
});
 
// 加载模块
seajs.use(['myModule.js'], function(my){
 
});
```

##### 二者的区别

1. AMD推崇的是依赖前置，也就是说在定义模块的时候就需要声明其依赖的模块，即需要将导入语句写在文件的最开头的位置
2. CMD推崇就近依赖，只有在用到的时候再去require导入



#### CommonJs、ES6Module

##### CommonJS

**CommonJs是nodejs的模块化实现方式**

1. 导出：module.export = {}
2. 导入：require('文件')

##### ES6Module

1. 导出：export {} 或者export default
2. 导入：import {} from '文件'
3. 注意事项：需要在script标签处加上type="module"，

##### 二者的区别

1. CommonJS输出的是值的拷贝，也就是说原来模块中的值改变不会影响已经加载的值（复杂的数据类型如多层对象和数组除外），而ES6是静态分析动态引用，输出的是值的引用，值改变引用也改变，原来模块中的值改变则加载的值也改变
4. CommonJS this指向当前模块，ES6 this指向undefined。
5. CommonJS是运行时依赖，所以可以放在文件的任何位置引用，在执行阶段才会进行导入导出分析依赖；ES6Module是编译时依赖，需要放在最开头引入，在编译阶段就会进行导入导出分析依赖

### 手写一个数组的map方法

map接受两个参数，第一个参数是回调函数，第二个参数是回调函数内this 的指向。而回调函数又接受三个参数：curValue、index、arr，也就是当前遍历到的值、当前遍历到的下标和遍历的数组本身

```js
Array.prototype.myMap = function(callback,context){
	// 这里的this就是我们需要进行map的数组
  // 通过slice方法复制一份,这样操作就不会干扰到原数组
  let arr = Array.prototype.slice.call(this)
  let res = []// 这个就是最终返回的数组
  for(let i = 0;i < arr.length;i ++){
    res.push(callback.call(context,arr[i],i,this))
  }
  return res
}
```



### 手写一个reduce

reduce接受两个参数，第一个参数也是回调函数，第二个参数是初始值。回调函数也接受四个参数，上一次计算结束的返回值，当前遍历到的元素，当前元素的索引，当前遍历的数组本身

```js
Array.prototype.myReduce = function(callback,initVal){
  // 这里的this就是我们需要进行reduce的数组
  // 通过slice方法复制一份,这样操作就不会干扰到原数组
  let arr = Array.prototype.slice.call(this)
  let res,startIndex
  res = initVal ? initVal : arr[0]
  startIndex = initVal ? 0 : 1
  for(let i = startIndex,i < arr.length; i ++){
    res = fn.call(null,res,arr[i],i,this)
  }
  return res
}
```



### 手写一个Object.create

Object.create的原理就是将返回的对象的proto指向参数，所以需要借助一个中间构造函数F来完成

```js
function create(p){
  function F(){}
  F.prototype = p
  F.prorotype.constructor = F
  return new F()
}
```



### instanceof的原理

A instanceof B

判断左边的原型链上是否含有右边的prototype。具体的实现方式就是遍历左边的原型链直到找到右边的prototype否则返回false：

```javascript
function new_instance_of(leftValue, rightValue) { 
    let rightProto = rightValue.prototype; // 取右表达式的 prototype 值
    leftValue = leftValue.__proto__; // 取左表达式的__proto__值
  	while(leftValue){
      if(leftValue === rightProto){
        return true
      }
      leftValue = leftValue.__proto__
    }
  return false
}
```



### 手写一个Promise

promise由三种状态：Pending、Fulfilled、Rejected

promise在then方法之后仍会返回一个新的promise其中的参数就是上一个then中return 的值

**那么如何中断一个promise 的链式调用？**在then中返回一个状态永远是pending的promise即可，也就是then(() => {return new Promise((resolve,reject) => {})})

下面手写一个promise，使用到了一个queueMicrotask函数开启一个微任务，在node中可以使用process.nextTick开启微任务，浏览器中可以使用MutationObserver开启微任务。而queueMicrotask是跨环境的。

```javascript
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
  constructor(executor) {
    try {
      executor(this.resolve, this.reject)
    } catch (e) {
      this.reject(e)
    }
  }
  status = PENDING
  value = null
  reason = null

  onFulfilledCallbacks = []
  onRejectedCallbacks = []

  resolve = (value) => {
    if (this.status === PENDING) {
      this.status = FULFILLED
      this.value = value
      while (this.onFulfilledCallbacks.length) {
        this.onFulfilledCallbacks.shift()(value)
      }
    }
  }

  reject = (reason) => {
    if (this.status === PENDING) {
      this.status = REJECTED
      this.reason = reason
      while (this.onRejectedCallbacks.length) {
        this.onRejectedCallbacks.shift()(reason)
      }
    }
  }

  then(onFulfilled, onRejected) {
    const promise2 = new MyPromise((resolve, reject) => {
      const fulfilledMicrotask = () => {
        queueMicrotask(() => {
          try {
            let x = onFulfilled(this.value)
            resolvePromise(x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        })
      }
      const rejectedMicrotask = () => {
        queueMicrotask(() => {
          try{
            let x = onRejected(this.reason)
            resolvePromise(x,resolve,reject)
          }catch(e){
            reject(e)
          }
        })
      }
      if(this.status === PENDING){
        this.onFulfilledCallbacks.push(fulfilledMicrotask)
        this.onRejectedCallbacks.push(rejectedMicrotask)
      }else if(this.status === FULFILLED){
        fulfilledMicrotask()
      }else if(this.status === REJECTED){
        rejectedMicrotask()
      }
    })
    return promise2
  }
}

function resolvePromise(x, resolve, reject) {
  if (x instanceof MyPromise) {
    x.then(resolve, reject)
  } else {
    resolve(x)
  }
}
```



### 实现一个Promise.all

```js
function promiseAll(promiseArr){
  if(!Array.isArray(promiseArr)){
    throw new Error('必须是一个数组！')
  }
  return new Promise((resolve,reject) => {
    let res = []
    let count = 0
    
    function handleData(index,data){
      res[index] = data
      count ++
      if(count === promiseArr.length){
        resolve(res)
      }
    }
    
    for(let i = 0;i < promiseArr.length;i ++){
      promiseArr[i].then(data => {
        handleData(i,data)
      },reject)
    }
    
  })
}
```

### Promise.allSettled

与promise.all类似，接收一个promise数组。

promise.all会在遇到一个reject时立即中断执行并返回该reject，为了实现遇到reject不立即中断，而是继续执行完剩余所有promise，就有了promise.allSettled

promise.allSettled会将参数数组内所有的promise都执行，并返回一个promise实例，该实例只有then，参数为一个数组，数组内每一项是一个包含status和value或者reason的一组对象：

[*{"status":"rejected","reason":"promise1"}*,*{"status":"fulfilled","value":"promise2"}*]



### 使用Proxy

比如，需要对下面的对象进行监听

```js
const proxy = new Proxy(obj,{
  get(target,key){
    console.log('getter')
    // 进行数据劫持逻辑
    return target[key]
  },
  set(target,key,value){
    console.log('setter')
    // 进行数据劫持逻辑
    target[key] = value
  }
})
// 注意后面如果要实现响应式的数据劫持，操作的对象是proxy而不是原对象
```

使用`Object.defineProperty`无法监听到新增属性，但是使用`Proxy`是可以监听到的。对比上面两段代码可以发现有以下几点不同

- `Object.defineProperty`监听的是对象的每一个属性，而`Proxy`监听的是对象自身
- 使用`Object.defineProperty`需要遍历对象的每一个属性，对于性能会有一定的影响
- `Proxy`对新增的属性也能监听到，但`Object.defineProperty`无法监听到。

proxy可以使用的方法有：

+ get：获取对象属性时触发，三个参数(target目标对象/key属性名称/receiver相当于属性的this，一般认为是proxy对象本身)

+ set：设置对象属性时触发，四个参数(target目标对象/key属性名称/value目标属性要赋的新值/receiver相当于属性的this，一般认为是proxy对象本身))

+ has：当使用in判断属性是否存在时，触发。两个参数(target目标对象/key属性名)

+ deleteProperty：使用delete删除的时候触发

+ apply：监听的对象是一个函数时当调用该函数会触发

+ ownKeys：当通过`Object.getOwnPropertyNames`,`Object.getownPropertySymbols`,`Object.keys`,`Reflect.ownKeys`去获取对象的信息的时候，就会进入`ownKeys`这个钩子函数

+ construct：使用new时进入

+ defineProperty：使用Object.defineProperty触发

+ getPrototypeOf：读取对象原型的时候进入

+ setPrototypeOf：设置对象原型的时候进入

  



### localStorage和cookie、sessionStorage

localStorage存储大小（5M）远大于cookie（4K），并且localStorage不容易被清理掉，cookie一旦用户清除浏览历史就会被清除。但主要区别还是存储的大小。sessionStorage会在页面被关闭时自动被清除



### session和cookie

**区别：session是存储在服务器端的，cookie是存储在客户端（浏览器端）的。session是基于cookie 的**

**联系：服务器设置session后，会在发送给客户端的响应头中带着set-cookie='connect.sid'    客户端会自动把信息种植到本地的cookie中并且是httponly的（只能读不能修改）  之后客户端再次向服务器发送请求时，会默认在请求头的cookie中把connect.sid传递给服务器**

服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了6个属性值 expires、domain、path、secure、HttpOnly、same-site。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能在[客户端]()使用js 脚本访问。只有满足域名等于domain或者是domain的子域名且路径等于path或是path的子路径浏览器才会在发送请求时携带对应的cookie



###前端向后端传输数据的方式

1. 最常用的ajax
2. 通过请求图片的方式：const image  = new Image();  image.src = "地址?数据"    这样后端就能取到数据
3. 通过navigator.sendBeacon(url,数据)的方式，这种方式成功率最高但适配不好



### 单点登录

是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。有两种实现方式：第一种是同顶级域下的单点登录和非同顶级域下的单点登录

#### 同域下单点登录

例如，顶级域为a.com，第一个应用app1.a.com，第二个应用app2.a.com，负责登录的应用sso.a.com

在登录时发送请求到sso.a.com，登录完成后，sso.a.com设置cookie的domain属性为顶级域也就是a.com。这样后续的操作cookie也会被带上访问app1和app2。session可以使用共享session的解决方案例如Spring-Session

#### 非同域下单点登陆

具体流程如下：

1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录。
2. 跳转到SSO登录系统。 SSO系统也没有登录，弹出用户登录页。
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。
5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
6. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

1. 用户访问app2系统，app2系统没有登录，跳转到SSO。
2. 由于SSO已经登录了，不需要重新登录认证。
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
4. app2拿到ST，后台访问SSO，验证ST是否有效。
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。

这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。



### 安全问题 如XSS和CSRF

#### XSS

1. XSS是什么？xss全称Cross Site Scripting 跨站脚本攻击。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。
2. 攻击分类：①持久型（存储型）XSS，攻击者将恶意代码提交到目标网站的数据库中，用户请求后，服务器将恶意代码从数据库中取出，拼接在html中发给用户。常见于论坛发帖、商品评论   ②非持久型（反射型）XSS，诱骗用户点击URL带攻击代码的链接，服务器解析后响应，在响应内容中嵌入攻击者的XSS代码，常见于网站搜索跳转。③dom XSS，基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。
3. 防范：**所有用户输入都是不可信的。产生XSS的原因是用户对指定网站的信任**。① 使用输入过滤，对用户输入的内容进行有效性认证，忽略或者阻止以外的任何数据，对输入内容进行转义。②将cookie设置为httponly。使得javascript脚本无法获取到cookie   。③在浏览器中的渲染引擎有一个安全检查模块叫做XSSAuditor，用来检测词法安全，会对XSS进行拦截。④配置CSP，响应头中配置Content-Security-Policy，限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；禁止向第三方域提交数据，这样用户数据也不会外泄；

#### CSRF

1. CSRF是什么？CSRF全程Cross-sit Request forgery 跨站请求伪造，挟持用户在当前已登录的web上执行非本意的操作的攻击方法。**CSRF利用的是网站对用户浏览器的信任**
2. 攻击原理，在用户不知情的情况下利用用户已登录产生的cookie发送请求
3. 防范：①敏感请求不采用get形式（只能防范一些CSRF攻击）②用户操作限制，添加验证码机制（简单粗暴，但对用户不太友好）③验证http referer字段，这个字段记录了请求的来源地址，服务器验证来源地址是否合法（依赖浏览器）④采用token 。⑤设置cookie时添加sameSite属性，该属性有三个值：Strict/Lax/None，设置为Strict或者Lax后就基本杜绝了CSRF攻击



### Token

#### jwt

全称是json web token，是token的一种web规范。一个jwt由三个部分组成，部分之间用.隔开。三个部分分别是：header、payload、signature

header一般包含两个字段：type类型和algorithm算法，在进行base64编码后作为jwt的第一个部分：

```json
{
	"alg": "HS256",
  "typ": "JWT"
}
// base64编码后作为jwt的第一部分
base64.b64encode(json.dumps({"alg":"HS256","typ":"JWT"}))
'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9'
```

payload就是真实存储着需要传递的信息，比如用户ID、过期时间等，注意这里不能存敏感信息例如密码等，因为后续的编码是可以被破译的是不安全的

```json
{"user_id":"zhangsan"}
// 经过编码，这里的编码不一定是base64
 base64.urlsafe_b64encode('{"user_id":"zhangsan"}')
 'eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ=='
```

signature是对前面的header和payload以及一个密钥组合形成签名，来确保不会被篡改或者掉包，为了加密除了header和payload还多了一个密钥字段。也就是将上面的经过编码的header和经过编码的payload再加上密钥组合在一起再进行算法编码最后形成了signature。

```json
Signature = HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)

```

最后，将三个部分之间使用.连接在一起形成最后的jwt

服务器验证jwt就是通过自己读取payload和header进行同样的编码形成signature后与客户端传过来的第三部分signature进行比对。

为了减少 JWT Token 泄露风险，一般有效期会设置的比较短。可以同时生成 JWT Token 与 Refresh Token，其中 Refresh Roken 的有效时间长于 JWT Token，这样当 JWT Token 过期之后，使用  Refresh Token 获取新的 JWT Token 与 Refresh Token，其中  Refresh Token 只能使用一次。



### 浏览器垃圾回收机制

**js中的数据存在栈和堆中，对于栈中的变量会通过esp指针的方式很轻松的实现垃圾回收，下面主要针对堆中的垃圾回收**

首先，堆中会分为新生代和老生代两个区域，新生代中容量较小，老生代容量极大。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

+ 副垃圾回收器，主要负责新生代的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。新生代中用 Scavenge 算法来处理。就是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

+ 主垃圾回收器，主要负责老生代的垃圾回收。主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 整理（Mark-Compact）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。接下来就是垃圾的清除过程。让所有存活的对象向一端移动直接清理掉边界以外的内容。

V8引擎将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。



### 函数柯里化

```js
// 通用方法，length是参数长度
function currying(fn,length){
  let len = length || fn.length
  let arr = []
  return function temp(...args){
    arr.push(...args)
    if(arr.length >= len){
      let res = fn(...arr)
      arr = []
      return res
    }else{
      return temp
    }
  }
}
// 调用：
function add(a,b,c,d){
     return a+ b+c+d;
}
add = currying(add,4)
console.log(add(1)(2)(3)(4))
console.log(add(1,2)(3)(4))

// 直接写一个add类型的curring函数：
function add(){
  var _args = Array.prototype.slice.call(arguments)
  function _add(){
    _args.push(...arguments)
    return _add
  }
  _add.toString = () => {
    return _args.reduce((a,b) => {
      return a + b
    })
  }
  return _add
}
// 调用：
add(1,2)(3)(4)
```



### 移动端适配（消除点击300ms的延迟）

1. 禁用缩放 `<meta name = "viewport" content="user-scalable=no" >` 
   缺点: 网页无法缩放
2. 更改默认视口宽度 `<meta name="viewport" content="width=device-width">` 
   缺点: 需要浏览器的支持
3. 设置css的touch-action:none， touch-action默认为 auto，将其置为 none 即可移除目标元素的 300 毫秒延迟 缺点: 新属性，可能存在浏览器兼容问题
4. tap事件 zepto的tap事件, 利用touchstart和touchend来模拟click事件
   缺点: 点击穿透
5. fastclick 原理: 在检测到touchend事件的时候，会通过DOM自定义事件立即触发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉
   缺点: 脚本相对较大



## 框架部分

### Vue 高薪面试技巧

见pdf文见和链接http://t.kuick.cn/ZOAi



### 自己搭建一个vue-cli脚手架

#### 使用到的第三方包解析

+ commander：用来编写指令，处理命令行
+ inquirer：交互式命令行工具
+ chalk：修改控制台输出样式，比如颜色等
+ ora：好看的加载，下载的时候出现转圈
+ download-git-repo：下载远程模板

#### 具体步骤

1. 首先，创建文件夹，命名为lqh-demo-cli

2. 进入文件夹，输入命令npm init，生成package.json文件

3. 安装上述第三方包

4. 在主目录下新建template.json，内写入一个{}即可，这个文件用于保存项目模板及其github地址

5. 在主目录下新建文件夹bin，在bin中创建文件：“lqh.js”、“lqh-add.js”、“lqh-delete.js”、“lqh-list.js”、“lqh-init.js”

6. package.json文件中添加：

   ```json
   "bin":{
   	"lqh": "bin/lqh.js",
     "lqh-add": "bin/lqh-add.js",
     "lqh-delete": "bin/lqh-delete.js",
     "lqh-list": "bin/lqh-list.js",
     "lqh-init": "bin/lqh-init.js"
   }
   ```

   作用是配置命令。然后输入命令npm link，将添加的命令配置到全局，往后在所有文件夹中都可以通过lqh /lqh add/lqh init....来使用脚手架

7. lqh.js文件：

   ```js
   #!/usr/bin/env node
   const program = require('commander')
   
   // 定义当前版本
   // 定义使用方法
   // 定义四个指令
   program
     .version(require('../package').version)
     .usage('<command> [options]')
     .command('add', 'add a new template')
     .command('delete', 'delete a template')
     .command('list', 'list all the templates')
     .command('init', 'generate a new project from a template')
     
   // 解析命令行参数
   program.parse(process.argv)
   
   ```

8. lqh-add.js文件：

   ```js
   #!/usr/bin/env node
   
   // 交互式命令行
   const inquirer = require('inquirer')
   // 修改控制台字符串的样式
   const chalk = require('chalk')
   // node 内置文件模块
   const fs = require('fs')
   // 读取根目录下的 template.json
   const tplObj = require(`${__dirname}/../template`)
   
   // 自定义交互式命令行的问题及简单的校验
   let question = [
     {
       name: "name",
       type: 'input',
       message: "请输入模板名称",
       validate (val) {
         if (val === '') {
           return 'Name is required!'
         } else if (tplObj[val]) {
           return 'Template has already existed!'
         } else {
           return true
         }
       }
     },
     {
       name: "url",
       type: 'input',
       message: "请输入模板地址",
       validate (val) {
         if (val === '') return 'The url is required!'
         return true
       }
     }
   ]
   
   inquirer
     .prompt(question).then(answers => {
       // answers 就是用户输入的内容，是个对象
       let { name, url } = answers;
       // 过滤 unicode 字符
       tplObj[name] = url.replace(/[\u0000-\u0019]/g, '')
       // 把模板信息写入 template.json 文件中
       fs.writeFile(`${__dirname}/../template.json`, JSON.stringify(tplObj), 'utf-8', err => {
         if (err) console.log(err)
         console.log('\n')
         console.log(chalk.green('Added successfully!\n'))
         console.log(chalk.grey('The latest template list is: \n'))
         console.log(tplObj)
         console.log('\n')
       })
     })
   
   ```

9. lqh-delete.js文件：

   ```js
   #!/usr/bin/env node
   
   const inquirer = require('inquirer')
   const chalk = require('chalk')
   const fs = require('fs')
   const tplObj = require(`${__dirname}/../template`)
   
   let question = [
     {
       name: "name",
       message: "请输入要删除的模板名称",
       validate (val) {
         if (val === '') {
           return 'Name is required!'
         } else if (!tplObj[val]) {
           return 'Template does not exist!'
         } else  {
           return true
         }
       }
     }
   ]
   
   inquirer
     .prompt(question).then(answers => {
       let { name } = answers;
       delete tplObj[name]
       // 更新 template.json 文件
       fs.writeFile(`${__dirname}/../template.json`, JSON.stringify(tplObj), 'utf-8', err => {
         if (err) console.log(err)
         console.log('\n')
         console.log(chalk.green('Deleted successfully!\n'))
         console.log(chalk.grey('The latest template list is: \n'))
         console.log(tplObj)
         console.log('\n')
       })
     })
   
   ```

10. lqh-list.js文件：

    ```js
    #!/usr/bin/env node
    
    const tplObj = require(`${__dirname}/../template`)
    console.log(tplObj)
    ```

11. lqh-init文件：

    ```js
    #!/usr/bin/env node
    
    const program = require('commander')
    const chalk = require('chalk')
    const ora = require('ora')
    const download = require('download-git-repo')
    const tplObj = require(`${__dirname}/../template`)
    
    program
      .usage('<template-name> [project-name]')
    program.parse(process.argv)
    // 当没有输入参数的时候给个提示
    if (program.args.length < 1) return program.help()
    
    // 好比 vue init webpack project-name 的命令一样，第一个参数是 webpack，第二个参数是 project-name
    let templateName = program.args[0]
    let projectName = program.args[1]
    // 小小校验一下参数
    if (!tplObj[templateName]) {
      console.log(chalk.red('\n Template does not exit! \n '))
      return
    }
    if (!projectName) {
      console.log(chalk.red('\n Project should not be empty! \n '))
      return
    }
    
    url = tplObj[templateName]
    
    console.log(chalk.white('\n Start generating... \n'))
    // 出现加载图标
    const spinner = ora("Downloading...");
    spinner.start();
    // 执行下载方法并传入参数
    download (
      url,
      projectName,
      err => {
        if (err) {
          spinner.fail();
          console.log(chalk.red(`Generation failed. ${err}`))
          return
        }
        // 结束加载图标
        spinner.succeed();
        console.log(chalk.green('\n Generation completed!'))
        console.log('\n To get started')
        console.log(`\n    cd ${projectName} \n`)
      }
    )
    
    ```

    

### diff算法

#### 传统diff算法

创建一个完整的节点对象的成本的是非常大的，因为DOM对象非常复杂，包含很多属性和内容，这也是采用虚拟dom的原因

传统的diff算法会将每个新旧节点的两两比较，复杂度为O(n\^2)，比较之后还需要计算最小转化方式，所以综合复杂度就是O(n\^3)



#### 框架层diff算法

框架层的diff有个大前提就是WEB中的DOM节点跨层级的操作少，可以忽略不计，所以其核心在于，框架层的diff算法只对同层级节点进行比较 ，忽略跨层级的复用，所以只需要遍历一次新节点，复杂度为O(n)。

数据更新时，对比新数据构建的vnode和老数据构建的oldVnode的差异，如果为可复用节点(sameNode)就通过patchVnode的方式进行打补丁更新，如果不是可复用节点，则创建新节点进行替换旧的节点的子节点也不考虑复用。

1. 判断是否可复用：大概是通过tag、key、inputType进行，完全相同则说明可以复用

2. patchVnode的逻辑如下：先找到对应的dom节点elm并赋值给vnode.elm；判断节点类型，是文本节点就跟新elm文本即可；非文本节点则看子节点，如果新老节点都右子节点，则走子节点的同层比较流程updateChildren；如果只有新节点有子节点，直接使用addVnodes为elm添加子节点(需要先删除文本)；如果只有旧节点有子节点，使用removeVnodes删除即可；如果都没有子节点，判断旧数据是否有文本节点，有则清空

3. updateChildren逻辑如下：![image-20210610164101430](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210610164101430.png)

   暂且将StartIdx、endIdx称为左指针、右指针，startVnode、endVnode称为左节点和右节点

   首先会将新旧节点的startVnode进行对比，能复用则深度遍历并将两个指针都向右移动；如果不能复用，则进行新旧节点的endVnode对比；还是不行，则进行旧节点的startVnode和新节点的endVnode进行对比，然后是旧节点的endVnode和新节点的startVnode对比。最后如果还是无法匹配，则会创建一个旧节点的key-》index的一个映射，根据新节点中的key去进行匹配。
   
   最后当有一方的首尾指针发生碰撞后，就认为其已经遍历完毕。如果旧节点被匹配完毕但新节点还没有，则创建新节点中的未被匹配元素；如果新节点匹配完毕但是旧节点还没有，则删除旧节点中的未匹配内容。



### 虚拟dom vdom

#### 虚拟dom的作用

js无法直接操作真实的dom，需要借助dom模块，这会带来很高的性能代价，且频繁的操作dom会导致页面重绘或者回流。虚拟dom便于我们掌握dom结构，优化dom操作内容，原来直接操作dom的多次操作可以经过虚拟dom优化成一次操作，起到了优化性能的作用。

将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。

变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。

在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。

#### vdom更新界面的过程

初次渲染时，首先将数据渲染为vdom，然后由该vdom生成dom。

数据更新时，渲染得到新的vdom，与上一次的vdom进行diff算法比较，得到需要进行更新的dom，然后在patch的过程中应用到dom上实现界面的同步更新

#### 一个简单的vdom：

```javascript
// 真实的dom节点：
<ul id="list">
	<li class="item">item1</li>
  <li class="item">item2</li>
  <li class="item">item3</li>
</ul>

// 转换为vnode后：
const vnode = {
	tag:'ul',
	attrs:{id:'list'},
	children:[
		{
			tag:'li',
			attrs:{class:'item'},
			children:['item1']
		},
		{
			tag:'li',
			attrs:{class:'item'},
			children:['item2']
		},
		{
			tag:'li',
			attrs:{class:'item'},
			children:['item3']
		}
	]
}
```

#### 更新界面的过程简单代码实现：

```javascript
// 第一次patch，也就是首次渲染时：
function createElement(vnode) {
    var tag = vnode.tag  // 'ul'
    var attrs = vnode.attrs || {}
    var children = vnode.children || []
    if (!tag) {
        return null
    }

    // 创建真实的 DOM 元素
    var elem = document.createElement(tag)
    // 属性
    var attrName
    for (attrName in attrs) {
        if (attrs.hasOwnProperty(attrName)) {
            // 给 elem 添加属性
            elem.setAttribute(attrName, attrs[attrName])
        }
    }
    // 子元素
    children.forEach(function (childVnode) {
        // 给 elem 添加子元素
        elem.appendChild(createElement(childVnode))  // 递归
    })

    // 返回真实的 DOM 元素
    return elem
}
// 第二次patch，也就是根据diff算法更新dom：
function updateChildren(vnode,newNode){
  var children = vnode.children || []
  var newChildren = newNode.children || []
  children.forEach((childNode,index) => {
    var newChildNode = newChildren[index]
    if(childNode.tag === newChildNode.tag){
      updateChildren(childNode,newChildNode)
    }else{
      replaceNode(childNode,newChildNode)
    }
  })
}
function replaceNode(node,newNode){
  var elem = vnode.elem
  var newElem = createElement(newNode)
  //然后进行替换
}
```

### vue 模板解析流程

#### 对于runtime+compiler的构建方式

1. 先将template解析(parse)成ast(abstract syntax tree)抽象语法树

2. 将抽象语法树编译(compile)成render字符串函数，这里的render还是字符串形式的函数

   下面看一下具体的html对应的render：

```js
// html部分：
<div id="app">
    <div>
      <input v-model="title" type="text">
      <button v-on:click="add">submit</button>
    </div>
    <div>
      <ul>
        <li v-for="item in list">{{item}}</li>
      </ul>
    </div>
 </div>
// 对应的render函数：
// 其中_c就是创建标签  _v创建文本节点  _s创建{{}}数据  _l对应v-for
with (this) 
{ return _c(
  'div', 
  { 
    attrs: { "id": "app" } 
  }, 
  [
    _c(
      'div', 
      [
        _c(
          'input', 
          { 
            directives: [
              { 
                name: "model", 
                rawName: "v-model", 
                value: (title),
                expression: "title" 
              }
            ], 
            attrs: { 
              "type": "text" 
            }, 
            domProps: { 
              "value": (title) 
            },
            on: { 
              "input": function ($event) { 
                if ($event.target.composing) return; 
                title = $event.target.value 
              } 
            } 
          }),
        _v(" "), 
        _c(
          'button', 
          { 
            on: { 
              "click": add 
            } 
          }, 
          [_v("submit")])
      ]), 
      _v(" "), 
      _c('div', 
        [
          _c(
            'ul',
            _l((list), 
              function (item) { 
                return _c('li', [_v(_s(item))]) 
              }), 
              0)]
          )]
          ) 
        }
```

3. render转换成真正的函数(new function)并执行会返回一个VNode对象，也就是虚拟dom

4. 将虚拟dom执行一系列操作如diff算法等，渲染成真实的UI界面

```js
vm._update(vnode){
	const prevVnode = vm._vnode
  vm._vnode = vnode
  if(!prevVnode){
    vm.$el = vm._patch_(vm.$el,vnode)
  }else{
    vm.$el = vm._patch_(prevVnode,vnode)
  }
}
// 页面每一次渲染或者data每一次修改内容都会触发下面的函数
function updateComponent(){
  //  下面的render就是第二步的render函数，返回一个Vnode
  vm._update(vm._render())
}
```



#### 对于runtime-only的构建方式

**runtime-only省去了template -> ast ->render 函数的过程，直接将执行render函数返回一个Vnode**

1. 执行render函数

   ```js
   new Vue({
   	router,
   	vuex,
   	render:h => h(App)  //这里的h就是创建VNode的函数，返回VNode，叫h可能是对应snabbdom
   }).$mount('#app')
   ```

2. 将render函数返回的VNode对象执行操作渲染出真实的UI界面



### vue整个的实现流程

解析模板成render函数  -->   开启响应式监听   -->   初次渲染，显示页面并绑定依赖   -->  data属性变化，再次执行渲染   

#### 一、解析模板成render函数

就是上面vue 模板解析的过程，将模板解析成为render函数，模板中的逻辑都变成了js代码，render函数执行会返回vnode

#### 二、开启响应式监听

根据render函数监听数据的变化（Object.defineProperty）并将data 的属性代理到vm上。

#### 三、进行初次渲染，显示页面并绑定依赖

```js
// 页面每一次渲染或者data每一次修改内容都会触发下面的函数
function updateComponent(){
  //  下面的render就是第二步的render函数，返回一个Vnode
  vm._update(vm._render())
}

vm._update(vnode){
	const prevVnode = vm._vnode
  vm._vnode = vnode
  if(!prevVnode){
    // 初次渲染
    vm.$el = vm._patch_(vm.$el,vnode)
  }else{
    // 再次渲染
    vm.$el = vm._patch_(prevVnode,vnode)
  }
}
```

执行render函数会访问到内部的数据，就会被响应式的get方法监听到

#### 四、data属性变化引发再次渲染

修改属性会被set方法监听到，然后就会再次执行updateComponent()函数



### Vue生命周期

<img src="https://img-blog.csdnimg.cn/20200921202303225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tvbmdLb25nX1JhYw==,size_16,color_FFFFFF,t_70#pic_center" alt="Vue生命周期" style="zoom:40%;" />

+ beforeCreate :   实例初始化之后，数据观测、event、watcher事件配置之前
+ created ：  实例创建完成之后被调用。这一步已经完成了数据观测，属性计算和事件绑定
+ beforeMount ： 挂载之前调用，相关的render函数首次被调用
+ mounted ： el替换
+ beforeUpdate ： 数据更新时调用，发生在虚拟dom重新渲染和打补丁之前，可以进一步的修改状态，不会触发重复的渲染过程
+ updated ： 数据和虚拟Dom已经重新渲染完成
+ activated ：keep-alive组件激活时调用
+ deactivated ：keep-alive组件停用时调用
+ beforeDestroy ： 实例销毁前调用，这里实例仍然可用
+ destroyed：实例完全销毁后，所有事件等都被移除绑定

1. 创建实例，new Vue() 的过程中，首先执行 init()

2. init() 过程首先是执行 beforeCreate ，初始化data、 props、 watch、computed,这些执行都是在 beforeCreate 阶段和 create 阶段，也是创建响应式数据的阶段，这个阶段不要去修改数据
3. create 阶段结束，会去判断实例中有无 el option 选项，如果没有会执行 \$mount(), 如果有，直接执行下一步
4. 判断 template, 若有，会把 template 打成一个个 render function ,其中的传参h就是vue.createElement， 参数为 标签，对象(可以是props或事件)，内容
5. render函数发生在 beforemounted 和 mounted 之间，所以当 beforeMount 时，$el 还只是HTML上的节点，mounted 时才把渲染的内容挂载到 DOM 上，实际就是执行了 renderfunction
6. beforeMount 有了 renderfunction 才执行，执行完执行 mount , mounted 执行完，整个生命周期中主动执行的函数就已经完毕，剩下的比如 beforeUpdata、updata、beforDestory、destory 需要外部触发

### Vue中的v-for循环中key的作用

 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。

为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。

key 的特殊属性主要用在Vue的虚拟DOM的diff算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。

由于Diff算法，如果需要在多个节点中插入一个节点，diff算法会默认将原来的节点一一更新，而不是直接插入。当有了key这个唯一标识的时候，diff算法就可以正确识别节点并在正确的位置插入。

**所以，v-for中的key是为了更新Dom时更高效**

不建议使用index作为key的原因是：当以数组的下标index作为key值时，其中一个元素发生了变化 就有可能导致所有元素的key值发生改变 。diff算法是比较同级之间的不同并以key值来进行关联。当对数组进行下标的变换时，比如删除第一条数据，那么以后所有的Index都会发生改变，那么key值自然也跟着全部发生改变，所以，index作为key值和没加index是一样的，并不能提升性能。 



### Vue中computed和watch的区别

#### computed：

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算

2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化

3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值

4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed

5. 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

#### watch：

1. 不支持缓存，数据变，直接会触发相应的操作；

2. watch支持异步；

3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

4. 当一个属性发生变化时，需要执行对应的操作；一对多；

5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：



### Vue组件化步骤

+ 创建组件构造器Vue.extend() ->  
+ 注册组件Vue.component() ->
+ 使用组件



### 好的组件设计原则

+ 容错处理，错误参数传入的处理；
+ 缺省值（默认值）的设定
+ 一切皆可配置，暴露出接口让使用者配置
+ 高内聚，低耦合（职责单一易于组合、剥离业务逻辑）
+ 易集成易扩展



### Vue单向数据流

vue所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。

额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你**不**应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。



### Vue-loader是什么

vue文件的一个加载器，跟template/js/style转换成js模块。

1. 先将.vue文件拆分成三个部分：

   ```js
   import Script from './app.vue?vue&type=script&lang=js'
   import {render,staticRenderFns} from './app.vue?vue&type=template'
   import style0 from './app.vue?vue&type=style&lang=css'
   ```

2. 然后调用pitcher对上面的三部分进行处理，根据用户对应的use设置，分别拼接出要使用到的loader的路径：

   ```js
   import mod from "-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&";
   ```

3. 最后根据上面的路径依次调用对应的loader进行处理



### $nextTick作用？

vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。

nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM

还可以使用await this.$nextTick()  之后写代码，来保证代码将在数据更新后执行



### Vue中双向数据绑定的原理

vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：

> 1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化

> 2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

> 3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

> 4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。



### vue如何监听数组或者对象的变化

两种方式：

+ this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)
+ 调用以下几个数组的方法：push/pop/shift/unshift/reverse/sort/splice。Vue中对这些方法进行了hack，会在调用原生的该方法后使用notify通知更新



### v-if和v-show

1. v-if是通过控制dom节点是否存在来控制显示与隐藏的；而v-show是通过控制css中的display：none或者block来控制显示与隐藏的
2. v-if切换会有一个编译的过程，v-show只是简单的css切换
3. v-if切换会有更高的切换消耗，频繁切换的场景使用v-show
4. v-if的优先级比v-show的优先级更高



### v-for和v-if优先级

+ 首先，v-for会在v-if之前被解析。
+ 在vue官方文档中不建议我们将v-if和v-for放在一起使用。因为即使是放在一起使用，也会遍历整个对象或者数组，并不会起到优化代码的作用。从源码中render函数返回的值也可以看到，v-for的逻辑会放在外层，v-if在内层，也就是说数组中的每个内容都会被遍历到
+ 通常会有这样一种场景导致我们这样做：比如过滤一个后台返回的用户列表，将用户的isActive为true的用户渲染，为false 的不进行渲染。其实可以使用一个computed属性先将后台传递过来的数组进行过滤后再使用v-for渲染。

### Vue-Router中的导航钩子

#### 全局导航钩子

+ 前置钩子。beforeEach(to,from,next)。通常用于跳转前的权限验证
+ 后置钩子。afterEach(to,from)

#### 独享钩子

+ 在路由配置的时候写在routes内，beforeEnter(to，from，next)，与全局前置钩子类似

#### 组件里的导航钩子

+ beforeRouteEnter(to,from,next)：此时还不能获取到组件实例this
+ beforeRouteUpdate(to,from,next)
+ beforeRouteLeave(to,from,next)



### Vuex

#### Vuex的作用（简单介绍一下Vuex）

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。设计思想上，Vuex 全局维护着一个对象，使用到了单例设计模式。在这个全局对象中，所有属性都是响应式的，任意属性进行了改变，都会造成使用到该属性的组件进行更新。并且只能通过 `commit` 的方式改变状态，实现了单向数据流模式。

<img src="https://img1.sycdn.imooc.com/5d58131e0001f33010861004.png" alt="图片描述" style="zoom:45%;" />

Vuex由四大部分组成，state是存储的单一状态，是存储的基本数据。getters相当于是store的计算属性，mutations用于同步更改数据，通过commit（mutation内的方法）来实现数据更改。actions用于异步更改数据，内部使用commit提交mutation来实现。



#### 为什么不能在action里直接更改state

首先，从单一职责原则 上来说，mutation设计就是用来处理同步逻辑，action就是用来处理异步逻辑。而且，在Vue devtools中，只能追踪到commit操作，为了能追踪到异步操作，就需要在action中使用commit调用mutation中的内容。





### vue3和vue2的区别

#### 底层源码上

+ 重构了响应式系统，使用Proxy替换了Object.defineProperty，对数组和对象的监听更加友好。
+ 重构了VDOM。模板编译时将一些静态的节点编译成常量
+ TS替换了Flow，对TS原生支持
+ 支持Tree Shaking 按需引入，使得体积更小
+ Custom Render API。让使用者可以自定义渲染平台



#### 写法上

+ Composition式API，在写法上更加友好，有利于后续的逻辑复用和代码结构组织
+ 新增了一些响应式数据创建方式：ref、reactive、toRefs
+ 新增了一些新特性组件，如Teleport、Suspense






### React的流程

#### 一、JSX语法解析

JXS语法会隐式的调用React.createEleme()函数，该函数会返回一个vNode对象，类似于vue中的render函数。当遇到自定义组件时，会调用自定义组件的render方法，再次触发React.createElement函数

#### 二、setState流程

React中数据的修改与vue中都是异步的，在setState完成之后，react会隐式的调用renderComponent()函数，函数内部会再一次执行render触发React.createElement函数返回一个新的Vnode，然后执行patch渲染。



### 父子组件通信

#### Vue中父子组件通信

**vue中，父传子通过props进行传递，子传父通过emit，如果有多级传递，在Vue2中用\$on/$emit，在Vue3中需要引入第三方的mitt通过mitt的on和emit进行。同时，父组件还可以通过v-slot获取到子组件的数据：在子组件中\<slot name="test" :data="count">在父组件中：\<template v-slot:test="sonData" >这样就可以通过sonData.data获取到子组件的count**

**还可以通过本地存储的方式：vuex（刷新会重置）、localStorage**

####react中父子组件通信

**react中父传子也是通过props传递，子传父通过父组件将方法通过props传递给子组件，子组件调用该方法实现。多层通信可以通过手写发布订阅或者React.createContext**



### 前端路由的原理

主要使用的原理是URL与UI的映射关系，即改变URL并不引起页面的刷新

1. history：history.pushState()、history.replaceState()  这两种方式都会引起URL的变化但页面不会刷新。通过监听popState事件可以感知到URL的变化从而改变组件的展示，但单纯使用pushState和replaceState时不会触发popState回调，需要进行hack
2. hash：hash就是URL的#后面部分，使用window.location.hash处理哈希的改变时不会重新渲染页面，监听hashchange事件即可。hash的优势是兼容性更高，但不太美观



## webpack部分

### webpack配置组成

+ entry：入口文件
+ output：输出位置
+ mode：环境（production or development；主要是设置了process.env.NODE_ENV的值）
+ module：里面的rules配置Loaders
+ plugins：插件配置
+ devtool: source-map配置
+ devServer: 本地开发模式热更新
+ optimization：分包等等

### .babelrc文件配置组成

本质上是一个json文件，也就是一个{}包裹的内容。内部分为两个部分，一个是presets，另一个是plugins，这两部分都是数组。其中presets是多种plugins的官方集合体，也就是说presets内容内置了多种官方的plugins：

如下所示，@babel/preset-env内置了多个plugins用于es6语法的转换

```json
{
  "presets": [
    ["@babel/preset-env"],
    "@babel/preset-react"
  ],
  "plugins":[
    "@babel/plugin-syntax-dynamic-import"
  ]
}
```



### 单入口配置

首先在项目中输入npm init 初始化，之后会出现一个package.json文件表示初始化完成

然后进入项目中输入npm install webpack@4.31.0  webapck-cli@3.3 --save-dev 在项目的开发依赖中安装webpack和webpack-cli。

接下来在根目录下创建webpack 的配置文件：webpack.config.js:

```js
'use strict';

const path = require('path')

modeule.exports = {
  entry:'./src/index.js',
  output:{
    path: path.join(__dirname,'dist'),
    filename:'bundle.js'
  },
  mode:'production'
}
```

接下来我们编写好对应的index.js后，在命令行中输入 ./node_modules/.bin/webpack  即可开启打包。

还可以修改package.json文件的script，添加："build":"webpack"  这样后面就可以通过npm run build 开启打包

### 多入口配置

与上面的单入口配置基本一致，对webpack.config.js进行修改，entry变成对象，指定每个入口的名称，输出位置的filename使用[name]进行占位，生成的文件名就是entry中的名称：

```js
'use strict'

const path = require('path')

modeule.exports = {
  entry:{
    index:'./src/index.js',
    search:'./src/search.js'
  },
  output:{
    path:path.join(__dirname,'dist'),
    filename:'[name].js'
  },
  mode:'production'
}
```



### 解析ES6

需要安装@babel/core、@babel/preset-env、babel-loader: 

npm i @babel/core @babel/preset-env babel-loader -D

新建.babelrc文件：

```json
{
  "presets": [
    "@babel/preset-env"
  ]
}
```

在webpack.config.js文件中新增loader：

```js
module:{
  rules:[
    {
      test:/\.js$/,
      use:['babel-loader'],
      exclude:/node_modules/
    }
  ]
}
```

### 解析css

需要安装style-loader、css-loader；其中css-loader用于加载css文件并转换成commonJS对象插入到js代码中去，style-loader将样式通过style标签插入\<head>中

在webpack.config.js文件中新增loader：

```js
module:{
  rules:[
    {
      test:/\.css$/,
      use:['style-loader','css-loader']
    }
  ]
}
```

### 解析图片| 字体

需要安装url-loader和file-loader，其中url-loader用于将小的图片文件直接base64编码，大的图片交给file-loader处理。file-loader处理字体图片等文件，在代码中通过相对URL去引用输出的文件：如果单独用file-loader则不会对小图片进行base64。使用url-loader会自动将超过limit大小的使用file-loader。所以，一般推荐直接使用url-loader即可

```js
module:{
  rules:[
    {
      test:/\.(jpg | png | gif | svg)$/,
      use:[ 
      	{
      		loader:'url-loader',
          options:{
            limit:20480 // 小于的使用base64，大于使用file-loader
          }
    		}
      ]
    }
  ]
}
```

### 文件监听

每次更改后都要手动的构建太过于麻烦，需要开启webpack自动构建文件。

**以下方式还存在缺陷，就是需要手动刷新浏览器**

有多种方式，比如在开启webpack构建的时候加上参数--watch或者在配置文件中加上watch：true。这里采用的方式是在package.json 的scripts中加上："watch": "webpack --watch"。

方式一：在package.json中的scripts添加命令

```json
"scripts":{
  "watch":"webpack --watch"
}
```

方式二：在webpack.config.js中添加watch：

```js
module.exports = {
  entry:'xxx',
  output:{},
  // 默认为false，也就是不开启监听
  watch:true,
  // 只有开启监听后才有意义
  watchOptions:{
    // 默认为空，用于设置不进行监听的文件或者文件夹，支持正则
    ignored:/node_modules/,
    // 监听到变化后会等待的时间，默认就是300ms
    aggregateTimeout:300,
    //判断文件是否变化的轮询次数，每秒进行多少次，默认是1000，每秒轮询1000次
    poll:1000
  }
}
```

原理分析：开启监听后，webpack会轮询判断文件的最后编辑时间是否发生变化，某个文件发生变化后，并不会立刻告诉监听者，而是先缓存起来，等待aggregateTimeout（默认是300ms）后再进行更新。

### 热更新 webpack-dev-server

简称WDS，WDS不刷新浏览器，WDS不输出文件而是放在内存中，使用HotModuleReplacementPlugin插件，这个插件是webpack中自带的。

需要安装webpack-dev-server

在package.json文件的scripts中加上："dev": "webpack-dev-server --open"

在webpack.config.js中加上：

```js
const webpack = require('webpack')
module.exports = {
  entry:'xxx',
  output:{},
  mode:'development',
  plugins:[
    new webpack.HotModuleReplacementPlugin()
  ],
  devServer:{
    contentBase:'./dist',
    hot:true, // 开启热更新
    port:8533 // 更改端口为8533
  }
}
```

### 热更新 webpack-dev-middleware

简称WDM，将webpack输出的文件传输给服务器，适用于灵活的定制场景

需要安装webpack-dev-middleware、express

新建一个server.js文件：

```js
const express = require('express')
const webpack = reuqire('webpack')
const webpackDevMiddleware = require('webpack-dev-middleware')

const app = express()
const config = reuqire('./webpack.config.js')
const compiler = webpack(config)

app.use(webpackDevMiddleware(compiler,{
  publicPath:config.output.publicPath
}))

app.listen(3000,() => {
  console.log('example app listening on port 3000')
})
```

### webpack热更新原理

首先介绍几个概念：

+ Webpack Compiler：将JS编译为Bundle
+ HMR Server：在Webpack-dev-server中，将热更新的文件输出给HMR Runtime
+ HMR Runtime：在最后生成的bundle.js中，进行文件的更新
+ Bundle server：提供文件在浏览器中以localhost服务器的方式访问
+ bundle.js：最后构建输出的文件

在开启热更新之后，本地会开启一个Bundle Server提供localhost服务器的访问方式，构建生成的bundle.js文件中会被注入一个HMR Runtime。当接收/监听到文件改变后会将文件更新。同时，本地会开启一个HMR Server负责将热更新的文件通过websocket的方式输出给HMR Runtime

<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210712222930194.png" alt="image-20210712222930194" style="zoom:50%;" />

### 文件指纹

几个核心概念：

+ Hash：整个项目的构建有关，项目中有一个文件变化，该hash就会变化
+ ChunkHash：和打包的chunk有关，不同的entry会生成不同的chunkhash，同一个entry中若包含js和css，但只有js变化了，js和css文件的chunkhash都会发生改变
+ Contenthash:根据文件内容定义hash，文件内容不变，contenthash不变

**对于js文件可以使用chunkhash，css文件使用contenthash(设置在MiniCssExtractPlugin内)，图片字体文件使用hash(设置在file-loader内)。**

由于hash是在生产环境中的，而热更新是在开发环境中的，所以下面对config文件进行重构，将上面的文件重命名为webpack.dev.js。复制一份为webpack.prod.js。修改package.json文件的scripts如下：

```json
"scripts": {
    "build": "webpack --config webpack.prod.js",
    "watch": "webpack --watch",
    "dev": "webpack-dev-server --config webpack.dev.js --open"
 }
```

在webpack.prod.js文件中：

需要安装mini-css-extract-plugin，**特别注意，使用到该插件时是与style-loader互斥的，需要将style-loader替换掉**

```js
const path = require('path')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
module.exports = {
  entry:{
    index:'./src/index.js',
    search:'./src/search.js'
  },
  output:{
    path:path.join(__dirname,'dist'),
    filename:'[name]_[chunkhash:8].js'
  },
  mode:'production',
  module:{
    rules:[
      {
        test:/\.js$/,
        use:'babel-loader',
        exclude:/node_modules/
      },
      {
        test:/\.css$/,
        use:[MiniCssExtractPlugin.loader,'css-loader']
      },
      {
        test:/\.less$/,
        use:[MiniCssExtractPlugin.loader,'css-loader','less-loader']
      },
      {
        test:/\.(png | jpg | gif | svg)$/,
        use:[
          {
            loader:'file-loader',
            options:{
              name:'[name]_[hash:8].[ext]'
            }
          }
        ]
      }
    ]
  },
  plugins:[
    new MiniCssExtractPlugin({
      filename:'[name]_[contenthash:8].css'
    })
  ]
}
```

### 代码压缩

+ js文件的压缩：webpack4中内置了uglifyjs-webpack-plugin可以完成压缩
+ css文件的压缩：使用optimize-css-assets-webpack-plugin同时使用cssnano
+ html文件的压缩：使用html-webpack-plugin设置压缩参数

代码演示：需要安装optimize-css-assets-webpack-plugin、cssnano、html-webpack-plugin

```js
'use strict';
const path = require('path')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports = {
  entry: {
    index:'./src/index.js',
    search:'./src/search.js'
  },
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name]_[chunkhash:8].js'
  },
  mode:'production',
  module:{
    rules:[
      {
        test:/\.js$/,
        use:['babel-loader'],
        exclude:/node_modules/
      },
      {
        test:/\.css$/,
        use:[MiniCssExtractPlugin.loader,'css-loader']
      },
      {
        test:/\.less$/,
        use:[MiniCssExtractPlugin.loader,'css-loader','less-loader']
      },
      {
        test:/\.(png|svg|jpg|gif)$/,
        use:[
          {
            loader:'file-loader',
            options:{
              name:'[name]_[hash:8].[ext]'
            }
          }
        ]
      }
    ]
  },
  plugins:[
    new MiniCssExtractPlugin({
      filename:'[name]_[contenthash:8].css'
    }),
    new OptimizeCSSAssetsPlugin({
      assetNameRegExp:/\.css$/g,
      cssProcessor:require('cssnano')
    }),
    new HtmlWebpackPlugin({
      template: path.join(__dirname,'src/search.html'),
      filename:'search.html',
      chunks:['search'],
      inject:true,
      minify:{
        html5:true,
        collapseWhitespace:true,
        preserveLineBreaks:false,
        minifyCSS:true,
        minifyJS:true,
        removeComments:false
      }
    }),
    new HtmlWebpackPlugin({
      template: path.join(__dirname,'src/index.html'),
      filename:'index.html',
      chunks:['index'],
      inject:true,
      minify:{
        html5:true,
        collapseWhitespace:true,
        preserveLineBreaks:false,
        minifyCSS:true,
        minifyJS:true,
        removeComments:false
      }
    })
  ]
}
```

### 自动清理构建目录

之前每次构建之前都要手动清理上一次构建的目录，麻烦。

使用cleanWebpackPlugin，需要下载clean-webpack-plugin。

注意一下这里的引入需要{}

```js
const {CleanWebpackPlugin} = require('clean-webpack-plugin')

plugins:[
  new CleanWebpackPlugin()
]
```

### 增强css——自动补齐css3前缀

使用postcss-loader以及该loader生态的autoprefixer插件。

需要下载postcss-loader、autoprefixer

**注意，postcss-loader的执行顺序需要在css-loader之前，最好在less-loader或者sass-loader之后，同时autoprefixer是postcss-loader生态下的插件，需要将内容写在新建的postcss.config.js文件中**

webpack.prod.js：

```js
module:{
  rules:[
    {
      test:/\.css$/,
      use:[
        MiniCssExtractPlugin.loader,
        'css-loader',
        'postcss-loader'
      ]
    },
    {
      test:/\.less$/,
      use:[
        MiniCssExtractPlugin.loader,
        'css-loader',
        'postcss-loader',
        'less-loader'
      ]
    }
  ]
}
```

postcss.config.js：

```js
module.exports = {
  plugins:[
    require('autoprefixer')({
      overrideBrowserslist:['last 2 version','>1%','ios 7']
    })
  ]
}
```

### 增强css——px自动转换rem

使用px2rem-loader将px转换为rem之后，自动设置根元素的font-size使用手淘的lib-flexible库

**注意，px2rem-loader的执行顺序要在less-loader、sass-loader等预处理器loader之前**

```js
module:{
  rules:[
    {
      test:/\.css$/,
      use:[
        MiniCssExtractPlugin.loader,
        'css-loader',
        'postcss-loader',
        {
          loader:'px2rem-loader',
          options:{
            remUnit:75, // 1个rem相当于75个像素，适用于750px视觉稿
            remPrecision:8 // 保留几位小数
          }
        }
      ]
    },
    {
      test:/\.less$/,
      use:[
        MiniCssExtractPlugin.loader,
        'css-loader',
        'postcss-loader',
        'less-loader',
        {
          loader:'px2rem-loader',
          options:{
            remUnit:75, // 1个rem相当于75个像素，适用于750px视觉稿
            remPrecision:8 // 保留几位小数
          }
        }
      ]
    }
  ]
}
```

### 多页面应用打包通用方案

上面我们通过多个 html-webpack-plugin的方式实现了多页面的打包，还可以使用glob.sync的方式动态获取entry中的文件进行打包构建。

主要的实现方式就是setMPA函数，获取到所有的模板。**注意，这里需要对src中的文件层级进行修改，将对应的页面文件放入对应的文件夹中，并命名为index**：

<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210713150905153.png" alt="image-20210713150905153" style="zoom:80%;" />

需要安装glob

```js
'use strict';

const glob = require('glob')
const path = require('path')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')

const setMPA = () => {
  const entry = {}
  const htmlWebpackPlugin = []
  const entryFiles = glob.sync(path.join(__dirname, 'src/*/index.js'))
  Object.keys(entryFiles)
    .map((index) => {
      const entryFile = entryFiles[index]
      const match = entryFile.match(/src\/(.*)\/index\.js/)
      const pageName = match && match[1]

      entry[pageName] = entryFile
      htmlWebpackPlugin.push(
        new HtmlWebpackPlugin({
          template: path.join(__dirname, `src/${pageName}/index.html`),
          filename: `${pageName}.html`,
          chunks: [pageName],
          inject: true,
          minify: {
            html5: true,
            collapseWhitespace: true,
            preserveLineBreaks: false,
            minifyCSS: true,
            minifyJS: true,
            removeComments: false
          }
        }))
    })
  return {
    entry,
    htmlWebpackPlugin
  }
}
const {entry,htmlWebpackPlugin} = setMPA()

module.exports = {
  entry:entry,
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name]_[chunkhash:8].js'
  },
  mode: 'production',
  module: {},
  plugins: [
    new CleanWebpackPlugin(),
    new MiniCssExtractPlugin({
      filename: '[name]_[contenthash:8].css'
    }),
    new OptimizeCSSAssetsPlugin({
      assetNameRegExp: /\.css$/g,
      cssProcessor: require('cssnano')
    })
  ].concat(htmlWebpackPlugin)
}
```

### sourceMap

在开发模式development下使用，可以将打包后的代码的bug映射到源码

有几个关键的名词：

+ eval：没有单独的map文件，map相关信息放在代码的最后用eval包裹
+ source-map：生成单独的map文件
+ cheap：错误信息只包括行信息不包括列信息
+ inline：没有单独的map文件，map作为DataURI引入，会使文件变大
+ module：包含loader的sourcemap

![image-20210713154413735](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210713154413735.png)

**设置sourcemap只需要在配置文件中加上devtool：'xxx'即可.**相关的值见上图。常用的值有：source-map/cheap-source-map/eval等等

### 提取公共资源

1. 使用webpack4内置的SplitChunksPlugin提取公共第三方包（例如react等）。只需要在webpack.prod.js最后加上如下的optimization即可，最后别忘了在HtmlWebpackPlugin的chunks加上一个'vendors'

   ```js
   module.exports = {
   	plugins:[],
     optimization:{
       splitChunks:{
         cacheGroups:{
           vendors:{
             test:/(react|react-dom)/,
             name:'vendors',
             chunks:'all'
           }
         }
       }
     }
   }
   
   // 别忘了在HtmlWebpackPlugin的chunks加上一个'vendors'：
   new HtmlWebpackPlugin({
     chunks:['vendors',pageName]
   })
   ```

   

2. 在提取了公共的第三方之后，还可以提取公共的自己写的文件：

   ```js
   module.exports = {
   	plugins:[],
     optimization:{
       splitChunks:{
         minSize:0, //最小打包的限制，超过这个限制的就会被拿出来打包
         cacheGroups:{
           commons:{ // 提取common文件
             name:'commons',
             chunks:'all',
             minChunks:2 // 最少被引用了两次的就会被单独打包出来
           },
           vendors:{
             test:/(react|react-dom)/,
             name:'vendors',
             chunks:'all'
           }
         }
       }
     }
   }
   
   // 在HtmlWebpackPlugin的chunks加上'vendors'和'commons'：
   new HtmlWebpackPlugin({
     chunks:['vendors','commons',pageName]
   })
   ```

### Tree Shaking (摇树优化)

概念：一个模块可能包含了多种方法，但只要其中某个方法被使用到了，整个文件就会被引入到bundle中去，这是非常浪费的。于是有了tree shaking。没用到的方法会在uglify阶段被擦除掉。**简单来说，树摇就是留下有用的代码。**

tree shaking在webpack4中默认支持，且如果是production生产模式会默认开启。其他情况，例如development想要开启可以在.babelrc中设置"presets":[["env",{"modules":false}]]即可。

要求：该模块必须是ES6语法，CommonJS的语法不支持(也就是require这种)

原理：首先介绍一下DCE，就是那些不会执行不可到达、执行结果不会被用到、只会影响死变量(只写不读)的代码。这些代码就会在静态分析过程中被tree-shaking掉。

为什么TreeShaking需要ESM才能使用呢？因为TreeShaking是在打包编译的过程中执行的，而ESM本身就是编译时可以在编译阶段就确定依赖关系，CJS是执行时不能在编译阶段确定依赖关系也就不能进行TreeShaking

### scope hoisting

webpack打包出来的模块文件，每个模块都是一个单独的闭包，这样就会存在大量的重复构造闭包的代码，文件体积增大。

如下所示是打包后的一小部分代码：

```js
(function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helloworld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);

console.log(Object(_common__WEBPACK_IMPORTED_MODULE_1__["common"])());
document.write(Object(_helloworld__WEBPACK_IMPORTED_MODULE_0__["helloworld"])());
/***/ }),
```

打包之前的代码如下：

```js
import { helloworld } from "./helloworld";
import {common} from '../../common'
console.log(common());
document.write(helloworld())
```

可以看到，外面用一层闭包进行包裹，import语句用\__webpack_require__(moduleId)代替。

\__webpack_require__(moduleId)用于加载模块，首次加载会将模块放入installedModules中，后续脚在使用会直接通过id找到并返回模块。这也就是说模块可以不按照顺序进行加载

\__webpack_require__(0)就是从entry中启动打包

**scope hoisting原理：**将所有模块的代码按照引用的顺序放在一个函数作用域内，然后进行适当的重命名，防止变量名冲突。

**用法：**mode设置为production会默认开启scope hoisting；或者在插件中插入以下内容：

```js
module.exports = {
  ....,
  plugins:[new webpack.optimize.ModuleConcatenationPlugin()]
}
```

### 代码分割(比如动态import实现路由懒加载)

动态import的语法为：import('文件')  然后会返回一个promise对象，then中的value就是import进来的内容。例如：

```js
import('./text.js').then((Text) => {
  this.setState({
    Text:Text.default
  })
})
```

动态import没有原生支持，需要安装babel的相关插件：@babel/plugin-syntax-dynamic-import 

然后在.babelrc中的plugins进行配置：

```json
{
  "presets": [
    ["@babel/preset-env"],
    "@babel/preset-react"
  ],
  "plugins":[
    "@babel/plugin-syntax-dynamic-import"
  ]
}
```

### webpack打包基础库

平时通过npm install下来的第三方库，可以通过webpack打包并发布。下面打包一个大数加法large-number的基础库

首先，需求如下：需要打包压缩版.min.js文件和非压缩版.js文件，实现在生产环境中自动导出.min.js文件，开发环境导出.js文件，并且引入方式支持CJS、amd、es6 module。

应用到了webpack的插件terser-webpack-plugin。src/index.js就是大数加法源文件。

<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210713214409279.png" alt="image-20210713214409279" style="zoom:65%;" />

<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210713214426739.png" alt="image-20210713214426739" style="zoom:50%;" />

新建webpack.config.js文件进行打包配置：主要体现在output中的不一样

```js
const TerserPlugin = require('terser-webpack-plugin')
module.exports = {
  entry:{
    "large-number":'./src/index.js',
    "large-number.min":'./src/index.js'
  },
  output:{
    filename:'[name].js',
    library:'largeNumber', //打包出来的库的名称
    libraryTarget:'umd', // 打包出来的库支持的引入方式
    libraryExport:'default' // 打包出来的库的默认引入
  },
  mode:"none",
  optimization:{
    minimize:true,
    minimizer:[
      new TerserPlugin({ // 设置压缩，只压缩.min.js
        include:/\.min\.js$/
      })
    ]
  }
}
```

然后在根目录下新建index.js文件用于判断环境实现不同的文件导入：

```js
if (process.env.NODE_ENV == 'production'){
  module.exports = require('./dist/large-number.min.js')
}else{
  module.exports = require('./dist/large-number.js')
}
```

### webpack 服务端渲染(SSR)

SSR就是将首屏数据在服务端完成渲染，返回给客户端的是一个渲染完成的html文件。相比于客户端渲染，有利于SEO优化和首屏时间。

主要原理是服务端跑一个node，先读取webpack打包好的html文件作为模板，然后读取相应的js文件，在服务器中先将模板中的内容进行替换后将最后的html文件返回给客户端。

要注意的点有：

1. React的组件文件最后不能使用ReactDOM.render进行渲染，应该使用module.exports = <组件 />返回。并且，组件内的导入方式要改为require的形式。最后，为了能够进行事件的绑定，还要在客户端再次渲染一遍js，所以在js中使用document===undefined进行判断是在客户端还是服务端。在服务端则使用上面的module.exports = <组件 />返回；在客户端则使用常规的ReactDom.render（）进行组件渲染
2. 在服务端的node中，要注意对代码window进行hack，替换掉来避免报错
3. webpack配置中，需要对相应的文件名进行处理，并且要注意设置output的libraryTarget为umd

webpack.ssr.js：

```js
'use strict';

const glob = require('glob')
const path = require('path')
const webpack = require('webpack')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')

const setMPA = () => {
  const entry = {}
  const htmlWebpackPlugin = []

  const entryFiles = glob.sync(path.join(__dirname, 'src/*/index-server.js'))
  Object.keys(entryFiles)
    .map((index) => {
      const entryFile = entryFiles[index]
      const match = entryFile.match(/src\/(.*)\/index-server\.js/)
      const pageName = match && match[1]
      if (pageName) {
        entry[pageName] = entryFile
        htmlWebpackPlugin.push(
          new HtmlWebpackPlugin({
            template: path.join(__dirname, `src/${pageName}/index.html`),
            filename: `${pageName}.html`,
            chunks: ['vendors', 'commons', pageName],
            inject: true,
            minify: {
              html5: true,
              collapseWhitespace: true,
              preserveLineBreaks: false,
              minifyCSS: true,
              minifyJS: true,
              removeComments: false
            }
          }))
      }
    })
  return {
    entry,
    htmlWebpackPlugin
  }
}
const { entry, htmlWebpackPlugin } = setMPA()

module.exports = {
  entry: entry,
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name]-server.js',
    libraryTarget: 'umd'
  },
  mode: 'none',
  module: {
    rules: [
      {
        test: /\.js$/,
        use: ['babel-loader'],
        exclude:/node_modules/
      },
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader'
        ]
      },
      {
        test: /\.less$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'less-loader'
        ]
      },
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: [
          {
            loader: 'file-loader',
            options: {
              name: '[name]_[hash:8].[ext]'
            }
          }
        ]
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin(),
    new MiniCssExtractPlugin({
      filename: '[name]_[contenthash:8].css'
    }),
    new OptimizeCSSAssetsPlugin({
      assetNameRegExp: /\.css$/g,
      cssProcessor: require('cssnano')
    })
  ].concat(htmlWebpackPlugin),
}
```

search/index-search.js (服务端渲染的js文件)：

```js
'use strict';
const React = require('react')
const small = require('./img/small.jpg')
const ReactDOM = require('react-dom')
require('./search.less')

class Search extends React.Component {
  constructor() {
    super(...arguments)
    this.state = {
      Text: null
    }
  }

  loadComponent() {
    import('./text.js').then((Text) => {
      this.setState({
        Text: Text.default
      })
    })
  }

  render() {
    const { Text } = this.state
    return <div className='search-text'>
      {
        Text ? <Text /> : null
      }
      <img src={small.default} onClick={this.loadComponent.bind(this)} />
    </div>;
  }
}

if (typeof document === "undefined") {
  console.log('在服务端渲染')
  module.exports = <Search />;
} else {
  console.log('在客户端渲染')
  ReactDOM.render(
    <Search />,
    document.getElementById('root')
  )
}
```

server/index.js (服务端node)：

```js
if (typeof window === 'undefined'){
  global.window = {}
}
const fs = require('fs')
const path = require('path')
const express = require('express')
const {renderToString} = require('react-dom/server')
const SSR = require('../dist/search-server')
const template = fs.readFileSync(path.join(__dirname,'../dist/search.html'),'utf-8')

const server = (port) =>{
  const app = new express()
  app.use(express.static('dist'))
  app.get('/search',(req,res) => {
    const html = renderMarkup(renderToString(SSR))
    res.status(200).send(html)
  })

  app.listen(port,() => {
    console.log('server running on' + port)
  })
}

const renderMarkup = (str) =>{
  return template.replace('<!--HTML_PLACEHOLDER-->',str)
}
server(process.env.PORT || 3000)
```

### 优化打包时命令行的显示日志

使用friendly-errors-webpack-plugin插件并设置stats为'error-only'

<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210714141753413.png" alt="image-20210714141753413" style="zoom:50%;" />

```js
const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin')
module.exports = {
  entry:xxx,
  ....
  stats:'error-only',
  plugins:[
  	new FriendlyErrorsWebpackPlugin()
  ]
}
```

### 可维护的webpack配置

将webpack配置分为四个文件：webpack.base.js、webpack.prod.js、webpack.dev.js、webpack.ssr.js

+ webpack.base.js：基础配置。包含资源解析(es6、js、es6、css、less、图片、字体等)、样式增强(css前缀、px2rem)、目录清理、多页面打包、命令行显示优化、css单独抽成一个文件
+ webpack.prod.js：生产阶段配置。包含代码压缩(css/html/js)、文件指纹、Tree Shaking、Scope Hoisting、速度优化、体积优化
+ webpack.dev.js：开发阶段配置。包含代码热更新、sourcemap
+ webpack.ssr.js：SSR配置。包含output中的libraryTarget配置

### webpack优化

#### 使用speed-measure-webpack-plugin查看各项时间

使用该插件可以查看每个loader和plugin的运行时间

使用方式：安装、引入、实例化、使用实例化对象的wrap方法将module.exports包裹起来：

```js
const speedMeasureWebpackPlugin = require('speed-measure-webpack-plugin')
const swp = new speedMeasureWebpackPlugin()
module.exports = swp.wrap({
  entry:xxx
  ....
})
```

#### 使用webpack-bundle-analyzer分析体积

使用该插件构建完成后会在8888端口展示大小

使用方式：安装、引入(注意const {BundleAnalyzerPlugin} = require('webpack-bundle-analyzer'))、在plugins实例化：

```js
const {BundleAnalyzerPlugin} = require('webpack-bundle-analyzer')

module.exports = {
  entry:xxx,
  ....
  plugins:[new BundleAnalyzerPlugin()]
}
```

#### 优化方式(体积、速度)

**速度优化：**

+ 使用高版本的webpack和Node。高版本的webpack做了很多优化(ru Tree Shaking等)且构建速度更快；高版本的Node对代码的执行速度更快，做了更多的优化(如map/set代替object、for of代替forEach、includes代替indexOf等等)

+ 多进程/多实例构建。使用thread-loader，执行顺序位于最后，也就是放在所有loader的最前面，可以配置其options{workers: 数量}

  ```js
  {
    test:/\.js$/,
    use:[
      {
        loader: 'thread-loader',
        options:{
          worker: 3
        }
      },
      'babel-loader'
    ],
     exclude:/node_modules/
  }
  ```

+ 多进程/多实例并行压缩。使用terser-webpack-plugin开启parallel参数即可，设置在optimization的minimizer内，通过new terserPlugin({parallel: 4})

  ```js
  const TerserPlugin = require('terser-webpack-plugin')
  module.exports = {
    entry:xxx,
    ...,
    optimization:{
      minimizer:[
        new TerserPlugin({
        	parallel: 4
      	})
      ]
    }
  }
  ```

+ 预编译资源模块。使用DLLPlugin进行分包，DLLReferencePlugin对manifest.json引用。简单来说就是将项目中的react、react-dom、redux等基础包和业务基础包打包成一个文件。使用方式：先创建一个webpack.dll.js文件内置关于dllplugin的配置；再在webpack.config.js中使用DLLReferencePlugin引用manifest.json。然后在package.json中新建一个dll命令运行webpack.dll.js，运行dll之后再进行build

  ```js
  // 新建的webpack.dll.js：
  const webpack = require('webpack')
  const path = require('path')
  module.exports = {
    entry:{
      library:[
        'react',
        'react-dom'
      ]
    },
    output:{
      filename:'[name]_[hash].dll.js',
      path:path.join(__dirname,'build/library'),
      library:'[name]_[hash]' //注意这里要与下面的name相同
    },
    plugins:[
      new webpack.DllPlugin({
        name:'[name]_[hash]',//注意这里要与上面的library相同
        path:path.join(__dirname,'build/library/manifest.json')
      })
    ]
  }
  
  
  // webpack.config.js：
  plugins:[
    new webpack.DllReferencePlugin({
       manifest:require('./build/library/manifest.json')
      }),
  ]
  ```

+ 利用缓存提升二次构建速度。使用到的loader/plugin有：babel-loader、terser-webpack-plugin、cache-loader或者hard-source-webpack-plugin。首先babel-loader开启缓存只需要在后面加上?cacheDirevtory=true;terser-webpack-plugin开启缓存加上cache：true即可；hard-source-webpack-plugin开启缓存效果显著，直接引入并new即可。

  ```js
  const HardSourceWebpackPlugin = require('hard-source-webpack-plugin')
  module.exports = {
    entry:xxx,
    output:{},
    module:{
      rules:[
        {
          test:/\.js$/,
          use:[
            {
              loader:'thread-loader',
              options:{
                workers: 3
              }
            },
            'babel-loader?cacheDirectory=true' // 开启babel-loader缓存
          ],
          exclude:/node_modules/
        }
      ]
    },
    plugins:[
      new HardSourceWebpackPlugin() // 开启hard-source-webpack-plugin缓存
    ],
    optimization:{
      minimizer:[
        new TerserPlugin({
          parallel:true,
          cache:true // 开启TerserPlugin缓存
        })
      ]
    }
  }
  ```

+ 缩小构建范围。例如解析js的时候设置exclude：/node_modules/，不需要对第三方包的js进行转换

+ 减少文件的搜索范围。这个主要是通过设置resolve来完成的，比如设置resolve.alias文件夹别名优化查找速度、设置resolve.modules限定第三方包的查找范围、设置resolve.mainFields指定入口文件的查找按照package.json的main字段查找、设置resolve.extensions简化后缀查找(默认会按照js->json等顺序)：

  ```js
  const path = require('path')
  module.exports = {
    resolve:{
      alias:{
    'react':path.resolve(__dirname,'./node_modules/react/dist/react.min.js') // 设置react别名
      },
    modules:[path.resolve(__dirname,'node_modules')],
    mainFields:['main'],
    extensions:['.js']
  	}
  }
  ```




**体积优化**

+ Scope Hoisting
+ Tree Shaking
+ 公共资源分离(split chunks)
+ 动态polyfill



###webpack工作流程

<img src="https://user-gold-cdn.xitu.io/2020/7/29/1739822c9b10d329?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:150%;" />

<img src="https://user-gold-cdn.xitu.io/2019/8/7/16c69e3ef33f87b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:67%;" />

主要分为三个阶段：准备阶段、

模块构建和chunk生成阶段、文件生成

#### 准备阶段

+ 确定参数。从命令行和配置文件中读取并合并参数，得出最终的参数
+ 实例化Compiler。用上面确定好的参数初始化Compiler对象
+ 加载插件。依次调用插件的apply方法，传入Compiler，这样插件就能监听到钩子事件并能够使用相关的API
+ 处理入口，根据配置中的entry找到所有的入口文件

#### 模块构建和chunk生成阶段

+ 将entry对应的module生成一个新的chunk
+ 遍历module的依赖列表，将所依赖的module也加入到chunk中去
+ 如果依赖的module是动态引入的，则会根据这个module创建一个新的chunk，继续遍历其依赖
+ 得到所有的chunk。在这过程中还会根据模块使用对应的loader进行转换

#### 文件生成阶段

+ 渲染源码，将chunk按照模板生成输出资源
+ 执行文件输出，将文件输出到磁盘

### 手写一个webpack实现打包js文件

主要分为四个文件，包含一个配置文件用于配置entry和output、三个lib文件。lib文件夹中包含三个文件，入口文件index.js、将es6转es5的paarser.js、渲染模板并写入文件的compile.js

首先是配置文件simplepack.config.js：

```js
const path = require('path')

module.exports = {
  entry:path.join(__dirname,'./src/index.js'),
  output:{
    path:path.join(__dirname,'./dist'),
    filename:'main.js'
  }
}
```

然后是lib/index.js入口文件:

```js
const Compiler = require('./compile')
const options = require('../simplepack.config') // 读取配置文件中的配置

new Compiler(options).run() // 开始编译
```

es6转es5的lib/parser.js:

其中的babylon库用于将文件转换成对应的AST

babel-traverse用于遍历AST并找到依赖关系

babel-core用于将AST转换成es5的代码

```js
const fs = require('fs')
const babylon = require('babylon')
const traverse = require('babel-traverse').default
const {transformFromAst} = require('babel-core')

module.exports = {
  // getAST用于得到一个文件的AST
  getAST: (path) => {
    const source = fs.readFileSync(path, 'utf-8')
    return babylon.parse(source, {
      sourceType: 'module'
    })
  },
	// getDependencies用于从ast中分析得到依赖数组
  getDependencies: (ast) => {
    const dependencies = []
    traverse(ast,{
      ImportDeclaration:({node}) => {
        dependencies.push(node.source.value)
      }
    })
    return dependencies
  },
	// transform用于将ast转换成es5代码
  transform:(ast) =>{
    const {code} = transformFromAst(ast,null,{
      presets:['env']
    })
    return code
  }
}
```

渲染模板并输出文件的compile.js:

```js
const {getAST,getDependencies,transform} = require('./parser')
const path = require('path')
const fs = require('fs')
module.exports = class Compiler{
  constructor(options){
    const {entry,output} = options
    this.entry = entry
    this.output = output
    this.modules = []
  }
  run(){
    const entryModule = this.buildModule(this.entry,true)
    this.modules.push(entryModule)
    this.modules.map(_module =>{
      _module.dependencies.map(dependency => {
        this.modules.push(this.buildModule(dependency))
      })
    })
    this.emitFiles()
  }

  buildModule(filename,isEntry){
    let ast;
    if(isEntry){
      ast = getAST(filename)
    }else{
      const absolutePath = path.join(process.cwd(),`./src`,filename)
      ast = getAST(absolutePath)
    }
    return {
      filename,
      dependencies:getDependencies(ast),
      source:transform(ast)
    }
  }

  emitFiles(){
    const outputPath = path.join(this.output.path,this.output.filename)
    let modules = ''
    this.modules.map(_module =>{
      modules += `'${_module.filename}':function(require,module,exports){${_module.source}},`
    })
    const bundle = `(function(modules){
      function require(filename) {
        var fn = modules[filename];
        var module = {exports:{}}
        fn(require,module,module.exports);
        return module.exports
      }
      require('${this.entry}')
    })({${modules}})`

    fs.writeFileSync(outputPath,bundle,'utf-8')
  }
}
```

注意安装以及.bablerc的配置：

```json
// 安装
"dependencies": {
    "@babel/preset-env": "^7.5.5",
    "babel-core": "^6.26.3",
    "babel-preset-env": "1.7",
    "babel-traverse": "6.26",
    "babylon": "^6.18.0"
}

// .babelrc的配置
{
  "presets": [
    "@babel/preset-env"
  ]
}
```

其实最后生成的bundle.js文件代码大概是这样的：

```js
(function (list){
  function reuqire(file) {
    var exports = {};
    (function (exports,code){
      eval(code)
    })(exports,list[file])
    return exports
  }
  require('index.js')
})({
  "index.js": `var add = require('add.js').default; console.log(add(2,4))`,
  "add.js": `var a = 123;exports.default = function (a,b){return a + b}`
})
```



### 手写一个loader

#### 如何实现链式调用

loader本质上就是一个函数，接收一个参数source，就是对应匹配到的文件内容的字符串格式。

由于loader需要实现链式调用，最后需要将source返回出去，返回的方式有两种，如果loader进行了异步操作(如io操作)，则需要异步返回；如果没有进行异步操作，进行同步返回即可：

+ 异步返回：const callback = this.async();  callback(error,source)
+ 同步返回：this.callback(error,source)

#### 如何获取options 的参数

如果使用loader时通过options传递了参数，可以通过loaderUtils(需要安装loader-utils)的getOptions(this)方式获取到参数：const loaderUtils = require('loader-utils')  const{name} = loaderUtils.getOptions(this)

#### 如何在loader中进行文件的写入

使用this.emitFile(url,内容)的方式进行文件写入，url可以通过loaderUtils.interpolateName(this,'[name].[ext]',source)的方式进行获取。也可以通过fs.writeFileSync写入。**注意，在使用loader-runner插件条件下调试无法使用this.emitFile方法，只能在webpack环境下使用**

#### 如何调试

+ 可以手动安装webpack+webpack-cli，然后按照配置文件的形式进行调试：

  ```js
  modules:{
    rules:[
      {
        test:/\.js$/,
        use:[
          path.resolve('./loaders/a-loader'),
          path.resolve('./loaders/b-loader')
        ]
      }
    ]
  }
  ```

+ 或者使用loader-runner插件。仅仅需要安装loader-runner即可，但注意，在此方式下调试无法使用this.emitFile方法进行文件写入。这种方式需要额外编写一个run-loader.js文件：其中的resource用于指定传入的文件；loaders指定要调试的loader文件；readResource指定读取文件的方式

  ```js
  const fs = require('fs')
  const path = require('path')
  const {runLoaders} = require('loader-runner')
  
  runLoaders({
    resource:'./loaders/index.css', // 指定传入的文件
    loaders:[path.resolve(__dirname,'./loaders/sprite-loader')], // 指定要调试的loader文件
    readResource:fs.readFile.bind(fs) // 指定读取文件的方式
  },
    (err,result) => (err ? console.log(err) : null)
  )
  ```

#### 实战-编写一个合成雪碧图loader

需求：对css文件中的url(xxx?__sprite) 图片合成为一张雪碧图，并将url替换为该雪碧图，同时设置好对应的image-position

使用到了第三方库：spritesmith用于将多张图片合成为一张图片

run-loader.js调试文件：

```js
const fs = require('fs')
const path = require('path')
const {runLoaders} = require('loader-runner')

runLoaders({
  resource:'./loaders/index.css',
  loaders:[path.resolve(__dirname,'./loaders/sprite-loader')],
  readResource:fs.readFile.bind(fs)
},
  (err,result) => (err ? console.log(err) : null)

)
```

sprite-loader.js loader文件：

```js
const Spritesmith = require('spritesmith')
const fs = require('fs')
const path = require('path')

module.exports = function (source) {
  const callback = this.async()
  const imgs = source.match(/url\((\S*)\?__sprite/g)

  const matchedImgs = new Map()
  for (let i = 0; i < imgs.length; i++) {
    const img = imgs[i].match(/url\((\S*)\?__sprite/)[1]
    matchedImgs.set(i,path.join(__dirname, img))
  }

  Spritesmith.run({
    src: Array.from(matchedImgs.values()),
  }, (err, result) => {
    fs.writeFileSync(path.join(process.cwd(), 'dist/sprite.jpg'),result.image)
    let i = 0
    source = source.replace(/url\((\S*)\?__sprite\)/g, (...args) => {
      return `url(./sprite.jpg) -${result.coordinates[matchedImgs.get(i )].x}px -${result.coordinates[matchedImgs.get(i ++)].y}px`
    })
    fs.writeFileSync(path.join(process.cwd(),'dist/index.css'),source)
    callback(null, source)
  })
}
```

### 手写一个plugin

#### 基本形式

plugin是一个类，内部必须包含一个apply方法，接收compiler对象作为参数，对钩子事件进行监听并处理。还可以有一个构造函数接收传递的参数：

```js
module.exports = class MyPlugin{
  constructor(options){
    this.options = options
  }
  apply(compiler){
    console.log('options',this.options)
  }
}
```

#### 错误处理

+ 在参数校验阶段，也就是constructor内可以通过throw new Error的方式抛出错误
+ 在钩子事件监听阶段，通过compilation.warning.push()处理警告或者compilation.errors.push()处理错误

#### 如何在plugin中进行文件写入

 需要使用到webpack-sources第三方库中的RawSource。在监听emit事件钩子的回调函数中实现：

```js
const { RawSource } = require('webpack-sources')
module.exports = class MyPlugin{
  constructor(options){
    this.options = options
  }
  apply(compiler){
    const {name} = this.options
    // 实现文件的写入
    compiler.hooks.emit.tapAsync('MyPlugin',(compilation,cb) => {
      compilation.assets[文件路径.ext] = new RawSource("demo")
      cb()
    })
  }
}
```

#### 实战-编写一个压缩构建资源为zip包的插件

使用到了第三方库jszip和webpack-sources，其中jszip用于生成zip文件、webpack-sources中的RawSource用于写入文件。

jszip的用法：

+ 首先引入JSZip = require('jszip')
+ 然后实例化对象const zip = new JSZip()
+ 接下来创建一个zip文件：const folder = zip.folder(文件名)
+ 然后将需要合成zip的文件都塞入folder中：folder.file(被zip的文件名，文件source)
+ 最后生成zip文件：zip.generateAsync({type:nodebuffer}).then(content =>{content就是最终的zip文件内容，后续可以将其写入文件中})

zip-plugin：

```js
const JSZip = require('jszip')
const zip = new JSZip()
const path = require('path')
const RawSource = require('webpack-sources').RawSource

module.exports = class ZipPlugin {
  constructor(options) {
    this.options = options
  }

  apply(compiler) {
    const zipName = (this.options && this.options.filename) || 'test'
    compiler.hooks.emit.tapAsync('ZipPlugin', (compilation, cb) => {
      const folder = zip.folder(zipName)
      // console.log(compilation.assets)
      for (let filename in compilation.assets) {
        const source = compilation.assets[filename].source()
        // console.log(source)
        folder.file(filename, source)
      }
      zip.generateAsync({
        type: 'nodebuffer'
      }).then(content => {
        // console.log(compilation.options)
        const outputPath = path.join(
          compilation.options.output.path,
          zipName + '.zip'
        )
        const outputRelativePath = path.relative(
          compilation.options.output.path,
          outputPath
        )
        compilation.assets[outputRelativePath] = new RawSource(content)
        cb()
      })
    })
  }
}
```



### babel-runtime和babel-polyfill的区别

babel默认只转换新的javascript语法，而不转换新的API，例如Iterator、Symbol、Promise等，如果要使用这些新的对象和方法，就需要使用babel-polyfill

而babel-runtime是为了减少重复的代码，能够将工具函数diamante转换成require语句，



### bundle、module、chunk的区别

+ 我们手写的一个个文件都可以看做是一个module
+ 将module源文件传到webpack进行打包时，会根据文件引用关系生成chunk文件
+ webpack处理好chunk之后，最终会根据文件类型(css/js...)输出bundle文件，可以直接在浏览器中运行

### plugin和loader的区别

loader：webpack默认只能识别js、json文件，如果需要打包其他文件，就需要使用到loader，loader的作用就是让webpack拥有了加载和解析非javascript文件的能力

plugin：扩展webpack的功能，让webpack具有更多的灵活性

几个loader：

+ style-loader：将css样式以style标签插入带页面中

+ css-loader：处理css文件中的@import和url()

+ less-loader：处理less

+ sass-loader：处理sass

+ px2rem-loader：将css的px转换成rem

+ raw-loader：将文件以字符串的形式导入

+ thread-loader：多进程打包js和css

+ url-loader: 处理图片等文件的地址，对于小的图片直接使用base64编码，大的图片会交给下面的file-loader处理

+ file-loader：处理字体图片等文件，在代码中通过相对URL去引用输出的文件，二者的配置如下所示：

  ```json
  use:[
    {
      loader:'url-loader'
    	options:{
      	limit:10240,// 限制大小，超过大小的采用下面的fallback
      	fallback:{
      		loader:'filer-loader',
      		options:{
      			name:'img/[name].[hash:8].ext'
    			}
    		}
    	}
    }
  ]
  ```

+ image-loader：加载并压缩图片文件

+ babel-loader：将ES6转换成ES5

+ ts-loader：将TypeScript转换成Js

+ postcss-loader：扩展css语法，配合autoprefixer插件自动补齐css3前缀

+ vue-loader：加载Vue单文件组件，解析出其中的template、css、js交给相应的loader处理

+ cache-loader：在性能开销大的Loader之前添加，可以将结果缓存在磁盘中



几个plugin：

+ htmlWebpackPlugin：创建一个html模板，并自动引入chunk包
+ ZipWebpackPlugin：将打包出的资源生成一个zip包
+ UglifyJsWebpackPlugin：压缩js代码
+ cleanWebpackPlugin：打包输出前清空文件夹
+ miniCssExtractPlugin：没有这个插件的话会将所有css写在html文件中，这个插件将css单独拆分出来一个文件
+ OptimizeCSSAssetsPlugin：压缩css
+ splitChunksPlugin: 分离chunks
+ bannerPlugin：在产出的资源文件头部添加信息，比如作者版权等
+ Webpack.HotModuleReplacementPlugin：热更新
+ copyWebpackPlugin：拷贝静态资源
+ FriendlyErrorsWebpackPlugin：命令行日志简化
+ DefinePlugin: 创建一个在编译时可以配置的全局常量，对开发模式和生产模式构建产生的不同行为非常有用
+ bundleAnalyzerPlugin：分析每个包的体积
+ HardSourceWebpackPlugin：构建时开启缓存加快构建速度
+ vueLoaderPlugin：处理vue文件
+ terserPlugin： 文件压缩





## 计算机网络部分

**TCP/IP的五层模型：物理层、数据链路层(MAC地址、以太网协议)、网络层(IP协议)、传输层(TCP/UDP协议)、应用层(HTTP协议)**

### HTTP协议

#### HTTP常见的状态码

+ 1xx 提示信息 表示目前是协议处理的中间状态，还需要后续的操作
+ 2xx 服务器成功处理了客户端的请求
+ + 200 OK  表示一切正常，如果是非HEAD请求，返回的响应头中都会有body数据
  + 204 No Content   也是常见的成功状态码，响应头中没有body数据
  + 206 Partial Content 应用于分块下载或者断点续传，表示当前返回的数据不是全部资源
+ 3xx  表示客户端请求的资源发生了变动，需要重定向
+ + 301 Moved Permanently  永久重定向，请求的资源已经不存在了，需要使用新的URL，在响应头中会有Location字段，指明后续要跳转的URL，浏览器会自动重定向过去。浏览器会做缓存优化，下一次会直接跳转到新的地址中去
  + 302 Found  表示临时重定向，请求的资源还在，但是暂时需要另一个URl访问，在响应头中会有Location字段，指明后续要跳转的URL，浏览器会自动重定向过去
  + 304 Not Modified  不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，用于缓存控制.表示本地存在缓存文件且该缓存文件还在有效期内未失效
+ 4xx  表示客户端发送的报文有错误，服务器无法处理
+ + 400 Bad Request 表示报文有错误。但只是个笼统的错误
  + 401 No authentication token found  token错误/未找到
  + 403 Forbidden   表示服务器禁止访问资源
  + 404 Not Found 表示请求的资源在服务器上未找到
  + 405 Method Not Allowed 请求方法不被服务器允许
+ 5xx  表示客户端报文正常，但服务器内部发生了错误
+ + 500 Internal Server Error 服务内部错误
  + 501 Not Implmented  客户端请求的功能还不支持。
  + 502 Bad GateWay  服务器作为网关或者代理返回的错误码，表示从上游服务器收到了无效的相应
  + 503 Service Unavailable 表示服务器繁忙，暂时无法响应
  + 504 服务器作为网关或者代理时，未能及时从上游服务器收到回应（网关超时）
  + 505 协议不匹配

### HTTP请求行/响应行

#### 请求行

```js
// 请求方法  请求URL  HTTP协议和版本
POST /chapter17/user.html HTTP
/1.1
```

#### 响应行

```js
// HTTP协议和版本 状态码 描述
HTTP/1.1 200 OK
```



#### HTTP常见的请求头/响应头

**头部信息每一行以\r\n结尾，头部与体之间的信息以一个空行隔开，也就是空行\r\n，当检测到两对\r\n是，下一个字符开始就是体了**

**request header：**

```json
Host: www.test.com/  //请求的目标域名和端口号
Origin: http://localhost:8081/  //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）
Referer: https:/localhost:8081/link?query=xxxxx  //	请求的来源
User-Agent //浏览器信息
Cookie: //当前域名下的Cookie
Accept: text/html,image/apng  //代表客户端希望接受的数据类型是html或者是png图片类型 
Accept-Encoding: gzip, deflate  //代表客户端能支持gzip和deflate格式的压缩
Accept-Language: zh-CN,zh;q=0.9  //代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)
Connection: keep-alive  //告诉服务器，客户端需要的tcp连接是一个长连接
If-None-Match  //如果内容未改变返回304代码，对应Etag
If-Modified-Since //对应last-modified，未被修改则返回304代码
Content-Type: text/html; charset=utf-8  //编码格式 还有application/x-www-form-urlencoded(普通表单); multipart/form-data(文件上传);  application/json(json字符串)
```

**response header：**

```json
Date: //服务端发送资源时的服务器时间
Expires: //缓存过期时间
Cache-Control:  no-cache  // 缓存方式
Etag  // 文件内容hash
Last-Modified  //最近一次文件修改时间
Content-Type: text/html; charset=utf-8  //编码格式 还有aplication/x-www-form-urlencoded; multipart/form-data;  apllication/json
Content-Encoding: gzip  //采用gzip对资源进行解码
Connection: keep-alive  //tcp是长连接
Set-Cookie //设置Http Cookie 
```

#### HTTP1.1

1. 默认开启了长连接，也就是默认设置Connection:keep-alive
2. 引入管道机制，即在同一个TCP连接内可以同时发送多个请求，但服务器还是会按照顺序依次回应
3. HTTP/1.1 通过引入 Chunk transfer 机制来解决动态生成不知道长度的问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。
5. 虚拟主机的支持，增加了host字段表示当前的域名地址，服务器可以对不同的域名做不同的处理
6. **缺点：**虽然有管道机制，但服务器回应时依旧可能造成队头堵塞。为了解决这一问题，有两种办法：减少请求数和同时多开持久连接

#### HTTP2

1. 头信息和数据体都是二进制，并且将它们统称为“帧”(frame): 头信息帧和数据帧
2. 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应且不用按顺序一一回应，这样避免了“队头堵塞”。这样双向的、实时的通信就叫做多工
3. 由于HTTP2的数据包是不按顺序发送的，所以必须要对数据包做标记。将属于一个请求或者回应的所有数据包称为一个**数据流(stream)**,每个数据流都有着独一无二的编号，在数据包发送时会标记这个编号来区分属于哪个数据流
4. HTTP2可以取消某一次请求而不关闭TCP连接，客户端还可以指定数据流的优先级，优先级越高，服务器就会越早相应
5. 引入头信息压缩机制，一方面头信息需要使用gzip或者compress压缩后再发送；另一方面，客户端和服务器同时维护一张信息表，所有字段都会存入这张表，往后只需要发送索引号即可
6. 允许服务器主动发送资源，叫做server push
7. 解除了浏览器对于每个域名最多维护6个TCP连接的限制

#### HTTPS

1. HTTPS为了解决HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL/TSL安全协议，使得报文能够加密传输。加密的原理：混合加密（对称加密+非对称加密）
2. HTTPS在TCP三次握手之后还需要进行SSL/TSL的握手过程，才能进入加密报文传输
3. HTTP的端口是80，HTTPS的端口是443
4. 混合加密过程：浏览器向服务器发送client_random和加密方法列表，服务器接收到返回server_random、加密方法以及非对称加密的公钥A；浏览器接收，接着生成另一个随机数pre_random，并且使用公钥A进行加密，传给服务器；服务器用非对称加密的私钥A‘解出pre_random；接下来两者采用相同的加密方法混合client_random、server_random、pre_random，生成最后的密钥用于通信。在HTTPS中，服务器的公钥A藏在数字证书中。
5. HTTPS证书如何保证不被篡改？数字签名。数字签名就是对元信息(证书所有者的信息，例如基本信息、公钥等)。然后使用CA机构的公钥进行解密验证元信息是否一致就能判断证书是否合法。数字签名与验证过程：一、签名：先通过哈希算法将内容编码成摘要，接着使用自己的私钥对摘要进行加密得到数字签名，将数字签名+内容一起发送。
二、验证：首先同样适用哈希算法将内容编码为摘要，然后使用公钥对签名进行解密，将解密结果与摘要进行对比，一致表示签名正确
6. **为了解决每一次请求都需要SSL握手问题，服务端会生成一个Session ID，客户端和服务端都可以对其进行保存，后续握手只需要发送该Session ID 就可以完成一次快速握手**
7. 前端加密：md5加密

### SSL、TSL建立连接过程

1. 首先，客户端发送自己的SSL版本、加密算法列表等给服务端
2. 服务端收到后将加密方法套件、版本号以及公钥(数字证书)发送给客户端
3. 客户端收到后，验证数字证书的合法性，并使用公钥加密生成的对称加密的密钥发送给服务端
4. 服务端使用私钥解密得到后续的对称加密密钥后，使用该对称加密密钥发送一个报文验证

#### HTTP缓存

#### 强缓存和协商缓存

http缓存分为强制缓存和协议缓存

1. 强制缓存：通过Expires、Cache-Control、Pragma控制，三者同时出现时：pragma > cache-control > expires。浏览器在发送请求之前会判断当前的时间是否在Cache-Control：max-age内.或者响应会返回200 Cache。Cache-Control有以下几个值：max-age（时间）、private（只有客户端缓存）、public（客户端和代理服务器都缓存）、immutable（缓存就算用户按下f5也不会重新请求，不写这个如果用户按下f5会向服务器发出请求）、no-cache（跳过强制缓存）、no-store（都不缓存，跳过强制缓存和协商缓存）
2. 协议缓存：当设置了no-cache的情况下，如果上一次的response中存在ETag或者Last-Modified字段，则表示开启协议缓存，浏览器在发送请求时会带上If-None-Match：ETag和If-Modified-Since：Last-Modified字段给服务器，服务器通过判断是否过期，如果没过期则返回304表示使用缓存。**Etag的生成规则：在nginx中，etag是last_modified与content_length拼接而成的。**
3. 协商缓存：为什么有了last_modified还要有一个etag？首先，last_modified只能精确到秒为单位，如果一秒内多次修改，则last_modifed值不会发生改变。其次，可能其他文件修改了导致该文件修改时间发生变化，但实际内容没有发生更改。这两个问题都可以使用etag解决。
4. 对于前端，可以在入口页面使用no-cache或max-age设置为较短时间，js.css本身设置max-age较长时间，引用js、css通过打包工具自动加上hash版本号的方式，这样浏览器只会请求修改的文件。

#### 缓存位置

有两种位置可以存放：内存和磁盘。内存缓存读取速度快但存活时间短容量小，磁盘缓存读取速度稍慢但储存时间长容量大。

对于比较大的js和css文件会被直接丢进磁盘，反之丢进内存

内存使用率较高的时候会优先进入磁盘



### TCP协议

#### 七层网络模型与四层网络模型

**OSI七层网络模型：**物理层、数据链路层、网络层(IP/ICMP)、传输层(TCP/UDP)、表示层、会话层、应用层(HTTP/HTTPS/FTP/SMTP)

**TCP/IP四层网络模型：**网络接口层、网际层、传输层、应用层

**五层体系结构**：物理层、数据链路层、网络层、传输层、应用层，实际上是OSI和TCP/IP的总和、

1. tcp协议是传输层的协议，也就是说是以太网协议和IP协议的上层协议，http的下层协议
2. tcp协议的作用：保证数据通信的完整性和可靠性，防止丢包



#### TCP为什么能防止丢包（快重传与快恢复）

接收端每一次收到包都会记录并发送ACK，如果收到的包不是对应的ACK，就不会变化，这样，接收方就会反复发送多个重复的ACk给发送方，当发送方收到连续三个重复的ACk后就会确认丢包，将丢失的数据包重新发送，接收端接收到正确的包后才会更新ACK。

#### TCP三次握手

+ 第一次握手：建立连接时，客户端发送syn包(syn = x)到服务器并进入SYN_SEND状态，等待服务器确认；SYN：同步序列编号
+ 第二次握手：服务器收到syn包，必须确认客户的syn并发送一个ACK(ack = x + 1),同时自己也发送一个syn包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态
+ 第三次握手：客户端收到SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器都进入ESTABLISHED(TCP连接成功)状态，完成三次握手



####TCP四次挥手（断开连接可以是客户端也可以是服务端）

+ 假设是客户端断开连接，发送FIN报文，表示Client端没有数据发送，请求断开连接
+ 服务器收到后，可能自己还有数据没有发送完毕，就先发送一个ACK表示收到请求，请等待我发送完毕，这时客户端进入FIN_WAIT状态，继续等待服务器的FIN报文。
+ 当服务器完成所有数据的发送后，向客户端发送FIN报文，告诉客户端我数据发送完毕，准备关闭连接，进入CLOSE_WAIT状态
+ 客户端收到FIN后，向服务器发送ACK报文，表示收到，然后进入TIME_WAIT等待状态。服务器收到客户端的ACK后就关闭连接。客户端等待2MSL后没有数据就自行关闭连接



#### 为什么连接时只需要三次握手而断开连接却需要四次挥手？

因为在建立连接时，服务器在接收到客户端的SYN包后可以将自己的SYN和ACK包一并发送给客户端。但是在关闭连接时，服务器可能还有数据尚未发送完毕，只能先发送ACK包确认收到客户端请求，等到自己的数据传输完成后才能发送FIN包给客户端。

#### 建立连接的过程可不可以只有两次握手？这样会发生什么

不行。如果只有两次握手，如果第二次握手时服务器的某一个包(SYN/ACK)包丢失，客户端将无法得知服务器是否准备好了，将会一直等待服务器的确认；而服务器却认为自己准备就绪开始想客户端发送数据，客户端会因为一直等待服务器确认而忽略服务器发送的数据，服务器就会一直发送重复的数据，这样就会造成资源浪费。

#### 为什么关闭连接时TIME_WAIT需要经过2MSL才真正关闭

网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

#### TCP可靠传输的机制有哪些

1. 三次握手建立连接
2. 停止等待协议：每发送完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组，若接收方收到重复分组，就丢弃该分组，但同时还需要发送确认
3. 连续ARQ协议：**通常要结合滑动窗口协议**。发送方会有一个窗口，窗口的大小假设为5，窗口内的分组是未确认的分组，当发送方收到一个分组的确认后会向后移动一个分组，后面的分组会进入窗口，前面的分组会自动被释放。如果长时间没有收到确认，就会回退到上一次收到确认的地方重新开始发送
4. 流量控制：**流量控制也需要结合滑动窗口协议**。当接收方跟不上发送方的速度时就会强制让发送方慢下来，基于窗口的流量控制，窗口的大小会随着时间变动，从而实现流量控制
5. 拥塞控制：发送速率超过路由器的能力而导致丢包，就需要通过拥塞控制。拥塞控制采用了四种算法：慢开始、快重传、快恢复：
   + 慢开始、拥塞避免：发送方会从小到大逐渐增大发送窗口，一开始会以指数级增长。当大于**慢启动门限**后，会采用拥塞避免，窗口大小会线性增加。
   + 快重传与快恢复：当接收方接收到一个不按顺序的数据，就会给发送方发送一个重复确认，如果收到三个重复确认，就会认为数据丢失，并重传丢失的数据，**并设置慢启动门限为此时窗口大小的一半，窗口大小缩小为慢启动门限值，重新进入拥塞避免阶段**



#### TCP半连接和全连接以及Flood攻击

+ 半连接：在服务器接收到客户端发送的SYN后自己发送SYN、ACK进入SYN_RECIV状态后，该连接就被推入了半连接队列
+ 全连接：在服务器收到客户端最后一次握手返回的ACK后就会把连接推入全连接队列
+ Flood攻击：伪造一系列假的IP疯狂发送SYN给服务器，服务器回复SYN和ACK造成半连接队列满无法处理正常请求，且由于假IP，服务器会不断重发数据，直到耗尽服务端的资源
+ Flood攻击的防范：扩大半连接队列容量；减少重发数据次数；利用SYN Cookie技术，收到第一个SYN后不立即进入队列，而是计算一个Cookie并发送给客户端，客户端回复ACK时带上Cookie，服务端验证通过后再正式分配连接资源



#### TCP报文头部

![img](https://user-gold-cdn.xitu.io/2020/2/23/170723f106ff0306?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 源端口、目标端口：用来唯一标识一个连接
2. 序列号：图中看出长度为4个字节。保证数据包按照正确的顺序组装
3. 确认号：告知对方下一个期望接收的序列号，小于该ACK的所有字节都已经全部收到
4. 标记位：常见的有SYN、FIN、ACK、RST、PSH。FIN表示准备断开连接、RST(reset)用来强制断开连接、PSH(push)：告知对方数据包收到后马上交给上层应用不能缓存
5. 窗口大小：占用两个字节。但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。
6. 校验和：占用两个字节，放置数据包损坏，如果校验和出现错误直接丢弃等待重传
7. 可选项：常用的有：TimeStamp（时间戳）、MSS（允许接收的最大报文段）、SACK（选择确认选项）、Window Scale（窗口缩放选项）

​    

### websocket

#### 与http区别（为什么用websocket而不用http）

最主要的区别就是websocket允许服务端主动发送消息，这样就可以方便的让两个客户端之间借助服务端进行实时的通信。而且websocket没有同源限制。与http一样都是基于TCP协议的，开头是ws://或者wss://，也需要握手来建立连接，握手的过程数据是通过http传输的，建立之后就不需要http了。

#### http如何实现websocket的伪消息推送或者长连接

从http1.1开始所有的链接默认采用的是长连接，会复用之前 建立的TCP连接。

要实现伪服务端推送消息有以下这种方式：

+ 轮询：客户端定时向服务端发送请求，看看服务端有没有新的消息返回(聊天室)



### get和post的区别

1. 最直观的区别，get参数包含在url中，post一般在body中

2. 通常来说会认为post比get更安全。由于get参数往往放在url中直接传递，post参数通常放在body中传递，表面上看起来post更安全，但实际上http协议下都是明文传输，都是不安全的

3. 通常来说会认为post发送的数据会比get多。get参数一般写在url中进行传递。而浏览器对url有长度限制所以才导致了get发送的数据有长度限制。

4. get为一次请求，post会有两次请求。get会在tcp第三次握手时将发送get请求头和数据；而post会在第三次握手时先发送post请求头，再发送数据分两次发送

5. get会被主动缓存，post不设置不会缓存
6. get通常用来进行查询等不产生危害的操作，post通常用来进行修改数据等会产生危害的操作



### 性能优化

#### 性能优化的方法

+ 减少HTTP请求
+ + 将文件适当的合并，但也不能过渡合并使得某一个文件过大。静态文件可以使用CDN

+ + 适当使用缓存(localStorage)/内存(Vuex.state)，将请求的数据进行保存，需要时可以从缓存/内存中取。
  + 频繁触发时使用节流和防抖
  + 使用websocket，配置Gzip压缩
  + 图片使用雪碧图或者svg
  + 如果有audio或者video设置他们的preload，播放时在进行加载
+ 浏览器渲染方面
+ + 当样式很多时，设置className而不是直接操作Style
+ + 避免空的src和href，CSS放到顶部，js放到底部同时避免使用CSS表达式，尽量少使用@import
+ + 对敏感属性offset族的处理，可以先获取，计算完毕后赋值
+ + 对于大图片或者多图片使用懒加载，或者使用雪碧图或者svg
+ +   使用defer，async属性的脚本，异步加载的方式，会先发请求，然后JS引擎会继续解析下面的内容。async脚本在加载完成后立即执行，defer会等待html解析完成后执行
  + js避免使用eval
+ + 使用requestAnimationFrame
+ + 尽量使用三维transform，会开启硬件加速 。使用will-change采用合成线程处理动画提高渲染效率
+ + SSR渲染、类似个人中心这种页面进行预渲染 

#### CDN

基于内容的分布式分发网络（Content Delivery Network）

简单的说CDN就是让原本上海的浏览器要访问北京主站内容的请求转而由部署在上海或南京的缓存来受理，这样请求的数据只需经过一跳或有限的几跳就能到达请求端，有效利用带宽并且降低主站压力，对于电子商务网站和搜索引擎网站以及门户网站，CDN的合理应用显得尤为重要。

CDN 的核心点有两个，一个是**缓存**，一个是**回源**。

这两个概念都非常好理解。对标到上面描述的过程，“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。



#### 图片格式

+ 前置知识：2进制位数与色彩的关系：在计算机中，像素用二进制数来表示，不同图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，可以表示的颜色种类越多，体积也会越大。例如二进制位数为n，可以呈现2^n种颜色

+ jpg、jpeg：最大的特点就是有损压缩。通常最为大的背景图、轮播图或者banner出现。缺陷是处理矢量图形和logo等线条感强颜色对比明显的图像时会出现明显的模糊，且不支持透明度处理
+ png：无损压缩，质量高，体积略大，支持透明度。通常用在页面logo、颜色简单但是对比度明显的图片和背景
+ svg：文本文件、体积小、不失真、兼容性好，矢量图，基于XML语法的图像格式。既可以写在html中作为dom节点，也可以作为图片src。局限是渲染成本比较高
+ base64：是一种编码方式，可以直接作为编码展示而不发送http请求，当然编码后体积会膨胀，所以适用于那些体积小的图片，这样就不用发送http请求。在webpack中的url-loader就能将适宜的图片转换为base64编码
+ webp：既支持透明还可以展示动图而且图像尺寸小。局限性就是兼容性不好，safari不支持，可以采用以下方式解决：在支持webp时优先使用webp，不支持使用jpg。或者将工作交给后端，根据http请求的accept字段是否包含image/webp来决定返回的图片地址。



## 操作系统部分

### 进程之间通信的方式（IPC）

+ 管道pipe：半双工，数据只能单向流动，只能用于有亲缘关系的进程之间（比如父子进程和兄弟进程）
+ 命名管道FIFO：也是半双工，但允许无亲缘关系的进程之间通信
+ 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
+ 共享内存SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
+ 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
+ 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同进程及其间进程的通信。
+ 信号Sinal：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。



### 进程和线程的区别

+ 进程是操作系统分配资源的基本单位，线程是处理器进行任务调度和执行的基本单位
+ 每个进程拥有自己独立的代码和数据空间；而同一个进程中的线程共享这些代码和数据空间，每个线程有自己独立的程序计数器和运行栈。所以进程之间的切换会有较大的开销，线程之间的切换开销较小
+ 一个进程内可以包含多条 线程
+ 一个进程崩溃后不会对其他进程产生影响，但一个进程中的某个线程崩溃会导致整个进程死从而影响到其他线程。所以多进程比多线程健壮。这也是现代浏览器采用多进程架构的原因之一
+ 线程不能独立执行，必须依存于进程中





## git部分

### git合并分支之merge

**下面讨论的条件为：master和bugfix两个分支，要将bugfix合并到master**

1. 如果bugfix分支创建出来后master分支没有经过任何更改。merge名利就会把master分支的位置移动到bugfix上，称为fast-forward合并![image-20210601175748404](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601175748404.png)

2. 如果bugfix分支创建出来后master分支经过了更改和提交。合并两个分支会生成一个提交，这时master分支的HEAD会移动到该提交上。![image-20210601175846035](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601175846035.png)

   ![image-20210601175854221](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601175854221.png)

   

### git合并分支之rebase

同样是master和bugfix两个分支，需要合并。此时master分支在bugfix分支创建出来后经过了修改，如下图所示：

<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601180207802.png" alt="image-20210601180207802" style="zoom:67%;" />

rebase命令执行后，会将bugfix 的两个提交添加到master分支的末尾，形成一条线（需要解决产生冲突的部分），之后将master 的HEAD移动到bugfix 的HEAD处。![image-20210601180334413](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601180334413.png)

### git pull

git pull = git fetch + git merge FETCH_HEAD

git pull --rebase = git fetch + git rebase FETCH_HEAD



## 交互设计

### 交互设计十大原则

+ 系统可见性原则。保持界面的状态可见、变化可见、内容可见。例如加载过程动画、操作反馈等
+ 贴近场景原则。功能操作符合用户的使用场景。例如隐喻设计、模仿现实产品
+ 可控性原则。允许用户出错，设置撤销、返回、删除
+ 一致性原则。统一用于、功能、操作、颜色等，和用户行为保持一致
+ 防错原则，防止用户出错。例如对用户输入设置范围和类型，提供操作提示等
+ 协助记忆原则。减少用户记忆负荷，例如搜索智能提示、自动读取默认地址
+ 灵活高效。减少用户不必要的操作，例如常用入口前置、自定义复杂功能入口、订单的再次购买
+ 审美简约设计。不包含无关紧要的信息，良好的视觉层次结构。
+ 容错原则。错误信息可视化展示，帮助用户恢复，例如无网络连接时的提示、撤回消息重新编辑按钮
+ 人性化帮助。引导用户完成操作，例如搜索智能提示、分步骤提示



## 算法部分

### 获取白屏/首屏加载时间

1. 白屏时间指的是从输入url到页面开始有内容出现的时间，将以下代码写在\</head>之前即可：

   ```html
   <script>
   	new Date() - performance.timing.navigationStart
   </script>
   ```

2. 首屏时间指的是从输入url到页面完全渲染完成的时间，将上面的代码写在window.onload事件中即可



### ES5实现一个能够生成迭代器对象的迭代器生成函数

```js
// 定义生成器函数，入参是任意集合
function iteratorGenerator(list) {
    // idx记录当前访问的索引
    var idx = 0
    // len记录传入集合的长度
    var len = list.length
    return {
        // 自定义next方法
        next: function() {
            // 如果索引还没有超出集合长度，done为false
            var done = idx >= len
            // 如果done为false，则可以继续取值
            var value = !done ? list[idx++] : undefined
            
            // 将当前值与遍历是否完毕（done）返回
            return {
                done: done,
                value: value
            }
        }
    }
}

var iterator = iteratorGenerator(['1号选手', '2号选手', '3号选手'])
iterator.next()
iterator.next()
iterator.next()
```

### 约瑟夫环

```js
function countOff(num,m){
  let res = []
  for(let i = 1;i <= num;i ++){
    res.push(i)
  }
  let flag = 0
  while(res.length > 1){
    let len = res.length,temp = 0
    for(let i = 0;i < len;i ++){
      flag ++
      if(flag == m){
        res.splice(i-temp,1)
        temp ++
        flag = 0
      }
    }
  }
  return res[0]
}
```



### 数组去重

1. 使用set的特性：不能重复

```js
function unique(arr){
	return [...new Set(arr)]
}
```

2. 与第一种类似，采用对象的属性不能重复的特性：这种方式存在问题，例如两个不一样的对象就会被去掉一个

```javascript
function unique(arr){
	let temp = {}
	let res = []
	for(let i of arr){
		if(!temp[i]){
			res.push(i)
			temp[i] = 1;
		}
	}
	return res
}
```

3. 利用map

```js
function unique(arr){
  let map = new Map()
  let res = []
  for(let i = 0;i < arr.length;i ++){
    if(map.has(arr[i])){
      map.set(arr[i],true)
    }else{
      map.set(arr[i],false)
      res.push(arr[i])
    }
  }
  return res
}
```

4. 双层循环然后splice去重,这种方式要注意NaN的问题

```js
function unique(arr){
  let flag = false
  for(let i = 0;i < arr.length;i ++){
    flag = false
    if(typeof arr[i] === "number" && isNaN(arr[i])){
      flag = true
    }
    for(let j = i + 1;j < arr.length;j ++){
      if(arr[i] === arr[j] || (flag && typeof arr[j] === "number" && isNaN(arr[j]))){
        arr.splice(j,1)
        j --
      }
    }
  }
  return arr
}
```

### 数组的扁平化处理

**扁平化就是将数组变成一维的数组**

1. ES6的flat方法，flat方法可以直接将数组扁平化，接受一个参数是扁平化几级，一般使用最大值Infinity即可

```js
arr.flat(Infinity)
```

2. toString方法，缺点是数组内只能包含字符串或者数字

```javascript
arr.toString().split(',').map(item => parseFloat(item))
```

3. reduce方法

```js
function flat(arr){
  return arr.reduce((a,b) => a.concat(Array.isArray(b) ? flat(b) : b),[]) 
}
```

4. 利用正则表达式

```js
function flat(arr){
  let str = JSON.stringify(arr)
  str.replace(/(\[|\])/g,'')
  str = '[' + str + ']'
  return JSON.parse(str)
}
```

5. 实现指定层级的扁平化

```js
Array.prototype.myFlat = function(count){
  let arr = Array.prototype.slice.call(this)
  if(count == 0) return arr
  return arr.reduce((res,value) => {
    return res.concat(Array.isArray(value)?value.myFlat(count-1):value)
  },[])
}
```



### 将数组随机打乱顺序，生成一个新的数组

思路：生成随机数，得到的随机数下标与最后一位交换，然后随机数范围-1

```js
function randomSort(arr){
  return arr.sort((a,b) => {
    return Math.random() < 0.5 ? 1:-1
  })
}
```



### 深拷贝

```js
function deepClone(origin,target){
  var target = target || new origin.constructor
  var toStr = Object.prototype.toString
  var arrStr = '[object Array]'
  for(let prop in origin){
    if(origin.hasOwnProperty(prop)){
      if(typeof origin[prop] === 'object'){
        if(origin[prop] instanceof RegExp){
          target[prop] = new RegExp(origin[prop])
        }else{
          target[prop] = (toStr.call(origin[prop])) === arrStr ? [] :{}
          deepClone(origin[prop],target[prop])
        }
      }else{
        target[prop] = origin[prop]
      }
    }
  }
  return target
}
```

```js
function deepClone(obj,hash = new Map()){
  if(obj instanceof RegExp) return new RegExp(obj)
  if(obj instanceof Date) return new Date(obj)
  if(obj === null || typeof obj !== 'object') return obj
  // 解决循环引用的情况
  if(hash.has(obj)){
    return has.get(obj)
  }
  let constr = new obj.constructor()
  hash.set(obj,constr)
  for(let prop in obj){
    if(obj.hasOwnProperty(prop)){
      constr[prop] = deepClone(obj[prop],hash)
    }
  }
  return constr
}
```



### 比较版本号

给你两个版本号 version1 和 version2 ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。

- 如果 `*version1* > *version2*` 返回 `1`，
- 如果 `*version1* < *version2*` 返回 `-1`，
- 除此之外返回 `0`。

```js
function compareVersion(version1,version2){
  const v1arr = version1.split('.')
  const v2arr = version2.split('.')
  let i = 0
  while(i < v1arr.length || i < v2arr.length){
    const v1 = v1arr[i] ? parseInt(v1arr[i]) : 0
    const v2 = v2arr[i] ? parseInt(v2arr[i]) : 0
    if(v1 > v2) return 1
    if(v1 < v2) return -1
    i ++
  }
  return 0
}
```

### 模板引擎

let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';
let data = {
 name: '姓名',
 age: 18
}
render(template, data); // 我是姓名，年龄18，性别undefined

```js
function render(template,data){
  const reg = /\{\{\w+\}\}/
  if(reg.test(template)){
    const name = reg.exec(template)[1]
    template = template.replace(reg,data[name])
    return render(template,data)
  }
  return template
}
```

### 驼峰命名转换

将"get-element-by-id"转换为"getElementById"

```js
function f(s){
  return s.replace(/-\w/g,(x) => {
    return x.slice(1).toUpperCase()
  })
}
```



### 转换为树形结构

```js
function toTree(data){
  let map = {}
  let res = []
  data.forEach(item => map[item.id] = item)
  data.forEach(item => {
    let parent = map[item.pid]
    if(parent){
      if(Array.isArray(parent.children)){
        parent.children.push(item)
      }else{
        parent.children = []
        parent.children.push(item)
      }
    }else{
      res.push(item)
    }
  })
  return res
}
```

### 实现lazyMan(流程控制)

```js
function lazyMan(name){
  this.task = []
  const fn = ()=>{
    return new Promise((resolve,reject) => {
      console.log('I am ${name}')
    	resolve()
    })
  }
  this.task.push(fn)
  setTimeout(this.next,0)
}

lazyMan.prototype = {
  eat(sth){
    const fn = () =>{
      return new Promise((resolve,reject) =>{
        console.log('I am eating ${sth}')
      	resolve()
      })
    }
    this.task.push(fn)
    return this
  }
  sleep(time){
    const fn = ()=>{
      return new Promise((resolve,reject) => {
        setTimeout(() => {
        	resolve()
      	},time*1000)
      })
    }
    this.task.push(fn)
    return this
  }
	sleepFirst(time){
    const fn = () => {
      return new Promise((resolve,reject) => {
        setTimeout(() => {
        	resolve()
      	},time*1000)
      })
    }
    this.task.unshift(fn)
    return this
  }
	next(){
    const fn = this.task.shift()
    if(fn && typeof fn == 'function'){
      fn().then(() => {
        this.next()
      })
    }
  }
}

function LazyMan(name){
  return new lazyMan(name)
}

```

### 实现最多同时运行n个任务的流程控制

例如：const sche = new Sche(2)// 最多同时运行两个任务
sche.addTask('3',3) // 添加三秒后输出'3'的任务
sche.addTask('1',1) // 添加一秒后输出'1'的任务
sche.addTask('2',2) // 添加二秒后输出2的任务
sche.start()
// 最后会先输出1，然后3和2同时输出.

```js
class Sche{
  constructor(num) {
    this.count = num;
    this.tasks = []
    this.working = []
  }

  addTask(str,timeout){
    const fn = () => {
      return new Promise(resolve => {
        setTimeout(() => {
          console.log(str)
          resolve()
        },timeout * 1000)
      })
    }
    this.tasks.push(fn);
  }

  start(){
    if (this.tasks.length < this.count) {
      this.tasks.forEach(task => task())
    }else {
      for(let i = 0;i < this.count;i ++) {
        this.next()
      }
    }
  }

  next(){
    const task = this.tasks.shift()
    if (task && typeof task === 'function') {
      task().then(() => this.next())
    }
  }
}
```

### promise处理请求超时

请求也是一个promise，要实现超时后忽略过来的请求

```js
function timeoutPromise(request,time){
  const timeout = new Promise((resolve,reject) => {
    setTimeout(() => {
      resolve('timeout!')
    },time)
  })
  return Promise.race([request,timeout])
}
```

### promise实现请求失败重试(限定重试次数)

```js
function retry(request,retryTime){
  let count = 0
  return new Promise((resolve,reject) => {
    function run(){
      request
      	.then((data) => {
      		resolve(data)
    		})
    		.catch((e) => {
      		if(count >= retryTime) reject(e)
        	count ++
        	run()
    		})
    }
    run()
  })
}
```

### 实现红绿灯

要求实现红绿灯效果，红灯持续3s，绿灯持续2s，黄灯持续1s。然后一直循环下去

```html
<style>
    .container {
      display: flex;
    }
    .red {
      width: 150px;
      height: 150px;
      background-color: white;
      border-radius: 50%;
      margin: 50px;
    }
    .green {
      width: 150px;
      height: 150px;
      background-color: white;
      border-radius: 50%;
      margin: 50px;
    }

    .yellow {
      width: 150px;
      height: 150px;
      background-color: white;
      border-radius: 50%;
      margin: 50px;
    }
</style>
<div class="container">
    <div class="red"></div>
    <div class="green"></div>
    <div class="yellow"></div>
</div>
<script>
 const red = document.getElementsByClassName('red')[0]
    const green = document.getElementsByClassName('green')[0]
    const yellow = document.getElementsByClassName('yellow')[0]

    function changeColor(color, duration) {
      return new Promise(resolve => {
        _changeColor(color)
        setTimeout(resolve, duration * 1000)
      })
    }

    function _changeColor(color) {
      switch (color) {
        case 'red':
          red.style.backgroundColor = 'red'
          green.style.backgroundColor = 'white'
          yellow.style.backgroundColor = 'white'
          break;
        case 'green':
          red.style.backgroundColor = 'white'
          green.style.backgroundColor = 'green'
          yellow.style.backgroundColor = 'white'
          break;
        case 'yellow':
          red.style.backgroundColor = 'white'
          green.style.backgroundColor = 'white'
          yellow.style.backgroundColor = 'yellow'
          break;
      }
    }

    async function start() {
      await changeColor('red', 3)
      await changeColor('green', 2)
      await changeColor('yellow', 1)
      start()
    }
    start()
</script>
```



### 实现compose函数

接收若干个函数作为参数，每个函数执行后的输出作为下一个函数的输入。例如compose(f,g,m,n)(x) === f(g(m(n(x))))

```js
function compose(...fns){
  return function(x){
    return fns.reverse().reduce((pre,cur) => {
    	return cur(pre)
  	},x)
  }
}
```

### 用random7生成random10

思路：首先使用random7生成1~5，然后根据百分之50的概率决定是否+5

```js
function random10(){
  let res = random7()
  while(res > 5) res = random7()
  let temp = random7()
  while(temp == 7) temp = random7()
  return temp >3 ? res + 5 :res
}
```



### 数组的排序

1. 冒泡排序(稳定排序)

```js
function babbleSort(arr){
  let temp;
  for(let i = 0;i < arr.length - 1;i ++){
    for(let j = 0;j < arr.length - 1 -i;j ++){
      if(arr[j] > arr[j+1]){
        temp = arr[j]
        arr[j] = arr[j+1]
        arr[j+1] = temp
      }
    }
  }
  return arr
}
```

2. 插入排序（稳定排序）

```js
function insertSort(arr){
  let insertIndex;
  let insertVal;
  for(let i = 1;i < arr.length;i ++){
    insertIndex = i - 1;
    insertVal = arr[i]
    while(insertIndex >= 0 && insertVal < arr[insertIndex]){
      arr[insertIndex + 1] = arr[insertIndex]
      insertIndex --
    }
    arr[insertIndex + 1] = insertVal
  }
  return arr
}
```

3. 快速排序（不稳定排序）

```js
// 递归实现
function quick(arr, left = 0, right = arr.length - 1) {
	if (left >= right) return;
	var i = left, j = right, flag = i;
	while(i < j) {
		while(arr[j] >= arr[flag] && j > flag) j --;
		if (i >= j) break;
		while(arr[i] <= arr[flag] && i < j) i ++;
		[num[flag],num[j],num[i]] = [num[j],num[i],num[flag]]
		flag = i
	}
	quick(arr, left, flag - 1);
	quick(arr, flag + 1, right);
}

// 非递归实现
function quick(arr, left = 0, right = arr.length - 1) {
	var list = [[left, right]]; // 模拟栈
	while(list.length > 0) {
		var now = list.pop()
		if (now[0] >= now[1]) continue;
		var i = now[0], j = now[1], flag = i;
		while(i < j) {
			while(arr[j] >= arr[flag] && j > flag) j --;
			if (i >= j) break;
			while(arr[i] <= arr[flag] && i < j) i ++;
			[num[flag],num[j],num[i]] = [num[j],num[i],num[flag]]
			flag = i	
		}
		list.push([now[0], flag - 1]);
		list.push([flag + 1, now[1]]);
	}
}
```

4. 选择排序（不稳定排序）

```js
function selectSort(arr){
  for(let i = 0;i < arr.length; i++){
    let minIndex = i
    let min = arr[i]
    for(let j = i + 1;j < arr.length;j ++){
      if(arr[j] < min){
        min = arr[j]
        minIndex = j
      }
    }
    arr[minIndex] = arr[i]
    arr[i] = min
  }
}
```



### 二分查找

时间复杂度为O(logN)

```js
function find(arr,target){
  let l = 0,r = arr.length - 1
  while(l <= r){
    const mid = Math.floor((l+r)/2)
    if(arr[mid] === target){
      return mid
    }else if(target > arr[mid]){
      l = mid + 1
    }else{
      r = mid - 1
    }
  }
  return false
}
```

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```js
function find(arr,target){
  let l = 0,r = arr.length - 1
  while(l <= r){
    const mid = Math.floor((l+r)/2)
    if(arr[mid] === target){
      return mid
    }else if(target > arr[mid]){
      l = mid + 1
    }else{
      r = mid - 1
    }
  }
  return r + 1
}
```

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

思路：找到左右边界。左边界就是数组中第一个大于等于target的，右边界就是数组中第一个大于target的-1

```js
// 找到左边界
function findLeftBorder(arr,target){
  let l = 0,r = arr.length - 1
  let res = arr.length 
  while(l <= r){
    const mid = Math.floor((l+r)/2)
    if(arr[mid] >= target){
      res=  mid
      r = mid - 1
    }else{
      l = mid + 1
    }
  }
  return res
}

// 找到右边界
function findRightBorder(arr,target){
  let l = 0,r = arr.length - 1
  let res = arr.length 
  while(l <= r){
    const mid = Math.floor((l+r)/2)
    if(arr[mid] > target){
      res=  mid
      r = mid - 1
    }else{
      l = mid + 1
    }
  }
  return res
}

// 正式开始
function searchRange(arr,target){
  let leftIdx = findLeftBorder(arr,target)
  let rightIdx = findRightBorder(arr,target) - 1
  if(leftIdx <= rightIdx && rightIdx < arr.length && arr[leftIdx] == target && arr[rightIdx] == target){
    return [leftIdx,rightIdx]
  }
  return [-1,-1]
}
```



### 将arguments类数组转数组

1. 使用ES6方法Array.from

   ```js
   function sum(a, b) {
     let args = Array.from(arguments);
     console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
   }
   sum(1, 2);//3
   ```

   使用这种方法还可以将Set和Map转换为数组

2. 使用slice

   ```js
   function sum(a, b) {
     let args = Array.prototype.slice.call(arguments);
     console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
   }
   sum(1, 2);//3
   ```

   


### 判断数组中是否含有某一个值

1. indexOf

   ```js
   arr.indexOf(x)//返回-1代表不包含
   ```

2. includes

   ```js
   arr.includes(x)//返回false代表不包含
   ```

3. find

   ```js
   arr.find(item => item == 3) // 返回undefined表示不含
   ```

4. findIndex

   ```js
   arr.findIndex(item => item === 3)// 返回-1表示不含
   ```

   

### 防抖函数

一次请求在x秒内没有新的请求出现再发送，如果x秒内出现新的请求则继续等待x秒发送新的请求

```javascript
function debounce(func,timeout){
	let timer
  return function(){
    let context = this
    let args = arguments
    if(timer) clearTimeout(timer)
    timer = setTimeout(() =>{
      func.apply(context,args)
    },timeout)
  }
}
```

上面这种方式有一个缺陷，就是用户频繁触发就会长时间没有响应。这时候我们进行改进，设置在一定时间内必须要发送一次请求：

```js
function debounce(func,timeout){
  let timer
  let last
  return function(){
    let now = new Date()
    let context = this
    let args = arguments
    if(now-last < timeout || !last){
      if(timer) clearTimeout(timer)
      timer = setTimeout(() => {
        func.apply(context,args)
      },timeout)
    }else{
      // 超过设置的时间，必须要发送请求给予响应了
      last = now
      func.apply(context,args)
    }
  }
}
```



### 节流函数

x秒内只发送一次请求，也就是在发送一次请求后x秒内不会再发送新的请求

```js
function throttle(func,timeout){
  let timer;
  return function(){
    let context = this
    let args = arguments
    if(!timer){
      timer = setTimeout(() => {
        func.apply(context,args)
        timer = null
      },timeout)
    }
  }
}
```

### 实现图片懒加载

首先，给图片一个占位资源default.jpg，将真正的地址写在data-src中：

```html
<img src="default.jpg" data-src="http://www.xxx.com/target.jpg" />
```

1. 判断图片具体顶部的高度-滚动条滚动的距离是否小于视口高度。小于就说明出现在视野中，将图片的src设置为data-src

```js
let img = document.getElementsByTagName("img");
let num = img.length;
let count = 0;//计数器，从第一张图片开始计

lazyload();//首次加载别忘了显示图片

window.addEventListener('scroll', lazyload);

function lazyload() {
  let viewHeight = document.documentElement.clientHeight;//视口高度
  let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//滚动条卷去的高度
  for(let i = count; i <num; i++) {
    // 元素现在已经出现在视口中
    if(img[i].offsetTop < scrollHeight + viewHeight) {
      if(img[i].getAttribute("src") !== "default.jpg") continue;
      img[i].src = img[i].getAttribute("data-src");
      count ++;
    }
  }
}
```

2. 使用getBoundingClientRect API直接判断是否出现在当前视口中

```js
function lazyload() {
  for(let i = count; i <num; i++) {
    // 元素现在已经出现在视口中
    if(img[i].getBoundingClientRect().top < document.documentElement.clientHeight) {
      if(img[i].getAttribute("src") !== "default.jpg") continue;
      img[i].src = img[i].getAttribute("data-src");
      count ++;
    }
  }
}
```

3. 使用浏览器内置的API：IntersectionObserver，它实现了监听window的scroll事件、判断是否在视口中、以及节流三大功能

```js
let img = document.getElementsByTagName("img");

const observer = new IntersectionObserver(changes => {
  //changes 是被观察的元素集合
  for(let i = 0, len = changes.length; i < len; i++) {
    let change = changes[i];
    // 通过这个属性判断是否在视口中
    if(change.isIntersecting) {
      const imgElement = change.target;
      imgElement.src = imgElement.getAttribute("data-src");
      observer.unobserve(imgElement);
    }
  }
})
Array.from(img).forEach(item => observer.observe(item));
```



### 实现字符串的indexOf

```js
//  使用正则方式：
function myIndexOf1(target){
  return this.match(new RegExp(target)) ? this.match(new RegExp(target)).index : -1
}
String.prototype.myIndexOf1 = myIndexOf1;
// 不使用正则表达式：
function myIndexOf2(target){
  let hArr = this.split('')
  for(let i = 0;i < this.length - target.length + 1;i ++){
			if(hArr.slice(i,i + target.length).join('') === target){
        return i;
      }    
  }
  return -1;
}
String.prototype.myIndexOf2 = myIndexOf2;
```



### 1000瓶毒药老鼠问题

答案：10只老鼠

解析：典型的二进制问题。将1000瓶毒药按照二进制的方式进行编号，十位二进制就可编号完毕。给10只老鼠也分别编号1,2....10

让老鼠喝下对应编号为1的药水，比如2号老鼠喝下所有二号位为1的药水

最后得到死亡的老鼠编号，将对应的编号置为1，其余为0，再转为十进制即为毒药编号。比如1,5,8老鼠死亡，则毒药的二进制编号为：0010010001转换为十进制为145

### 用两个栈实现队列

设两个栈A、B，其中A负责队列的入队操作push，B负责出队操作pop

入队：将元素压入A栈中

出队：

+ 判断B栈是否为空
+ + 若B栈空，看A栈。A栈也空则抛出错误。A栈不空，将A栈元素取出 并压入B栈中，执行B栈的pop
  + 若B栈不空，直接执行B栈的pop即可

### 爬楼梯问题

有n级楼梯，两种爬法，1次1级或者1次2级求n级楼梯有多少种爬法

1. 递归法

n=1时只有一种爬法，n=2时有两种爬法，n=3时有1+2=3中爬法。所以n级楼梯有f(n-1)+f(n-2)种爬法

```js
function jump(n){
  if(n <= 0){
    return -1
  }else if(n <= 2){
    return n
  }else{
    return jump(n-1) + jump(n-2)
  }
}
```

这种方式内存占用大，可能会造成栈溢出

2. 迭代法

与递归法类似，只不过换成了迭代的形式

```js
function jump(n){
  if(n < 0)return -1
  if(n <= 2)return n
  let a = 1
  let b = 2
  let res = 0
  for(let i = 3;i <= n;i ++){
    res = a + b
    a = b
    b = res
  }
  return res
}
```



3. 动态规划

```js
function jump(n){
  if(n == 0)return -1
  if(n <= 2)return n
  let dp = []
  dp[1] = 1
  dp[2] = 2
  for(let i = 3;i <= n;i ++){
    dp[i] = dp[i-1] + dp[i-2]
  }
  return dp[n]
}
```



### 盛最多水的容器

<img src="https://www.geekxh.com/assets/img/1.5ce7b4a9.jpg" alt="PNG" style="zoom:50%;" />

短板，双指针。一个指向开头，一个指向结尾。若左边的长度小于右边的，则计算容量，左边++；反之右边--，最终找到最大的

```js
function findMax(arr){
  let res = 0
  let i = 0
  let j = arr.length - 1
  while(i < j){
    if(arr[i] < arr[j]){
      res = Math.max(res,(j-i)*arr[i])
      i ++
    }else{
      res = Math.max(res,(j-i)*arr[j])
      j --
    }
  }
  return res
}
```



### 求连续子数组的最大和

输入一个数组，子数组为这个数组中连续的数组成的数组，求所有子数组中的和的最大值

```js
function findMax(arr){
  let sum = arr[0]
  let res = 0
  for(let i = 1;i < arr.length;i ++){
    sum = Math.max(arr[i],sum+arr[i])
    res = Math.max(sum,res)
  }
  return res
}
```



### 顺时针输出螺旋矩阵

```js
function shunshizhen(arr){
  let res = []
  if(!arr.length) return res
  let t = 0
  let r = arr[0].length - 1
  let b = arr.length - 1
  let l = 0
  while(true){
      for(let i = l;i <= r;i ++){
          res.push(arr[t][i])
      }
      t ++
      if(t > b) return res
      for(let j = t;j <= b;j ++){
          res.push(arr[j][r])
      }
      r --
      if(r < l) return res
      for(let m = r;m >= l;m --){
          res.push(arr[b][m])
      }
      b --
      if(b < t) return res
      for(let n = b;n >= t;n --){
          res.push(arr[n][l])
      }
      l ++
      if(l > r) return res
  }
}
```



### 根据前序和后序构建二叉树

```js
class Node{
  constructor(value,left,right){
    this.value = value
    this.left = left
    this.right = right
  }
}

function tree(preorder,inorder){
  if(!preorder.length || !inorder.length) return null
    const root = new Node(preorder[0])
    const inorderIndex = inorder.indexOf(root)
    const leftLen = inorderIndex
    root.left = tree(preorder.slice(1,1+leftLen),inorder.slice(0,inorderIndex))
    root.right = tree(preorder.slice(1+leftLen),inorder.slice(1+leftLen))
    return root
}
```

### 非递归遍历二叉树

#### 非递归前序遍历

```js
function preOrder(root){
  let p = root
  let stack = []
  let res = []
  let top = -1
  while(p || top!=-1){
    if(p){
      stack[++top] = p
      res.push(p.val)
      p = p.left
    }else{
      p = stack[top --]
      p = p.right
    }
  }
  return res
}
```



#### 非递归中序遍历

```js
function inOrder(root){
  let stack = []
  let top = -1
  let res = []
  let p = root
  while(p || top!=-1){
    if(p){
      stack[++top] = p
      p = p.left
    }else{
      p = stack[--top]
      res.push(p.val)
      p = p.right
    }
  }
  return res
}
```



#### 非递归后序遍历

```js
function postOrder(root){
  let stack = []
  let res = []
  let top = -1
  let flag = []
  let p = root
  
  while(p || top!=-1){
    if(p){
      stack[++top] = p
      flag[top] = 1
      p = p.left
    }else{
      if(flag[top] === 1){
        p = stack[top]
        flag[top] = 2
        p = p.right
      }else{
        p = stack[top --]
        res.push(p.val)
        p = null
      }
    }
  }
}
```



### 实现一个事件总线Event Bus

事件总线是vue中常用的用来父子组件通信的方式，主要采用的设计模式是发布订阅模式

```js
class EventEmitter{
  constructor(events,max){
    this._events = events || new Map()
    this._max = max || 10
  }
  // 触发事件,type是事件名称，args是参数
  emit(type,...args){
    let handler = this._events.get(type)
    if(Array.isArray(handler)){
      // 有多个监听者，需要依次触发
      for(let i = 0;i < handler.length;i ++){
        handler[i].call(this,...args)
      }
    }else{
      // 只有一个监听者，直接触发
      handler.call(this,...args)
    }
  }
  
  // 监听事件,type是事件名称，fn是触发的函数
  on(type,fn){
    let handler = this._events.get(type)
    if(!handler){
      this._events.set(type,fn)
    }else if(handler && typeof handler === 'function'){
      this._events.set(type,[handler,fn])
    }else{
      handler.push(fn)
    }
  }
  
  // 移除监听,type是事件名称，fn是触发的函数
  off(type,fn){
    let handler = this._events.get(type)
    if(handler && typeof handler === 'function'){
      this._events.delete(type)
    }else{
      let position
      for(let i = 0;i < handler.length;i ++){
        if(handler[i] === fn){
          position = i
          break
        }else{
          position = -1
        }
      }
      if(position != -1){
        handler.splice(position,1)
        if(handler.length === 1){
          this._events.set(type,handler[0])
        }
      }else{
        return this
      }
    }
  }
  
  once(type,fn){
    const tFn = (...args) => {
      fn.apply(this,args)
      this.off(type,tFn)
    }
    this.on(type,tFn)
  }
}
```



### 实现大数加法

```js
// 传入的是两个字符串形式，返回的也是一个字符串形式
function add(a,b){
  let i = a.length - 1
  let j = b.length - 1
  let res = ''
  let carry = 0
  while(i >= 0|| j >= 0){
    let x = 0;
    let y = 0;
    let sum
    if(i >= 0){
      x = a[i] - '0'
      i --
    }
    if(j >= 0){
      y = a[j] - '0'
      j --
    }
    sum = x + y + carry
    if(sum >= 10){
      sum -= 10
      carry = 1
    }else{
      carry = 0
    }
    res = sum + res
  }
  if(carry){
    res = carry + res
  }
  return res
}
```



### 实现一个LRU

LRU就是least recently used

```js
function LRU(count){
  this.cache = new Map()
  this.count = count
}

LRU.prototype.get = function(key){
  if(this.cache.has(key)){
    let temp = this.cache.get(key)
    this.cache.delete(key)
    this.cache.set(key,temp)
    return temp
  }
  return -1
}

LRU.prototype.put = function(key,value){
  if(this.cache.has(key)){
    this.cache.delete(key)
  }else if(this.cache.size >= this.count){
    this.cache.delete(this.cache.keys().next().value)
  }
  this.cache.set(key,value)
}
```

### 一个0,1数组 A，最多将 K 个值从 0 变成 1 ， 返回仅包含 1 的最长子数组的长度

这题的主要思想是回溯

```js
let max = 0//用于储存最大长度
function main(arr,k){
  test(arr,0,k)
}
function test(arr,index,k){
  if(index === arr.length || k === 0){
    let len = 0
    for(let i = 0;i < arr.length;i ++){
      if(arr[i] === 1){
        len ++
        max = Math.max(len,max)
      }else{
        len = 0
      }
    }
  }
  for(let i = 0;i < arr.length;i ++){
    if(arr[i] === 0){
      arr[i] = 1
      test(arr,index+1,k-1)
      arr[i] = 0
    }
  }
}
```

### 五个山洞，兔子下一天只能去相邻的洞，求最多几天能找到

答案：六天。

1. 第一天去2号洞，如果没抓到，则说明在1,3,4,5号洞中。兔子下一天只能去2,3,4,5号洞
2. 第二天去3号洞，如果没抓到，则说明在2,4,5号洞中。兔子下一天只能去1,3,4,5号洞
3. 第三天去4号洞，如果没抓到，则说明在1,3,5号洞中。兔子下一天只能去2,4号洞
4. 第四天还去4号洞，如果没抓到，则说明在2号洞中。兔子下一天只能去1,3号洞
5. 第五天去3号洞，如果没抓到，这说明在1号洞中，下一天只能去2号洞
6. 最后第六天直接去2号洞守株待兔即可。

### 最大钻石问题

1 楼到 n 楼的每层电梯门口都随机放着一颗钻石，钻石大小不一。你乘坐电梯从 1 楼到 n 楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到「最大」的一颗？

注意关键词：**随机放置**，所以这一题属于最佳停止问题，需要使用到37法则

答案是：我们要选择先放弃前 37%（就是1/e）的钻石，此后选择比前 37% 都大的第一颗钻石。

### 25匹马问题

1. 有一个赛场上共有25匹马，赛场有5个跑道，不使用计时器进行比赛（也就是每次比赛只能得到本次的比赛的顺序），问最少比多少场才能选出最快的**三匹马**？

答案：7次

首先将25匹马分成5组，分别为：A1、...、A5、B1、...、B5、C1、...、C5、D1、...、D5、E1、...、E5。然后五组各比一次，得出每一组的第一名，假设为A1、B1、C1、D1、E1。

然后，再让这5匹马比一次，决出最终的第一名，假设最终名次为A1->B1->C1->D1->E1，则第一名已经确定为A1。那么，后面的第二三名有可能是A组的第二三名(假设为A2、A3)以及B组的B1、B2和C组的C1。最后让A2、A3、B1、B2、C1比一次得到第二三名。所以最终要比七次。

2. 有一个赛场上共有25匹马，赛场有5个跑道，不使用计时器进行比赛（也就是每次比赛只能得到本次的比赛的顺序），问最少比多少场才能选出最快的**五匹马**？

答案：最少八次。

①上面一问中的第二三名如果是A2、A3。则可能出现以下情况：第四名是A4，第五名可能是A5、B1；第四名是B1，第五名可能是B2或者C1。所以再让A4、A5、B1、B2、C1比一次即可出结果。最终的次数为八次

②上面一问中的第二三名如果是A2，B1。则可能出现以下情况：第四名是A3，第五名可能是A4、B2、C1；第四名是B2，第五名可能是A3、B3、C1；第四名是C1，第五名可能是A3、B2、C2、D1。这时就还需要两次比赛才能出结果，所以需要九次。

......

### 滑动窗口的最大值

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

用到的是单调队列,队列内的数是索引，索引对应的数组中的值从大到小排列。

```js
function maxSlidingWindow(nums,k){
	const res = []
  const queue = []
  for(let right = 0;right < nums.length;right ++){
    while(queue.length && nums[right] >= nums[queue[queue.length - 1]]){
      queue.pop()
    }
    queue.push(right)
    let left = right - k + 1
    if(queue[0] < left){
      queue.shift()
    }
    if(right + 1 > k){
      res[left] = nums[queue[0]]
    }
  }
  return res
}
```

### 股票的最大利润

把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

```tsx
function maxProfit(prices: number[]): number {
    // 前i-1日的最大利润或者第i日的价格减去前i日的最低价
    let min = prices[0]
    let profit = 0
    for(let i = 1;i < prices.length;i ++){
        min = Math.min(min,prices[i])
        profit = Math.max(profit,prices[i]-min)
    }
    return profit
};
```

进阶版：可以多次买卖，但买之前必须出售上一次的。

```js
function maxProfit(prices) {
  let res = 0
  for(let i = 1;i <prices.length;i ++){
    if(prices[i] > prices[i-1]){
      res = res + prices[i] - prices[i-1]
    }
  }
  return res
}
```



### 最长不含重复字符的子串

请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

```js
function lengthOfLongestSubstring(s){
  let res = 0
  let left = 0
  var set = new Set()
  for(let i = 0;i < s.length; i ++){
   while(set.has(s[i])){
     set.delete(s[left])
     left ++
   }
   set.add(s[i])
   res = Math.max(res,set.size)
  }
  return res
}
```

### 等差子数列个数

如果一个数列 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该数列为等差数列。给你一个整数数组 `nums` ，返回数组 `nums` 中所有为等差数组的 **子数组** 个数。

```js
function number(nums){
  const len = nums.length
  if(len <= 2) return 0
  let d = nums[0] - nums[1],count = 0
  let res  = 0
  for(let i = 2;i < len;i ++){
    if(nums[i-1]-nums[i] == d){
      count ++
    }else{
      count = 0
      d = nums[i-1]-nums[i]
    }
    res = res + count
  }
  return res
}
```



### 翻转单链表

```js
function reverse(head){
  let cur = head
  let pre = null
  while(cur){
    let next = cur.next
    cur.next = pre
    pre = cur
    cur = next
  }
  return pre
}
```

### K个一组进行翻转链表

```js
function reverse(head,tail){
  let cur = head
  let pre = null
  while(cur != tail){
    let next = cur.next
    cur.next = pre
    pre = cur
    cur = next
  }
  return pre
}

function reverseKGroup(head,k){
  if(!head) return null
  let start = head
  let end = head
  for(let i = 0;i < k;i ++){
    if(!end) return head
    end = end.next
  }
  const newHead = reverse(start,end)
  start.next = reverseKGroup(end,k)
  return newHead
}
```

### 重排链表

给定一个单链表 L 的头节点 head ，单链表 L 表示为：

 L0 → L1 → … → Ln-1 → Ln 
请将其重新排列后变为：

L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**思路是：先找到链表的中点，然后将链表分成两部分，将后半部分倒转，最后将两部分按顺序连接起来**

```js
function reorderList(head){
  if (head == null || head.next == null || head.next.next == null) {
        return;
    }
  let fast = head,slow = head
  while(fast.next && fast.next.next){
    fast = fast.next.next
    slow = slow.next
  }
  // 到这里，slow指向的就是前半部分的最后一个
  let newHead = slow.next // newHead就是后半部分的第一个
  newHead = reverseList(newHead)
  while(newHead){
    let temp = newHead.next
    newHead.next = head.next
    head.next = newHead
    head = newHead.next
    newHead = temp
  }
}

function reverseList(head){
  let cur = head,pre = null
  while(cur){
    let next = cur.next
    cur.next = pre
    pre = cur
    cur = next
  }
  return pre
}
```



### 堆排序

要记住，最后一个非叶子结点的序号为Math.floor(arr.length/2)-1;序号为i的节点的左子节点的序号为2\*i+1，右子节点的序号为2\*i+2

```js
function heapSort(arr){
  let len = arr.length
  buildHeap(arr,len)
  for(let i = arr.length - 1;i > 0;i --){
    let temp = arr[i]
    arr[i] = arr[0]
    arr[0] = temp
    len --
    buildHeap(arr,len)
  }
  return arr
}
      
function buildHeap(arr,len){
  for(let i = Math.floor(len/2)-1;i >= 0;i --){
    heapFy(arr,i,len)
  }
}

function heapFy(arr,i,len){
  let left = 2*i+1
  let right = 2*i+2
  let largest = i
  if(left < len && arr[left] > arr[largest]){
    largest = left
  }
  if(right < len && arr[right] > arr[largest]){
    largest = right
  }
  if(largest !== i){
    let temp = arr[i]
    arr[i] = arr[largest]
    arr[largest] = temp
  }
}
```

### 数组中第K大元素

**基于堆排序**

```js
function heapSort(arr,k){
  let len = arr.length
  buildHeap(arr,len)
  for(let i = arr.length - 1;i >= arr.length-k+1;i --){
    let temp = arr[i]
    arr[i] = arr[0]
    arr[0] = temp
    len --
    buildHeap(arr,len)
  }
  return arr[0]
}
      
function buildHeap(arr,len){
  for(let i = Math.floor(len/2)-1;i >= 0;i --){
    heapFy(arr,i,len)
  }
}

function heapFy(arr,i,len){
  let left = 2*i+1
  let right = 2*i+2
  let largest = i
  if(left < len && arr[left] > arr[largest]){
    largest = left
  }
  if(right < len && arr[right] > arr[largest]){
    largest = right
  }
  if(largest !== i){
    let temp = arr[i]
    arr[i] = arr[largest]
    arr[largest] = temp
  }
}
```

### 前K个高频元素

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**思路：先遍历数组塞入map中，然后根据map建立小顶堆，不断优化小顶堆**

```js
function topK(nums,k){
  const map = new Map()
  nums.forEach(n => {
    if(map.has(n)) map.set(n,map.get(n) + 1)
    else map.set(n,1)
  })
  
  if(map.size <= k) return [...map.keys()]
  
  let count = 0,heap = []
  for(let n of map.keys()){
    if(count < k){
      heap.push(n)
      if(count === k-1){
        buildHeapTree(heap,k,map)
      }
    }else{
      if(map.get(n) > map.get(heap[0])){
        heap[0] = n
        heapiFy(heap,k,0,map)
      }
    }
    count ++
  }
}

function buildHeapTree(heap,k,map){
  for(let i = Math.floor(k/2)-1;i >= 0;i --){
    heapiFy(heap,k,i)
  }
}

function heapiFy(heap,k,i,map){
  let minIndex = i
  while(true){
    if(2*i < k && map.get(heap[2*i]) < map.get(heap[minIndex])) minIndex = 2*i
    if(2*i+1<k && map.get(heap[2*i+1]) < map.get(heap[minIndex])) minIndex = 2*i+1
    if(minIndex !== i){
      [heap[i],heap[minIndex]] = [heap[minIndex],heap[i]]
      i = minIndex
    }else{
      break
    }
  }
}
```



### 区间合并

```js
function merge(arr){
  arr.sort((a,b) => a[0]-b[0])
  let res = []
  res.push(arr[0])
  for(let i = 1;i < arr.length;i ++){
    let cur = arr[i]
    let pre = res[res.length - 1]
    if(cur[0] <= pre[1]){
      pre[1] = Math.max(pre[1],cur[1])
    }else{
      res.push(cur)
    }
  }
  return res
}
```

### 判断链表是否有环

```js
function hasCycle(head){
  let slow = head
  let fast = head.next
  while(slow != fast){
    if(fast == null || fast.next == null) return false
    slow = slow.next
    fast = fast.next.next
  }
  return true
}
```

### 找到环的入口

```js
function findEntry(head){
  let slow = head,fast = head
  while(slow != fast){
    slow = slow.next
    fast = fast.next.next
  }
  let fast = head
  while(fast != slow){
    fast = fast.next
    slow = slow.next
  }
  return fast
}
```



### 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

```js
function threeSum(nums){
  let res = []
  const len = nums.length
  if(nums == null || len < 3)return res
  nums.sort((a,b) => a-b)
  for(let i = 0;i < len-2;i ++){
    if(nums[i] > 0)break
    if(i > 0 && nums[i] == nums[i-1]) continue
    let L = i + 1
    let R = len - 1
    while(L < R){
      const sum = nums[i] + nums[L] + nums[R]
      if(sum == 0){
        res.push(nums[i],nums[L],nums[R])
        while(L < R && nums[L] == nums[L+1]) L ++
        while(L < R && nums[R] == nums[R-1]) R--
        L ++
        R --
      }
      else if(sum < 0) L ++
      else if(sum > 0) R --
    }
  }
  return res
}
```

### 合并两个有序数组

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。

```js
function merge(nums1,m,nums2,n){
  let p1 = m -1 
  let p2 = n - 1
  let k = m + n - 1
  while(p1 >= 0 || p2 >= 0){
    if(p1 < 0){
      nums1[k--] = nums2[p2--]
    }else if(p2 < 0){
      nums1[k--] = nums1[p1--]
    }else if(nums1[p1] > nums2[p2]){
      nums1[k--] = nums1[p1--]
    }else{
      nums1[k--] = nums2[p2--]
    }
  }
  return nums1
}
```



### 二叉树的最近公共祖先

```js
function lowestCommonAncestor(root,p,q){
  if(root == p || root == q || root == null){
    return root
  }
  const left = lowestCommonAncestor(root.left,p,q)
  const right = lowestCommonAncestor(root.right,p,q)
  if(left && right){
    return root
  }else if(left && !right){
    return left
  }else if(!left && right){
    return right
  }else{
    return null
  }
}
```

### 二叉树的最大深度

```js
function maxDepth(root){
  if(!root) return 0
  const left = maxmaxDepth(root.left)
  const right = maxmaxDepth(root.right)
  return Math.max(left,right) + 1
}
```

### 二叉树的最小深度

```js
function minDepth(root){
  if(!root) return 0
  const left = minDepth(root.left)
  const right = minDepth(root.tighr)
  if(!root.left || !root.right){
    return left + right + 1
  }else{
    return Math.min(left,right) + 1
  }
}
```

### 二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img" style="zoom:50%;" />

**思路：直接进行层序遍历，输出每一层遍历到的最后一个节点**

```js
function rightSideView(root){
  let res = [],queue = []
  while(queue.length > 0){
    const len = queue.length
    for(let i = 0;i < len;i ++){
      let temp = queue.shift()
      if(temp.left) queue.push(temp.left)
      if(temp.right) queue.push(temp.right)
      if(i == len - 1) res.push(temp.val)
    }
  }
  return res
}
```

### 二叉树的路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

```js
function hasPathSUm(root,targetSum){
  if(!root) return false
  return dfs(root,targetSum - root.val)
}

function dfs(root,count){
  if(!root.left && !root.right && count == 0) return true
  if(!root.left && !root.right) return false
  if(root.left && dfs(root.left,count-root.left.val)) return true
  if(root.right && dfs(root.right,count-root.right.val)) return true
  return false
}
```

进阶版：求出所有的路径

```js
function pathSum(root,targetSUm){
  let res = []
  function dfs(root,count,path){
    if(!root.left && !root.right && count == 0){
      res.push([...path]) // 注意这里不能直接放，要拷贝一下
    }
    if(!root.left && !root.right) return
    if(root.left){
      path.push(root.left.val)
      dfs(root.left,count-root.left.val,path)
      path.pop() // 注意这里回溯操作
    }
    if(root.right){
      path.push(root.right.val)
      dfs(root.right,count-root.right.val,path)
      path.pop() // 注意这里回溯操作
    }
    return
  }
  if(!root) return res
  dfs(root,targetSum-root.val,[root.val])
  return res
}
```

### 二叉树根节点到叶子节点的数字之和

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

```js
function sumNumbers(root){
  if(!root) return 0
  const res = []
  dfs(root,[root.val])
  
  function dfs(node,path){
    if(!node.left && !node.right){
      const num = path.reduce((a,b) => a*10+b)
      res.push(num)
      return
    }
    if(node.left){
      path.push(node.left.val)
      dfs(node.left,path)
      path.pop()
    }
    if(node.right){
      path.push(node.right.val)
      dfs(node.right,path)
      path.pop()
    }
  }
  
  return res.reduce((a,b) => a+b)
}
```

### 判断是否是平衡二叉树

```js
function height(node){
  if(node == null) return 0
  return Math.max(height(node.left),height(node.right)) + 1
}

function isBalance(node){
  if(node == null) return ture
  if(isBalance(node.left) && isBalance(node.right) && Math.abs(height(node.left)-height(node.right) <= 1)){
    return true
  }else{
    return false
  }
}
```

### 判断是否是对称二叉树

```js
function isDuiChen(root){
  return helper(root,root)
}

function helper(p,q){
  if(!p && !q) return true
  if(!p || !q) return false
  return q.val == p.val && helper(p.left,q.right) && helper(p.right,q.left)
}
```

### 相交链表

```js
function is(headA,headB){
  if(headA == null || headB == null) return null
  let pA = headA,pB = headB
  while(pA != pB){
    pA = pA == null ? headB:pA.next
    pB = pB == null ? headA:pB.next
  }
  return pA
}
```

### 回文子串的个数

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

 例如“anc”输出结果是3；“aaa”输出结果是6

```js
function huiwen(s){
  let count = 0
  const len = s.length
  const dp = new Array(len).fill(0).map(() => new Array(len).fill(false))
  for(let j = 0;j < len;j ++){
    for(let i = 0;i <= j;i ++){
      if(i == j){
        dp[i][j] = true
        count ++
      }else if(j-i == 1 && s[i] == s[j]){
        dp[i][j] = true
        count ++
      }else if(j-i > 1 && s[i] == s[j] && dp[i+1][j-1]){
        dp[i][j] = true
        count ++
      }
    }
  }
  return count
}
```

### 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

```js
function maxHuiWenStr(s){
  if(s.length < 2)return s
  let len = s.length
  let res = ''
  for(let i = 0;i < len;i ++){// 从s[i]开始扩散
    getRes(i,i) // 长度是奇数
    getRes(i,i+1) // 长度是偶数
  }
  function getRes(m,n){
    while(m>=0 && n < len && s[m] == s[n]){
      m --
      n ++
    }
    if(n-m-1>res.length) res = s.slice(m+1,n)
  }
  return res
}
```

### 和为K的子数组

给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。

```js
function sum(nums,k){
  let res = 0
  let map = {0:1}
  let sum = 0
  for(let i = 0;i < nums.length;i ++){
    sum = sum + nums[i]
    if(map[sum-k]){
      res += map[sum-k]
    }
    if(map[sum]){
      map[sum] ++
    }else{
      map[sum] = 1
    }
  }
  return res
}
```



### 字符串的全排列

```js
function main(s){
  const set = new Set()
  let visited = new Array(s.length).fill(false)
  let arr = s.split('')
  dfs(arr,'',visited,set)
  return [...set]
}

function dfs(arr,str,visited,set){
  if(str.length === arr.length){
    set.add(str)
    return
  }
  for(let i = 0;i < arr.length;i ++){
    if(visited[i]) continue
    visited[i] = true
    dfs(arr,str+arr[i],visited,set)
    visited[i] = false
  }
}
```

### 括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**要注意的就是，如果要选(,条件是只要有(剩余。而要选),条件只能是剩余的)数量大于剩余的(数量**

```js
function generate(n){
  let res = []
  function dfs(left,right,str){
    if(str.length === 2*n){
      res.push(str)
    }
    if(left > 0) dfs(left-1,right,str+"(")
    if(right > left) dfs(left,right-1,str+")")
  }
  dfs(n,n,'')
  return res
}
```

### 有效三角形的个数

给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

```js
function nums(arr){
  let res = 0
  arr.sort((a,b) => a- b)
  for(let k = arr.length - 1;k >= 2;k --){
    let left = 0,right = k-1
    while(left < right){
      if(arr[left] + arr[right] > arr[k]){
        res += right - left
        right --
      }else{
        left ++
      }
    }
  }
  return res
}
```

### 最小路径和

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步

<img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img" style="zoom:50%;" />

```js
function minPathSum(arr){
  const row = arr.length
  const col = arr[0].length
  
  for(let j = 1;j < col;j ++){
    arr[0][j] = arr[0][j-1] + arr[0][j]
  }
  
  for(let i = 1;i < row;i ++){
    arr[i][0] = arr[i-1][0] + arr[i][0]
  }
  
  for(let i = 1;i < row;i ++){
    for(let j = 1;j < col;j ++){
      arr[i][j] = Math.min(arr[i-1][j],arr[i][j-1]) + arr[i][j]
    }
  }
  
  return arr[row-1][col-1]
}
```

### 旋转矩阵

```js
function reverseMatrix(matrix){
  for(let i = 0;i < matrix.length-1;i ++){
    for(let j = i + 1;j < matrix.length;j ++){
      [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]]
    }
  }
  // 最后别忘了还要对每一行翻转一下
  matrix.forEach(m => m.reverse())
}
```

### 最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

```js
function test(arr){
  const set = new Set(arr)
  let res = 0
  for(let i = 0;i < arr.length;i ++){
    if(!set.has(arr[i] - 1)){
      let cur = arr[i]
      let count = 1
      while(set.has(cur + 1)){
        cur ++
        count ++
      }
      res = Math.max(res,count)
    }
  }
}
```



### 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

方法一：纯dp动态规划，时间复杂度为O(n^2)。dp[i]表示前i个数字的最长子序列长度

```js
function lengthOfLIS(nums){
  const len = nums.length
  if(len === 0) return 0
  let dp = new Array(len).fill(1)
  for(let i = 0;i < len;i ++){
    for(let j = 0;j < i;j ++){
      if(nums[j] < nums[i]) dp[i] = Math.max(dp[i],dp[j]+1)
    }
    res = Math.max(res,dp[i])
  }
  return res
}
```

方法二：二分查找+动态规划。tail[i]存的是长度为i的最长子序列的最后一位的最小情况

```js
function lengthOfLIS(nums){
  const len = nums.length
  if(len <= 1) return len
  let tail = new Array(len)
  tail[0] = nums[0]
  let end = 0
  for(let i = 1;i < len;i ++){
    if(nums[i] > tail[end]){
      end ++
      tail[end] = nums[i]
    }else{
      let left = 0,right = end,res = end
      while(left <= right){
        let mid = Math.floor((left+right)/2)
        if(tail[mid] >= nums[i]){
          res = mid
          right = mid - 1
        }else{
          left = mid  + 1
        }
      }
      tail[res] = nums[i]
    }
  }
  return end + 1
}
```

### 接雨水

方法一：直接暴力按照列求，时间复杂度为O(n^2)

```js
function trap(height){
  let res = 0
  for(let i = 1;i < height.length - 1;i ++){
    let maxLeft = 0
    for(let j = i-1;j >= 0;j --){
      maxLeft = Math.max(maxLeft,height[j])
    }
    let maxRight = 0
    for(let j = i + 1;j < height.length;j ++){
      maxRight = Math.max(maxRight,height[j])
    }
    let min = Math.min(maxLeft,maxRight)
    if(min > height[i]){
      res += res + min - height[i]
    }
  }
}
```

方法二：对方法一进行优化，存两个动态规划数组

```js
function trap(height){
  let res = 0
  let maxLeft = new Array(height.length).fill(0)
  let maxRight = new Array(height.length).fill(0)
  for(let i = 1;i < height.length - 1;i ++){
    maxLeft[i] = Math.max(maxLeft[i-1],height[i-1])
  }
  for(let i = height.length - 2;i >= 1;i --){
    maxRight[i] = Math.max(maxRight[i+1],height[i+1])
  }
  for(let i = 1;i < height.length - 1;i ++){
    let min = Math.min(maxLeft[i],maxRight[i])
    if(min > height[i]) res = res + min - height[i]
  }
  return res
}
```

### 目标和

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

```js
function findTargetSumWays(nums,target){
  const len = nums.length
  const sum = nums.reduce((a,b) => a+b,0)
  if(Math.abs(target) > Math.abs(sum)) return 0
  const row = len
  const col = 2*sum + 1
  let dp = new Array(row).map(() => new Array(col).fill(0))
  dp[0][sum + nums[0]] += 1
  dp[0][sum - nums[0]] += 1
  for(let i = 1;i < row;i ++){
    for(let j = -sum;j <= sum;j ++){
      if(j+nums[i]+sum > col - 1){
        dp[i][j+sum] = dp[i-1][j-nums[i]+sum]
      }else if(j-nums[i]+sum < 0){
        dp[i][j+sum] = dp[i-1][j+nums[i]+sum]
      }else{
        dp[i][j+sum] = dp[i-1][j+nums[i]+sum] + dp[i-1][j-nums[i]+sum]
      }
    }
  }
  return dp[row-1][target+sum]
}
```

### 最长公共子串

从长度短的字符串截取，判断长的字符串中是否含有即可

```js
function findSubStr(str1,str2){
  const len1 = str1.length
  const len2 = str2.length
  if(len1 > len2){
    [str1,str2] = [str2,str1]
  }
  const len = len1
  for(let i = len;i > 0;i --){
    for(let j = 0;j < len-i;j ++){
      let temp = str1.slice(j,j+i)
      if(str2.includes(temp)) return temp
    }
  }
}
```



### 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

**思路：动态规划。二维数组，dp\[i]\[j]表示:第一个字符串的前i-1和第二个字符串的前j-1的公共子序列长度**

```js
function test(text1,text2){
  const len1 = text1.length
  const len2 = text2.length
  const dp = new Array(len1+1).fill(0).map(() => new Array(len2+1).fill(0))
  for(let i = 1;i <= len1;i ++){
    for(let j = 1;j <= len2;j ++){
      if(text1[i-1] == text2[j-1]){
        dp[i][j] = dp[i-1][j-1] + 1
      }else{
        dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
      }
    }
  }
  return dp[len1][len2]
}
```

### 二维数组查找目标值

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```js
function findTarget(arr,target){
  if(arr == null || arr.length == 0) return false
  const row = arr.length
  const col = arr[0].length
  let i = 0,j = col - 1
  while(i <= row - 1 && j >= 0){
    if(arr[i][j] == target){
      return true
    }else if(arr[i][j] < target){
      i ++
    }else{
      j --
    }
  }
  return false
}
```

### 零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

```js
function coinChange(coins,amount){
  const dp = new Array(amount+1).fill(Infinity)
  dp[0] = 0
  for(let i = 1;i <= amount;i ++){
    for(let j = 0;j < coins.length;j ++){
      if(i - coins[j] >= 0){
        dp[i] = Math.min(dp[i],dp[i-coins[j]]+1)
      }
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount]
}
```

### 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```js
function minSubArrayLen(arr,target){
  let left = 0,right = 0,sum = 0,len = arr.length
  let res = len + 1
  while(right < len){
    sum = sum + arr[right]
    right ++
    while(sum >= target){
      res = Math.min(res,right-left)
      sum = sum - arr[left]
      left ++
    }
  }
  return res > len ? 0 : res
}
```

### 数组缺失的第一个正整数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**思路：缺失的正整数的范围一定是\[1,N+1](N是数组长度)。用三次遍历实现。第一次遍历将非正数值都变为N+1。第二次遍历将所有小于等于N的数的下标改为-。第三次遍历找到第一个大于0的元素的下标**

```js
function first(arr){
  const len = arr.length
  for(let i = 0;i < len;i ++){
    if(arr[i] <= 0) arr[i] = len + 1
  }
  for(let i of arr){
    if(Math.abs(i) <= len){
      arr[Math.abs(i)-1] = -Math.abs(arr[Math.abs(i) - 1])
    }
  }
  for(let i = 0;i < len;i ++){
    if(arr[i] > 0) return i + 1
  }
  return len + 1
}
```

。
