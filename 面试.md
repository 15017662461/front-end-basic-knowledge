# 前端面试

## 大前端技术栈概览

### HTML5

1. 语义化标签
2. 音视频处理
3. canvas、webGL
4. history API（vue和react等路由的关键）
5. requestAnimationFrame（解决动画掉帧的问题）
6. 地理位置
7. web socket（长连接、轮询）
8. ......

### CSS3

1. 常规
2. 动画animation、transition
3. 盒子模型
4. 响应式布局
5. ......

### JS

1. ES3456789
2. dom
3. bom
4. 设计模式
5. 底层原理
   + 堆栈内存
   + 闭包作用域
   + 面向对象
   + this
   + 浏览器渲染原理
   + 回流、重绘

### 网络通信层

1. Ajax、Fetch、axios
2. http1.0/2.0
3. TCP
4. 跨域处理方案
5. 性能优化
6. ......

### Hybrid或者APP或者小程序

1. Hybrid
2. uni-app
3. react-native
4. flutter

### 工程化

1. webpack
2. git
3. linux、nginx



## HTML、css部分

### display：none和visibility：hidden的区别？

display会将该元素及其所有后代元素都隐藏，占据的空间消失，无法点击

visibility仍会占用空间，只是视觉上消失，仍然会影响页面的布局，给子元素设置visibility：visible会将子元素重新显示出来，这点与display不同。transition对于visibility的优化更好



### 盒子水平垂直居中的方案

1. css3的flex方案：在父元素上设置

   ```css
   display:flex;  
   justify-content:center; 
   align-items:center;
   ```

2. css3的transform方案(这个不要求盒子有固定的的宽和高)：在元素上设置：

   ```css
   position: absolute; 
   left:50%; 
   top:50%;
   transform:translate3d(-50%,-50%,0);
   ```

3. 已知盒子的大小（比如是200px*100px）：

   ```css
   position: absolute;
   left: 50%;
   right: 50%;
   margin-left:-100px;
   margin-top:-50px;
   ```

   或者有宽高，但我们不考虑的情况下,这个跟第二种transform差不多，但需要宽高：

   ```css
   position:absolute;
   left:0;
   top:0;
   right:0;
   bottom:0;
   margin:auto;
   ```

   

4. display:table-cell 的方式：在父元素设置：父元素还要有固定宽高

   ```css
   display:table-cell;
   text-align:center;
   vertical-align:center;
   width:500px;
   height:500px;
   ```

   还需要在子元素上：

   ```css
   display:inline-block
   ```



### 盒模型问题

1. 标准盒模型：box-sizing:content-box
2. IE盒模型（怪异盒模型）box-sizing:border-box   

 ==像 bootstrap等UI组件库中大多数都会设置盒模型为怪异盒模型，也就是设置box-sizing:border-box==

1. flex弹性伸缩盒模型：display:flex    



### css的几种经典布局

#### 圣杯布局

**圣杯布局就是三个元素被一个大标签包裹，中间自适应，两边有固定的宽度**

总体的思路就是：先将父元素设置一个padding为左右两边的宽度，然后设置左右两边的宽度并给center、left、right全都添加float：left。之后，对左边设置margin-left：-100%移动到center元素的最左边，然后设置position:relative; left:-200px；将左边的元素移到对应的位置。最后，给right设置margin-right:-200px将右边一过去

```css
// html部分
<div class="container clearfix">
	<div class="center"></div>
	<div class="left"></div>
	<div class="right"></div>
</div>
// css 部分
.container{
	height:100%;
  padding:0 200px; //200px就是左右两边的宽度
}
.left,
right{
  width:200px;
  min-height:200px;
  background:red;
}
.center{
  width:100%;
  min-height:400px;
  background:yellow;
}
.center,
.right,
.left{
  float:left;
}
.left{
  margin-left:-100%;// 这里就移到了center元素最左边，还需要往左边再移动200px
  positio:relative;
  left:-200px;
}
.right{
  margin-right:-200px;
}
```



#### 双飞翼布局

**双飞翼布局是中间被一个元素包裹，左右两边是单独的；两个元素**

```css
// html部分
<div class="clearfix">
	<div class="container">
		<div class="center"></div>
	</div>
	<div class="left"></div>
	<div class="right"></div>
</div>
// css部分
.container,
.left,
.right{
	float:left;
}
.container{
  width:100%;
}
.container .center{
  margin:0 200px;
  min-height:400px;
  background:red;
}
.left{
  width:200px;
  margin-left:-100%;
}
.right{
  width:200px;
  margin-left:-200px
}
```



## JS部分

### Symbol

**Symbol会生成唯一的一个值，并不会导致重复，可以解决对象中重复属性覆盖的问题**

**要创建一个Symbol不用new，因为Symbol是一种基本数据类型，直接let x = Symbol()即可**



### 对象的属性名只能是字符串吗？

**==错误！属性名还可以是Symbol类型！==**

**所有引用值作为对象的属性名，都会转换成字符串。所以，如果对象的属性名是一个另一个对象，则会默认将属性名转换为'[object Object]'，所以将多个对象作为属性名会导致被覆盖**



### alert输出

**alert输出的内容自动转换成字符串，对象会转换成[object Object]**



###经典闭包问题

```js
var a = 0,b = 0;
function A(a){
  A = function(b){
    alert(a+ b++);
  };
  alert(a++)
}
A(1);// 1
A(2);// 4

```

**为什么呢？**

**首先，在外层函数A内并没有声明A，所以内层的A函数会跑到外面去替代掉外层的A，然后，由于js函数的作用域看的是定义时候的作用域，所以第二次的a是1++也就是2，最终结果就是2+2 = 4**

```js
再来一题：
var x = 0,y = 1;
funtion fn(){
  x += 2;
  fn = function(y){
    console.log(y+(--x));
  };
  console.log(x,y)
}
fn(3);
fn(4);
console.log(x,y)
```

**答案：（2,1）、5、（1,1）**

```js
// 再做一题
var x = 2;
var y = {
    x:3,
    z:(function(x){
        this.x *= x;
        x += 2;
        return function(n){
            this.x *= n;
            x += 3;
            console.log(x)
        }
    })(x)
};
var m = y.z;
m(4);
y.z(5)
console.log(x,y.x)
```

**答案：7、10、（16,15）**

### async等执行顺序

**浏览器的执行顺序：先执行主线任务，主线任务遇到await会执行await后面的函数并等待其返回结果将await下面的所有语句塞入微任务中，然后跳到下一步继续执行主线任务，遇到setTImeout会塞入宏任务。主线任务执行完毕后，会先执行微任务最后执行宏任务**

==宏任务：事件绑定，定时器，ajax==

==微任务：async、await、promise==

```js
async function async1(){
  console.log("async1 start")
  await async2();
  console.log("async1 end")
}
async function async2(){
  console.log("async2")
}
console.log("script start")
setTimeout(() => {
  console.log("setTimeout")
},0)
async1()
new Promise(function (resolve){
  console.log("promise1")
  resolve()
}).then(function(){
  console.log("promise2")
})
console.log("script end");

最终的输出顺序为：
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```



### 跨域问题

#### 第一阶段JSONP

jsonp的原理：由于script标签请求的资源不受跨域的影响，我们就创建一个script标签，将src设置为接口的地址，然后在后面加上一个callback=func；在js代码中定义这个func：function func(data){这样data就是我们从接口请求来的数据：}

```js
js代码生成一个script：<script src="www.baidu/api/user/info?callback=func"><script>
在js代码中：function func(data){这里的data就是请求来的数据}
```

==局限：接口的请求方式只能是get请求，且需要后端将数据拼接成："func({这里是数据})"==

#### 第二阶段iframe

使用window.name/document.domin/location.hash/post.message......(15~16年)

#### cors跨域资源共享

只需要在后端设置cors即可

#### 基于http proxy实现跨域请求(开发阶段)+nginx反向代理(部署阶段)

只需要在webpack中进行配置即可，如果是vue项目，新建一个vue.config.js：

```js
module.exports = {
  devServer: {
    port: 9988, // 启动代理服务器的本地端口
    proxy: {
      '/api': { //请求路径关键字，这样后面就可以使用/api代替后面target写的一长串地址
        target: 'http://api.vikingship.xyz/api', //对应自己需要跨域的接口
        changeOrigin: true,//是否允许跨域,在本地会创建一个虚拟服务端，然后发送请求的数据，
        // 并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题
        ws: true,
        pathRewrite: {
          '^/api': ''      //这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替
          // 比如我要调用'http://meituan:8024/management/user/add'，直接写‘/api/user/add’即可
        }
      }
    }
  },
  // lintOnSave: false // 取消 eslint 验证
}
```

如果是react项目，类似配置"proxy":"需要跨域的接口，例如：http://meituan:5566/api"   后面发请求直接axios.get('后缀地址，例如：/user/userInfo')，这样就会向本地localhost:3000/user/userinfo发送请求，由于设置的proxy，就会将请求通过服务器代理自动代理到上面写的接口http://meituan:5566/api中，最终拼接出来的接口就是：http://meituan:5566/api/user/userInfo

==最后，部署到服务器上时，就需要使用到nginx 的反向代理==

### localStorage和cookie、sessionStorage

localStorage存储大小（5M）远大于cookie（4K），并且localStorage不容易被清理掉，cookie一旦用户清除浏览历史就会被清除。但主要区别还是存储的大小。sessionStorage会在页面被关闭时自动被清除



### session和cookie

**区别：session是存储在服务器端的，cookie是存储在客户端（浏览器端）的。session是基于cookie 的**

**联系：服务器设置session后，会在发送给客户端的响应头中带着set-cookie='connect.sid'    客户端会自动把信息种植到本地的cookie中并且是httponly的（只能读不能修改）  之后客户端再次向服务器发送请求时，会默认在请求头的cookie中把connect.sid传递给服务器**





## 框架部分

### 父子组件通信

#### Vue中父子组件通信

**vue中，父传子通过props进行传递，子传父通过emit，如果有多级传递，在Vue2中用\$on/$emit，在Vue3中需要引入第三方的mitt通过mitt的on和emit进行。同时，父组件还可以通过v-slot获取到子组件的数据：在子组件中\<slot name="test" :data="count">在父组件中：\<template v-slot:test="sonData" >这样就可以通过sonData.data获取到子组件的count**

**还可以通过本地存储的方式：vuex（刷新会重置）、localStorage**

####react中父子组件通信

**react中父传子也是通过props传递，子传父通过父组件将方法通过props传递给子组件，子组件调用该方法实现。多层通信可以通过手写发布订阅或者React.createContext**

