#  前端面试(CSIG不问算法？)

## 大前端技术栈概览

### HTML5

1. 语义化标签
2. 音视频处理
3. canvas、webGL
4. history API（vue和react等路由的关键）
5. requestAnimationFrame（解决动画掉帧的问题）
6. 地理位置
7. web socket（长连接、轮询）
8. ......

### CSS3

1. 常规
2. 动画animation、transition
3. 盒子模型
4. 响应式布局
5. ......

### JS

1. ES3456789
2. dom
3. bom
4. 设计模式
5. 底层原理
   + 堆栈内存
   + 闭包作用域
   + 面向对象
   + this
   + 浏览器渲染原理
   + 回流、重绘

### 网络通信层

1. Ajax、Fetch、axios
2. http1.0/2.0
3. TCP
4. 跨域处理方案
5. 性能优化
6. ......

### Hybrid或者APP或者小程序

1. Hybrid
2. uni-app
3. react-native
4. flutter

### 工程化

1. webpack
2. git
3. linux、nginx



## HTML、css部分

### 在浏览器输入网址到页面展示经历了什么

主要分为以下五个步骤：DNS域名解析、建立TCP连接、发送HTTP请求、关闭TCP连接、浏览器渲染。会先在本地查找是否有强缓存，如果有且没过期就直接显示

#### DNS域名解析

在客户端输入URL后，会有递归查找的过程。从浏览器缓存中查找->本地的hosts文件查找->找本地DNS解析器缓存查找->本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下：<img src="https://user-gold-cdn.xitu.io/2020/1/30/16ff45e132f02931?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="GitHub" style="zoom:67%;" />





#### 建立TCP连接

首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL / TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。

进行三次握手，建立TCP连接。

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

SSL握手过程

1. 第一阶段 建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数
2. 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号
3. 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息
4. 第四阶段 变更密码构件和结束握手协议



#### 发送HTTP请求

TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.



#### 关闭TCP连接

第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；

第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我"同意"你的关闭请求；

第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；

第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。



#### 浏览器渲染

按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图：

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff48eeecb52d79?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



1. 渲染进程将 HTML 内容转换为能够读懂DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。
6. 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

##### 构建 DOM 树

浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树,先将HTML的原始字节数据转换为文件指定编码的字符,然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45efe1080a3b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



具体步骤：

1. 转码（Bytes -> Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串
2. Tokens 化（Characters -> Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则
3. 构建 Nodes（Tokens -> Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope（例如：iframe 的 treeScope 与外层页面的 treeScope 不同）
4. 构建 DOM 树（Nodes -> DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系

##### 样式计算

渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

CSS 样式来源主要有 3 种，分别是`通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。`,其样式计算过程主要为：

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45e91f199812?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为CSSOM的构建过程。



##### 页面布局

布局过程，即排除 `script、meta` 等功能化、非视觉节点，排除 `display: none` 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45e923b3d786?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

其中，这个过程需要注意的是`回流和重绘`，关于回流和重绘，详细的可以看我另一篇文章[《浏览器相关原理(面试题)详细总结二》](https://juejin.im/post/6844903969693646862#heading-1)，这里就不说了～



##### 生成分层树

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），如图：

![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45e925391019?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。在浏览器中，你可以打开 Chrome 的"开发者工具"，选择"Layers"标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。



并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？详细的可以看我另一篇文章[《浏览器相关原理(面试题)详细总结二》](https://juejin.im/post/6844903969693646862#heading-4)，这里就不说了～

##### 栅格化

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图：



![GitHub](https://user-gold-cdn.xitu.io/2020/1/30/16ff45f311bb8934?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

##### 显示

最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。





### 回流和重绘

#### html加载的过程

1. 首先，浏览器将所有的html代码解析成一个dom树(dom tree),这个dom树中包含了所有的标签包括display:none的标签以及用js动态添加的元素等
2. 然后，浏览器解析css，生成cssom树
3. 浏览器将cssom树与dom 树结合后构建成render tree，这个render tree中不包含display：none等节点

#### 回流

当render tree中的某一部分由于某种原因(元素尺寸、布局、显示与隐藏等)需要重新构建，就会触发回流。每个页面都需要至少一次回流，就是在页面第一次加载的时候，这时候一定会发生回流，因为要构建render tree。在回流的时候，浏览器会将render tree中受到影响的部分失效并重新绘制。

#### 重绘

当render tree中一些元素更新属性，但这些属性只是影响元素的外观而不影响其他元素的布局的，（例如background-color），称为重绘

#### 区别

回流一定会引起重绘，重绘不一定会引起回流



### meta标签属性

meta标签有以下三大类属性：charset属性、name+content属性、http-equiv属性：

#### charset属性

用于定义文档的字符集

```html
<meta charset="utf-8">
```

#### name+content属性

```html
<!-- 网页作者 -->
<meta name="author" content="开源技术团队"/>
<!-- 网页地址 -->
<meta name="website" content="https://sanyuan0704.github.io/frontend_daily_question/"/>
<!-- 网页版权信息 -->
<meta name="copyright" content="2018-2019 demo.com"/>
<!-- 网页关键字, 用于SEO -->
<meta name="keywords" content="meta,html"/>
<!-- 网页描述 -->
<meta name="description" content="网页描述"/>
<!-- 搜索引擎索引方式，一般为all，不用深究 -->
<meta name="robots" content="all" />
<!-- 移动端常用视口设置 -->
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
<!-- 
  viewport参数详解：
  width：宽度（数值 / device-width）（默认为980 像素）
  height：高度（数值 / device-height）
  initial-scale：初始的缩放比例 （范围从>0 到10）
  minimum-scale：允许用户缩放到的最小比例
  maximum-scale：允许用户缩放到的最大比例
  user-scalable：用户是否可以手动缩 (no,yes)
 -->
```

#### http-equiv属性

```html
<!-- expires指定网页的过期时间。一旦网页过期，必须从服务器上下载。 -->
<meta http-equiv="expires" content="Fri, 12 Jan 2020 18:18:18 GMT"/>
<!-- 等待一定的时间刷新或跳转到其他url。下面1表示1秒 -->
<meta http-equiv="refresh" content="1; url=https://www.baidu.com"/>
<!-- 禁止浏览器从本地缓存中读取网页，即浏览器一旦离开网页在无法连接网络的情况下就无法访问到页面。 -->
<meta http-equiv="pragma" content="no-cache"/>
<!-- 也是设置cookie的一种方式，并且可以指定过期时间 -->
<meta http-equiv="set-cookie" content="name=value expires=Fri, 12 Jan 2001 18:18:18 GMT,path=/"/>
<!-- 使用浏览器版本 -->
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<!-- 针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色，content的值为default | black | black-translucent -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
```



### src和href的区别

src是source的简写，目的是将文件下载到html页面中去

href是Hypertext Reference的简写，表示超文本引用

src常见于img、script、iframe；href常见于a、link（css）

src用于替换当前内容，href用于建立联系

**浏览器在遇到href时会并行的下载资源且不会停止对当前文档的处理，这也就是建议使用link而不是import的原因。遇到src时会暂停其他资源的下载和处理并直到该资源加载或者执行完毕，这也就是将script标签放在最后的原因（有defer和sync的除外）**



### async和defer

这两个属性都会使得script的加载过程异步，也就是加载的过程不会阻塞html的解析。但加载完成后二者的执行顺序不一致

#### async

async 的脚本会在加载完成后立即执行，也就是说加载完成后会阻塞html 的解析

#### defer

defer的脚本在加载完成后不会立即执行，而是会在整个文档解析完毕后（DOMContentLoaded事件发生）再执行，不会阻塞html的解析。



### 浏览器兼容问题及解决方案

首先说一下兼容性问题产生的原因，主要是内核的不一致导致的。IE使用的是Trident，Chrome是Blink，Firefox是Gecko，Opera以前是Presto，现在也是Blink。

常见的兼容性问题有：

1. 不同内核浏览器下部分标签默认的margin和padding不同。解决方案：通配符\*{padding:0;margin:0}

2. IE双边距问题，在IE6？中同时设置float 和 margin会出现边距问题。解决方案：display：inline

3. 图片默认存在间距问题。解决方案：可以使用float布局

4. 边距重叠问题，就是当相邻的两个元素都设置了margin时，margin将取最大值。解决方案：给子元素增加一个父级元素，并设置父元素overflow：hidden

5. css书写样式的兼容性问题，解决方案：在前面加上前缀，内核名称

6. 获取视口宽高问题

   ```js
   // 大部分浏览器：
   var w = window.innerWidth;
   var h = window.innerHeight;
   // IE浏览器：
   var w = document.documentElement.clientWidth;
   var h = document.documentElement.clientHeight;
   //或者
   var w = document.body.clientWidth;
   var h = document.body.clientHeight;
   ```
   
7. 获取滚动条滚动距离

   ```js
   function getScrollOffset(){
   	if(window.pageXOffset){
       return {
         x:window.pageXOffset,
         y:window.pageYOffset
       }
     }else{
       return {
         x: document.body.scrollLeft + document.documentElement.scrollLeft,
         y: document.body.scrollTop + document.documentElement.scrollTop,
       }
     }
   }
   ```

8. 取消冒泡

   ```js
   function stopBubble(event){
     if(event.stopPropagation){
       event.stopPropagation()
     }else{
       event.cancelBubble = true
     }
   }
   ```

9. 阻止默认事件

   ```js
   function cancelHandler(e){
     if(e.preventDefault){
       e.preventDefault()
     }else{
       e.returnValue = false,
     }
   }
   ```

   

### display：none和visibility：hidden的区别？

display会将该元素及其所有后代元素都隐藏，占据的空间消失，无法点击，不会出现在render tree中

visibility仍会占用空间，只是视觉上消失，仍然会影响页面的布局，给子元素设置visibility：visible会将子元素重新显示出来，会出现在render tree中，这点与display不同。transition对于visibility的优化更好



### 盒子水平垂直居中的方案

1. css3的flex方案：在父元素上设置

   ```css
   display:flex;  
   justify-content:center; 
   align-items:center;
   ```

2. css3的transform方案(这个不要求盒子有固定的的宽和高)：在元素上设置：

   ```css
   position: absolute; 
   left:50%; 
   top:50%;
   transform:translate3d(-50%,-50%,0);
   ```

3. 已知盒子的大小（比如是200px*100px）：

   ```css
   position: absolute;
   left: 50%;
   right: 50%;
   margin-left:-100px;
   margin-top:-50px;
   ```

   或者有宽高，但我们不考虑的情况下,这个跟第二种transform差不多，但需要宽高：

   ```css
   position:absolute;
   left:0;
   top:0;
   right:0;
   bottom:0;
   margin:auto;
   ```

   

4. display:table-cell 的方式：在父元素设置：父元素还要有固定宽高

   ```css
   display:table-cell;
   text-align:center;
   vertical-align:center;
   width:500px;
   height:500px;
   ```

   还需要在子元素上：

   ```css
   display:inline-block
   ```



### rem和em

rem是相对于html根元素的大小，即html根元素字体是16px则10rem=160px

em是相对于父元素的大小

在移动端适配问题上，可以采用rem的方式来做。统一采用rem，再添加脚本根据浏览器的视口宽改变html根元素的字体大小达到移动端适配的目的

```js
// 下面写一个设置rem的方式，html根元素的字体大小为视口宽的十分之一
function setRem(){
  let winWidth = document.documentElement.offsetWidth
  document.documentElement.style.fontSize = winWidth/10
}
```



### 盒模型问题

1. 标准盒模型：box-sizing:content-box
2. IE盒模型（怪异盒模型）box-sizing:border-box   

 ==像 bootstrap等UI组件库中大多数都会设置盒模型为怪异盒模型，也就是设置box-sizing:border-box==

1. flex弹性伸缩盒模型：display:flex    



### 当相邻的两个元素都设置inline-block时的留白问题

当两个相邻元素都设置了inline-block时会出现一段空隙

原因是元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据CSS中white-space属性的处理方式（默认是normal，合并多余空白），原来`HTML代码中的回车换行被转成一个空白符`，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。

解决方式：

1. 将两个元素紧挨着写：

   ```html
   <div class="container">
     <div class="left">
         左
     </div><div class="right">
         右
     </div>
   </div>
   ```

2. 设置父元素的font-size=0，子元素设置为正常值

   ```css
   .container{
     width:800px;
     height:200px;
     font-size: 0;
   }
   ```

3. 给子元素设置float：left

   ```css
   .left{
     float: left;
     font-size: 14px;
     background: red;
     display: inline-block;
     width: 100px;
     height: 100px;
   }
   //right是同理
   ```



### css的几种经典布局 

#### 圣杯布局

**圣杯布局就是三个元素被一个大标签包裹，中间自适应，两边有固定的宽度**

总体的思路就是：先将父元素设置一个padding为左右两边的宽度，然后设置左右两边的宽度并给center、left、right全都添加float：left。之后，对左边设置margin-left：-100%移动到center元素的最左边，然后设置position:relative; left:-200px；将左边的元素移到对应的位置。最后，给right设置margin-right:-200px将右边一过去

```css
// html部分
<div class="container clearfix">
	<div class="center"></div>
	<div class="left"></div>
	<div class="right"></div>
</div>
// css 部分
.container{
	height:100%;
  padding:0 200px; /*200px就是左右两边的宽度*/
}
.left,
.right{
  width:200px;
  min-height:200px;
  background:red;
}
.center{
  width:100%;
  min-height:400px;
  background:yellow;
}
.center,
.right,
.left{
  float:left;
}
.left{
  margin-left:-100%;// 这里就移到了center元素最左边，还需要往左边再移动200px
  positio:relative;
  left:-200px;
}
.right{
  margin-right:-200px;
}
```



#### 双飞翼布局

**双飞翼布局是中间被一个元素包裹，左右两边是单独的；两个元素**

```css
// html部分
<div class="clearfix">
	<div class="container">
		<div class="center"></div>
	</div>
	<div class="left"></div>
	<div class="right"></div>
</div>
// css部分
.container,
.left,
.right{
	float:left;
}
.container{
  width:100%;
}
.container .center{
  margin:0 200px;
  min-height:400px;
  background:red;
}
.left{
  width:200px;
  margin-left:-100%;
}
.right{
  width:200px;
  margin-left:-200px
}
```



### requestAnimationFrame

这个API通常是用来代替setTimeout或者setInterval做动画的，会默认将内部的函数在1000/ 60 ms后执行一次

与SetTimeout和setInterval不同的是，requestAnimationFrame性能更高，且会将一帧内所有的dom操作都集中在一起完成，具体使用如下：

```js
function clg(){
	consoloe.log(1);
	requestAnimationFrame(clg)
}
requestAnimationFrame(clg)
// 这样就实现了每16.6ms输出一次1
```

同时还可以取消：let timer = requestAnimationFrame(xxx);  cancelAnimationFrame(timer);



## JS部分

### JS的执行过程

首先js是一门解释性语言，对于解释性语言来说，执行过程一般是这样的：解释器先通过词法分析和语法分析生成AST抽象语法树，然后生成字节码，最后解释器根据字节码来执行程序。

#### 生成AST

生成 AST 分为两步——词法分析和语法分析。

词法分析即分词，它的工作就是将一行行的代码分解成一个个token。 比如下面一行代码:

```js
let name = 'sanyuan'
```

其中会把句子分解成四个部分:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b7d3513ebf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

即解析成了四个token，这就是词法分析的作用。

接下来语法分析阶段，将生成的这些 token 数据，根据一定的语法规则转化为AST。举个例子:

```js
let name = 'sanyuan'
console.log(name)
```

最后生成的 AST 是这样的:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b7ff6b0f513?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码。顺便补充一句，babel 的工作原理就是将 ES6 的代码解析生成`ES6的AST`，然后将 ES6 的 AST 转换为 `ES5 的AST`,最后才将 ES5 的 AST 转化为具体的 ES5 代码。

回到 V8 本身，生成 AST 后，接下来会生成执行上下文。

#### 生成字节码

开头就已经提到过了，生成 AST 之后，直接通过 V8 的解释器(也叫Ignition)来生成字节码。但是`字节码`并不能让机器直接运行，那你可能就会说了，不能执行还转成字节码干嘛，直接把 AST 转换成机器码不就得了，让机器直接执行。确实，在 V8 的早期是这么做的，但后来因为机器码的体积太大，引发了严重的内存占用问题。

给一张对比图让大家直观地感受以下三者代码量的差异:

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b822da9857c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

很容易得出，字节码是比机器码轻量得多的代码。那 V8 为什么要使用字节码，字节码到底是个什么东西？

> 字节码是介于AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。

字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。

#### 执行代码

接下来，就进入到字节码解释执行的阶段啦！

在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做`热点代码`(HotSpot)，然后将这么代码编译成`机器码`保存起来，这个用来编译的工具就是V8的`编译器`(也叫做`TurboFan`) , 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为`热点代码`，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。

其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。而编译器和解释器的 根本区别在于前者会编译生成二进制文件但后者不会。

并且，这种字节码跟编译器和解释器结合的技术，我们称之为`即时编译`, 也就是我们经常听到的`JIT`。

这就是 V8 中执行一段JS代码的整个过程，梳理一下:

1. 首先通过词法分析和语法分析生成 `AST`
2. 将 AST 转换为字节码
3. 由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率



### EventLoop

1. 一开始整段脚本作为第一个**宏任务**执行

2. 执行过程中同步代码直接执行，**宏任务**进入宏任务队列，**微任务**进入微任务队列

3. 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空

4. 执行浏览器 UI 线程的渲染工作

5. 执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空



### ES6新增

+ 变量声明：let、const
+ 函数：箭头函数，函数默认值，对象方法简写
+ 数组方法：新增了map、reduce、find、findIndex、includes、解构赋值
+ API：promise、async、await
+ 数据结构：map、set、symbol
+ 对象：新增了keys/values/entries/assign、解构赋值
+ 字符串：新增了includes、startsWith、endsWith、模板字符串



### 隐式类型转换

+ {} == {} （false）两个对象比较，比较的是内存地址
+ undefined == null (true)   undefined === null(false)
+ NaN == NaN   (false)   NaN和谁都不相等，包括自己
+ [12] == "12"  (true)   数组(对象)和字符串比较，是将它们toString()后进行比较
+ 剩余所有情况都是转换为数字在进行比较的
+ + 对象转数字，是将它先toString转换为字符串然后在转换为数字
  + 字符串转数字，只要出现一个非数字字符，就是NaN
  + 布尔转数字：true->1   false ->0
  + null 转数字 0
  + undefined转数字 NaN

```js
[] == false   //0 == 0 true
[] == 1 //0 == 1 false
"1" == [1] // 1 == 1 true
```



### Symbol

**Symbol会生成唯一的一个值，并不会导致重复，可以解决对象中重复属性覆盖的问题**

**要创建一个Symbol不用new，因为Symbol是一种基本数据类型，直接let x = Symbol()即可**



### Map/Set/WeakMap/WeakSet

+ Set:成员是唯一的**不能重复**，可以遍历，常用方法有：add/has/delete/clear
+ WeakSet: 在Set的基础上还保证了成员都是对象，成员只是弱引用，可以被垃圾回收机制回收，常用来保存Dom节点(当dom节点被删除时Set中也被删除)，不能被遍历
+ Map：键值对的集合，可以被遍历，key值可以是任意数据类型，常用方法有：set/has/delete/get/clear
+ WeakMap: 在Map的基础上还保证了键名是对象，键名是弱引用可以被垃圾回收，不能被遍历



### 原型与原型链

#### 一、prototype

prototype是函数才有的属性，比如Object、Array和构造函数等，它们都有着prototype，它们的prototype.constructor就是自己本身：

```js
function Person(){}
Person == Person.prototype.constructor  //true
```

构造函数通过new 出来的实例对象的\__proto__就是构造函数的prototype，实例化对象的constructor就是其构造函数

```js
function Person(){}
const per = new Person()
per.__proto__ = Person.prototype
```

任何一个函数的prototype的\__proto__都是Object.prototype:

```js
function a(){}
a.prototype.__proto__ == Object.prototype  //true
```

![](https://upload-images.jianshu.io/upload_images/1490251-3089c135df71c956.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

### 实现继承的几种方式

#### 原型链继承

```js
// 父类
function Parent(){}
// 子类
function Child(){
  
}
Child.prototype = new Parent()
Child.prototype.constructor = Child
```

这种方式将父类的实例作为子类的原型，子类原型上继承了父类中的所有属性和方法，缺点是无法传参，且一个实例修改了原型链上的属性则其他实例的属性也会被修改

#### call继承（构造继承）

```js
// 父类
function Parent(){}
// 子类
function Child(){
  Parent.call(this)
}
```

这种方式把父类的私有属性和方法克隆一份给子类，子类不会继承到父类原型prototype上的属性和方法

#### 组合继承

```js
// 父类
function Parent(){}
// 子类
function Child(){
  	Father.call(this)
}
Child.prototype = new Parent()
Child.prototype.constructor = Child
```

结合了上面两种方式的优点，但调用了两次父类构造函数，消耗内存

#### 优化组合继承

```js
// 父类
function Parent(){}
// 子类
function Child(){
  	Father.call(this)
}
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Son
```

解决了组合继承中调用两次构造函数的缺陷

#### ES6 Class继承

```js
class Parent{
  constructor(){}
}
class Child extends Parent{
  constructor(){}
}
```





### 对象的属性名只能是字符串吗？

**==错误！属性名还可以是Symbol类型！==**

**所有引用值作为对象的属性名，都会转换成字符串。所以，如果对象的属性名是一个另一个对象，则会默认将属性名转换为'[object Object]'，所以将多个对象作为属性名会导致被覆盖**



### forEach相关问题

forEach中使用return不能中断代码执行，也就是说return没有任何效果。如果想要中断forEach，可以使用trycatch在需要中断的地方抛出异常即可中断forEach。或者使用官方的推荐方法：用every或者some替代forEach



### new 关键字

**在执行new创造实例对象时，内部其实在构造函数中线创建了一个空对象{},然后将this指向这个空对象，并将这个空对象的\__proto__指向构造函数的prototype，最后将这个对象返回**

下面自行实现一个与new一样功能的\_new:

```js
// 需要实现的功能：const obj = _new(构造函数，构造函数的传参)，且obj跟照常new出来的对象拥有一样的功能
fuction _new(Func,...args){
  let obj = {}
  Func.call(obj,...args)
  obj.__proto__ = Func.prototype
  return obj
}
```



### 暂存性死区/暂时死区

使用 let和const声明的变量，在声明之前的区域就是暂存性死区，在这个区域内使用这些变量会报错。例如：

```js
// 第一种情况：
let i = 1
{
  console.log(i) // 报错，因为后面使用let 声明了i
  let i = 2
}
// 第二种情况：
var i = 1
{
  console.log(i) // 报错，因为后面使用let 声明了i
  let i = 2
}
// 第三种情况：
var foo = 33
{
  let foo = foo + 55 // 报错，也是因为在let声明之前就使用了foo
}
// 第四种情况：
let i = 0;
{
  console.log(i) // 报错，但原因是重复声明了i，因为var存在变量提升，在let之前就已经有了var i = undefined，下面再let就会报错
  var i = 2
}
```



### 经典闭包问题

**闭包的作用：1.模拟块级作用域（let）。2. 保留外部函数的变量。3.封装私有变量**

```js
var a = 0,b = 0;
function A(a){
  A = function(b){
    alert(a+ b++);
  };
  alert(a++)
}
A(1);// 1
A(2);// 4

// 改写闭包：
for(var i = 0; i < 6; i++){
  setTimeout(function(){
      console.log(i)
  },1000)
}
最终改写为：
for(var i = 0;i < 6;i ++){
  (function(j){
    setTimeout(() => {
      console.log(j)
    },1000)
  }(i))
}

```

**为什么呢？**

**首先，在外层函数A内并没有声明A，所以内层的A函数会跑到外面去替代掉外层的A，然后，由于js函数的作用域看的是定义时候的作用域，所以第二次的a是1++也就是2，最终结果就是2+2 = 4**

```js
再来一题：
var x = 0,y = 1;
funtion fn(){
  x += 2;
  fn = function(y){
    console.log(y+(--x));
  };
  console.log(x,y)
}
fn(3);
fn(4);
console.log(x,y)
```

**答案：（2,1）、5、（1,1）**

```js
// 再做一题
var x = 2;
var y = {
    x:3,
    z:(function(x){
        this.x *= x;
        x += 2;
        return function(n){
            this.x *= n;
            x += 3;
            console.log(x)
        }
    })(x)
};
var m = y.z;
m(4);
y.z(5)
console.log(x,y.x)
```

**答案：7、10、（16,15）**

### async等执行顺序

**浏览器的执行顺序：先将脚本作为一个宏任务来执行，宏任务遇到await会执行await后面的函数并等待其返回结果将await下面的所有语句塞入微任务中，然后跳到下一步继续执行主线任务，遇到setTImeout会塞入宏任务。主线任务执行完毕后，会先执行微任务再接着执行宏任务**

==宏任务：事件绑定，定时器，ajax==

==微任务：async、await、promise、V8的垃圾回收过程==

```js
async function async1(){
  console.log("async1 start")
  await async2();
  console.log("async1 end")
}
async function async2(){
  console.log("async2")
}
console.log("script start")
setTimeout(() => {
  console.log("setTimeout")
},0)
async1()
new Promise(function (resolve){
  console.log("promise1")
  resolve()
}).then(function(){
  console.log("promise2")
})
console.log("script end");

最终的输出顺序为：
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```



### 跨域问题

#### 手写AJAX

介绍一下readyState状态码：0->刚创建还没发送;1->执行了open;2->已经发送响应头已经被接收到;3->正在接受响应主体部分;4->响应主题已经被接收完毕;

使用xhr.abort（）可以强制中断ajax请求

```js
function myAjax({url,method,data,success,error}){
  let xhr = new XMLHttpRequest()
  let params = ''
  if(data){
    for(let i in data){
      params += i + '=' + data[i] + '&'
    }
    const reg = /['&']$/
    params = params.replace(reg,'')
  }
  if(method == 'get'){
    url += '?' + parmas
  }
  xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){
      if((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304){
        success && success()
      }else{
        error && error()
      }
    }
  }
  xhr.open(method,url,true)
  xhr.setRequestHeader('Content-type','x-www-form-urlencoded')
  xhr.send(params)
}
```



#### 第一阶段JSONP

jsonp的原理：由于script标签请求的资源不受跨域的影响，我们就创建一个script标签，将src设置为接口的地址，然后在后面加上一个callback=func；在js代码中定义这个func：function func(data){这样data就是我们从接口请求来的数据：}

```js
js代码生成一个script：<script src="www.baidu/api/user/info?callback=func"><script>
在js代码中：function func(data){这里的data就是请求来的数据}
```

==局限：接口的请求方式只能是get请求，且需要后端将数据拼接成："func({这里是数据})"==

#### 第二阶段iframe

使用window.name/document.domin/location.hash/post.message......(15~16年)

#### cors跨域资源共享

只需要在后端设置cors即可，设置header：Access-Control-Allow-Origin

cors跨域分为两种请求，简单请求和非简单请求（又称复杂请求）。

简单请求需要同时满足以下两大条件：1.请求方法是head/get/post之一。2.头信息不超出以下字段：Accept/Accept-Language/Content-Language/Last-Event-ID/Content-Type(只限于application/x-www-form-urlencoded、multipart/form-data、text/plain)。简单请求会在请求头中加上一个Origin字段表示请求来自哪个源，服务器会在响应头添加Access-Control-Allow-Origin字段，如果Origin不在这个字段中就会被浏览器拦截

非简单请求会发送两次请求，第一次预检请求，询问服务器网页是否在许可名单中以及可以使用哪些HTTP动词和头信息。得到肯定答复后发出正式的XMLHTTPRequest，过程和简单请求一样

#### 基于http proxy实现跨域请求(开发阶段)+nginx反向代理(部署阶段)

只需要在webpack中进行配置即可，如果是vue项目，新建一个vue.config.js：

```js
module.exports = {
  devServer: {
    port: 9988, // 启动代理服务器的本地端口
    proxy: {
      '/api': { //请求路径关键字，这样后面就可以使用/api代替后面target写的一长串地址
        	target: 'http://api.vikingship.xyz/api', //对应自己需要跨域的接口
        	changeOrigin: true,//是否允许跨域,在本地会创建一个虚拟服务端，然后发送请求的数据，
        	// 并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题
        	ws: true,
        	pathRewrite: {
          	'^/api': ''      //这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替
          	// 比如我要调用'http://meituan:8024/management/user/add'，直接写‘/api/user/add’即可
        	}
      }
    }
  },
  // lintOnSave: false // 取消 eslint 验证
}
```

如果是react项目，类似配置"proxy":"需要跨域的接口，例如：http://meituan:5566/api"   后面发请求直接axios.get('后缀地址，例如：/user/userInfo')，这样就会向本地localhost:3000/user/userinfo发送请求，由于设置的proxy，就会将请求通过服务器代理自动代理到上面写的接口http://meituan:5566/api中，最终拼接出来的接口就是：http://meituan:5566/api/user/userInfo

==最后，部署到服务器上时，就需要使用到nginx 的反向代理==





### call、apply、bind

#### 三者的共同点

三个都是用于改变函数的this指向，并传参

#### call

call用于改变函数的this指向，第一个参数是改变后的this指向，后面所有的参数都是传参.如果第一个参数是undefine或者null，则函数的this指向是window

```js
Object.prototype.toString.call([])
cat.eat.call(dog,'apple','banana')
// 自己实现一个call
Function.prototype.myCall = function(thisArgs){
  const fn = Symbol('fn')
  const args = arguments.slice(1)
  thisArgs[fn] = this
  const result = thisArgs[fn](...args)
  delete thisArgs[fn]
  return result
}
```

#### apply

apply也用于改变函数的this指向，第一个参数是改变后的this指向，后面只能再有一个参数，就是传参的数组。如果第一个参数是undefine或者null，则函数的this指向是window。**所以，call和apply的区别就是：call后面是this指向以及所有参数排列，apply后面是this指向以及所有参数的数组**

```js
cat.eat.apply(dog,['apple','banana'])
// 自己实现一个apply 
Function.prototype.myApply = function(thisArgs,oArgs){
  const fn = Symbol('fn')
  thisArgs[fn] = this
  const result = thisArgs[fn](...oArgs)
  delete thisArgs[fn]
  return result
}
```

#### bind

bind用于改变函数的this指向，后面跟着一系列参数排列。**与上面两个call、apply的区别是：bind并不会像call和apply一样直接执行函数，而bind会返回一个改变完this之后的新的函数**。所以在react中绑定函数使用的是bind，这样不会自动执行，而是等到对应条件触发时才会执行。

```js
const dogEat = cat.eat.bind(dog,'apple','banana')
dogEat()
// 自己实现一个bind
Function.prototype.myBind = function(thisArgs,...args){
  const _this = this
  return function(){
    _this.apply(thisArgs,args.concat(arguments))
  }
}
```



### Worker

woker是H5中创建多线程的API，会开启新的js线程

#### 使用方式

主线程中开启子线程：const worker = new Worker('新的js文件地址')

主线程中监听子线程传输的信息：worker.addEventListener('message',(e) => {   },false)

主线程向子线程传输信息：worker.postMessage(要传输的信息)

主线程关闭子线程：worker.terminate()

子线程监听主线程传入的信息：onmessage = (e) =>{}

子线程向主线程传输信息：postMessage(要传输的信息)

子线程自主关闭：self.close()

子线程中加载外部脚本：importScripts('文件')

#### 注意事项

1. 主线程和子线程之间不支持跨域。也就是说子线程的js文件必须与主线程js文件在同一个域名下
2. 两个线程之间传输的数据是值的拷贝，相当于将值复制一份进行传输。传输时会先在一端进行JSON.stringify序列化，在另一端接收到后进行JSON.parse反序列化
3. 子线程worker中无法使用dom、window、document、parent、alert()、confirm()，所以需要使用self来代替this



### 大量数据渲染

1. 使用requestAnimationFrame，每过100/30ms执行一次，也就是每秒60帧的动画
2. 使用worker开启子线程进行处理



### 生成器和迭代器

#### 生成器

生成器是一个带*号的函数，**但特别注意生成器不是函数，使用typeof查看会返回object**，它可以通过yield关键字来暂停执行和恢复执行

```js
function* gen() {
  console.log("enter");
  let a = yield 1;
  let b = yield (function () {return 2})();
  return 3;
}
var g = gen() // 阻塞住，不会执行任何语句
console.log(typeof g)  // object  看到了吗？不是"function"

console.log(g.next())  
console.log(g.next())  
console.log(g.next())  
console.log(g.next()) 

// enter
// { value: 1, done: false }

// { value: 2, done: false }
// { value: 3, done: true }
// { value: undefined, done: true }

```

由此可以看到，生成器的执行有这样几个关键点:

1. 调用 gen() 后，程序会阻塞住，不会执行任何语句。
2. 调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停。
3. next 方法返回一个对象， 有两个属性: `value` 和 `done`。value 为`当前 yield 后面的结果`，done 表示`是否执行完`，遇到了`return` 后，`done` 会由`false`变为`true`。

而生成器的底层就是协程，协程是一种比线程更加轻量级的存在，协程处在线程的环境中，`一个线程可以存在多个协程`，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将` JS 线程的控制权转交给 B协程`，那么现在 B 执行，A 就相当于处于暂停的状态。举个例子：

```js
function* A() {
  console.log("我是A");
  yield B(); // A停住，在这里转交线程执行权给B
  console.log("结束了");
}
function B() {
  console.log("我是B");
  return 100;// 返回，并且将线程执行权还给A
}
let gen = A();
gen.next();
gen.next();

// 我是A
// 我是B
// 结束了
```

在这个过程中，A 将执行权交给 B，也就是 `A 启动 B`，我们也称 A 是 B 的**父协程**。因此 B 当中最后`return 100`其实是将 100 传给了父协程。

需要强调的是，**对于协程来说，它并不受操作系统的控制，完全由用户自定义切换，因此并没有进程/线程`上下文切换`的开销，这是`高性能`的重要原因。**

而async和await`利用`协程`和`Promise`实现了同步方式编写异步代码的效果，其中`Generator`是对`协程`的一种实现。生成器本身也是下面即将说到的迭代器。



#### 迭代器

首先介绍一下可迭代数据类型，像数组就是一种可迭代数据类型。我们把那些原生具有[Symbol.iterator]属性数据类型为可迭代数据类型。如数组、类数组（如arguments、NodeList）、Set和Map。可迭代对象可以通过迭代器进行遍历。

```js
let arr = [4, 2, 1];
// 这就是迭代器
let iterator = arr[Symbol.iterator]();
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());


// {value: 4, done: false}
// {value: 2, done: false}
// {value: 1, done: false}
// {value: undefined, done: true}

```

其实，for...of循环就是迭代器的语法糖。

**而上面提到的生成器本身也是一种迭代器**



### 模块化标准

#### AMD、CMD

##### AMD

依赖的是**RequireJS**

1. 导出(定义模块)：define(模块的标识，当前模块依赖的模块名称数组，模块要导出的函数或对象)
2. 导入(加载模块)：require(所要依赖的模块数组，依赖模块加载成功后执行的函数(加载的模块会作为参数))

例如：

```js
// 导出：（在myModule.js文件中：）
define('test',['dependency'],function(){
	function say(){
    console.log('hello')
  }
  return{
    say:say
  }
})

// 导入(在main.js文件中：)
require(['test'],function(ss){
  ss.say()
})
```



##### CMD

依赖的是**SeaJS**

1. 导出：define(function(require,exports,module){})
2. 导入：seajs.use([依赖的模块名],function(参数){})

例如：

```js
// 定义模块  myModule.js
define(function(require, exports, module) {
  var $ = require('jquery.js')
  $('div').addClass('active');
});
 
// 加载模块
seajs.use(['myModule.js'], function(my){
 
});
```

##### 二者的区别

1. AMD推崇的是依赖前置，也就是说在定义模块的时候就需要声明其依赖的模块，即需要将导入语句写在文件的最开头的位置
2. CMD推崇就近依赖，只有在用到的时候再去require导入



#### CommonJs、ES6Module

##### CommonJS

**CommonJs是nodejs的模块化实现方式**

1. 导出：module.export = {}
2. 导入：require('文件')

##### ES6Module

1. 导出：export {} 或者export default
2. 导入：import {} from '文件'
3. 注意事项：需要在script标签处加上type="module"，

##### 二者的区别

1. CommonJS输出的是值的拷贝，也就是说原来模块中的值改变不会影响已经加载的值（复杂的数据类型如多层对象和数组除外），而ES6是静态分析动态引用，输出的是值的引用，值改变引用也改变，原来模块中的值改变则加载的值也改变
2. CommonJS是运行时加载，使用require命令加载时会运行整个模块代码。ES6模块是编译时输出接口，当遇到import语句时会生成一个只读引用，等到真正用到该模块时再根据引用去加载模块取值。
3. CommonJS加载的是整个模块也就是讲所有的接口全部加载进来，ES6可以单独加载某个
4. CommonJS this指向当前模块，ES6 this指向undefined。
5. CommonJS是运行时依赖，所以可以放在文件的任何位置引用；ES6Module是编译时依赖，需要放在最开头引入

### 手写一个map

map接受两个参数，第一个参数是回调函数，第二个参数是回调函数内this 的指向。而回调函数又接受三个参数：curValue、index、arr，也就是当前遍历到的值、当前遍历到的下标和遍历的数组本身

```js
Array.prototype.myMap = function(callback,context){
	// 这里的this就是我们需要进行map的数组
  // 通过slice方法复制一份,这样操作就不会干扰到原数组
  let arr = Array.prototype.slice.call(this)
  let res = []// 这个就是最终返回的数组
  for(let i = 0;i < arr.length;i ++){
    res.push(callback.call(context,arr[i],i,this))
  }
  return res
}
```



### 手写一个reduce

reduce接受两个参数，第一个参数也是回调函数，第二个参数是初始值。回调函数也接受四个参数，上一次计算结束的返回值，当前遍历到的元素，当前元素的索引，当前便利的数组本身

```js
Array.prototype.myReduce = function(callback,initVal){
  // 这里的this就是我们需要进行reduce的数组
  // 通过slice方法复制一份,这样操作就不会干扰到原数组
  let arr = Array.prototype.slice.call(this)
  let res,startIndex
  res = initVal ? initVal : arr[0]
  startIndex = initVal ? 0 : 1
  for(let i = startIndex,i < arr.length; i ++){
    res = fn.call(null,res,arr[i],i,this)
  }
  return res
}
```



### 手写一个Object.create

Object.create的原理就是将返回的对象的proto指向参数，所以需要借助一个中间构造函数F来完成

```js
function create(p){
  function F(){}
  F.prototype = p
  F.prorotype.constructor = F
  return new F()
}
```



### instanceof的原理

A instanceof B

判断左边的原型链上是否含有右边的prototype。具体的实现方式就是遍历左边的原型链直到找到右边的prototype否则返回false：

```javascript
function new_instance_of(leftValue, rightValue) { 
    let rightProto = rightValue.prototype; // 取右表达式的 prototype 值
    leftValue = leftValue.__proto__; // 取左表达式的__proto__值
  	while(leftValue){
      if(leftValue === rightProto){
        return true
      }
      leftValue = leftValue.__proto__
    }
  return false
}
```



### 手写一个Promise

promise由三种状态：Pending、Fulfilled、Rejected

promise在then方法之后仍会返回一个新的promise其中的参数就是上一个then中return 的值

**那么如何中断一个promise 的链式调用？**在then中返回一个状态永远是pending的promise即可，也就是then(() => {return new Promise(resolve,reject => {})})

下面手写一个promise，使用到了一个queueMicrotask函数开启一个微任务，在node中可以使用process.nextTick开启微任务，浏览器中可以使用MutationObserver开启微任务。而queueMicrotask是跨环境的。

```javascript
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
  constructor(executor) {
    try {
      executor(this.resolve, this.reject)
    } catch (e) {
      this.reject(e)
    }
  }
  status = PENDING
  value = null
  reason = null

  onFulfilledCallbacks = []
  onRejectedCallbacks = []

  resolve = (value) => {
    if (this.status === PENDING) {
      this.status = FULFILLED
      this.value = value
      while (this.onFulfilledCallbacks.length) {
        this.onFulfilledCallbacks.shift()(value)
      }
    }
  }

  reject = (reason) => {
    if (this.status === PENDING) {
      this.status = REJECTED
      this.reason = reason
      while (this.onRejectedCallbacks.length) {
        this.onRejectedCallbacks.shift()(reason)
      }
    }
  }

  then(onFulfilled, onRejected) {
    const promise2 = new MyPromise((resolve, reject) => {
      const fulfilledMicrotask = () => {
        queueMicrotask(() => {
          try {
            let x = onFulfilled(this.value)
            resolvePromise(x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        })
      }
      const rejectedMicrotask = () => {
        queueMicrotask(() => {
          try{
            let x = onRejected(this.reason)
            resolvePromise(x,resolve,reject)
          }catch(e){
            reject(e)
          }
        })
      }
      if(this.status === PENDING){
        this.onFulfilledCallbacks.push(fulfilledMicrotask)
        this.onRejectedCallbacks.push(rejectedMicrotask)
      }else if(this.status === FULFILLED){
        fulfilledMicrotask()
      }else if(this.status === REJECTED){
        rejectedMicrotask()
      }
    })
    return promise2
  }
}

function resolvePromise(x, resolve, reject) {
  if (x instanceof MyPromise) {
    x.then(resolve, reject)
  } else {
    resolve(x)
  }
}
```



### 实现一个Promise.all

```js
function promiseAll(promiseArray){
  return new Promise((resolve,reject) => {
    if(!Array.isArray(promiseArray)){
      throw new TypeError('argumenst must be array')
    }
    let resolveCount = 0
    let resolveArr = []
    for(let i = 0;i < promiseArray.length;i ++){
      Promise.resolve(promiseArray[i]).then(value => {
        resolveCount ++
        resolveArr.push(value)
        if(resolveCount == promiseArray.length){
          resolve(resolveArr)
        }
      },error => {
        reject(error)
      })
    }
  })
}
```





### localStorage和cookie、sessionStorage

localStorage存储大小（5M）远大于cookie（4K），并且localStorage不容易被清理掉，cookie一旦用户清除浏览历史就会被清除。但主要区别还是存储的大小。sessionStorage会在页面被关闭时自动被清除



### session和cookie

**区别：session是存储在服务器端的，cookie是存储在客户端（浏览器端）的。session是基于cookie 的**

**联系：服务器设置session后，会在发送给客户端的响应头中带着set-cookie='connect.sid'    客户端会自动把信息种植到本地的cookie中并且是httponly的（只能读不能修改）  之后客户端再次向服务器发送请求时，会默认在请求头的cookie中把connect.sid传递给服务器**

服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能在[客户端]()使用js 脚本访问。只有满足域名等于domain或者是domain的子域名且路径等于path或是path的子路径浏览器才会在发送请求时携带对应的cookie



###前端向后端传输数据的方式

1. 最常用的ajax
2. 通过请求图片的方式：const image  = new Image();  image.src = "地址?数据"    这样后端就能取到数据
3. 通过navigator.sendBeacon(url,数据)的方式，这种方式成功率最高但适配不好



### 安全问题 如XSS和CSRF

#### XSS

1. XSS是什么？xss全称Cross Site Scripting 跨站脚本攻击。利用开发时的漏洞将恶意代码注入到网页，使得用户加载并执行这些恶意代码，这些恶意代码通常是js，也包括java、VBScript等
2. 攻击分类：①持久型（存储型）XSS，攻击者将恶意代码提交到目标网站的数据库中，用户请求后，服务器将恶意代码从数据库中取出，拼接在html中发给用户。常见于论坛发帖、商品评论   ②非持久型（反射型）XSS，诱骗用户点击URL带攻击代码的链接，服务器解析后响应，在响应内容中嵌入攻击者的XSS代码，常见于网站搜索跳转。③dom XSS，根据实际情况构造dom节点进行XSS跨站脚本攻击，前端js代码不够严谨，把不可信的内容插到页面上
3. 防范：**所有用户输入都是不可信的。产生XSS的原因是用户对指定网站的信任**。① 使用输入过滤，对用户输入的内容进行有效性认证，忽略或者阻止以外的任何数据，对输入内容进行转义。②将cookie设置为httponly。使得javascript脚本无法获取到cookie   

#### CSRF

1. CSRF是什么？CSRF全程Cross-sit Request forgery 跨站请求伪造，挟持用户在当前已登录的web上执行非本意的操作的攻击方法。**CSRF利用的是网站对用户浏览器的信任**
2. 攻击原理，在用户不知情的情况下利用用户已登录产生的cookie发送请求
3. 防范：①敏感请求不采用get形式（只能防范一些CSRF攻击）②用户操作限制，添加验证码机制（简单粗暴，但对用户不太友好）③验证http referer字段，这个字段记录了请求的来源地址，服务器验证来源地址是否合法（依赖浏览器）④采用token 。⑤设置cookie时添加sameSite属性，该属性有三个值：Strict/Lax/None，设置为Strict或者Lax后就基本杜绝了CSRF攻击



### Token

#### jwt

全称是json web token，是token的一种web规范。一个jwt由三个部分组成，部分之间用.隔开。三个部分分别是：header、payload、signature

header一般包含两个字段：type类型和algorithm算法，在进行base64编码后作为jwt的第一个部分：

```json
{
	"alg": "HS256",
  "typ": "JWT"
}
// base64编码后作为jwt的第一部分
base64.b64encode(json.dumps({"alg":"HS256","typ":"JWT"}))
'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9'
```

payload就是真实存储着需要传递的信息，比如用户ID、过期时间等，注意这里不能存敏感信息例如密码等，因为后续的编码是可以被破译的是不安全的

```json
{"user_id":"zhangsan"}
// 经过编码，这里的编码不一定是base64
 base64.urlsafe_b64encode('{"user_id":"zhangsan"}')
 'eyJ1c2VyX2lkIjoiemhhbmdzYW4ifQ=='
```

signature是对前面的header和payload以及一个密钥组合形成签名，来确保不会被篡改或者掉包，为了加密除了header和payload还多了一个密钥字段。也就是将上面的经过编码的header和经过编码的payload再加上密钥组合在一起再进行算法编码最后形成了signature。

```json
Signature = HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)

```

最后，将三个部分之间使用.连接在一起形成最后的jwt

服务器验证jwt就是通过自己读取payload和header进行同样的编码形成signature后与客户端传过来的第三部分signature进行比对。

为了减少 JWT Token 泄露风险，一般有效期会设置的比较短。可以同时生成 JWT Token 与 Refresh Token，其中 Refresh Roken 的有效时间长于 JWT Token，这样当 JWT Token 过期之后，使用  Refresh Token 获取新的 JWT Token 与 Refresh Token，其中  Refresh Token 只能使用一次。



### 浏览器垃圾回收机制

**js引擎使用的是标记清除**

+ 标记清除(js引擎使用的垃圾回收机制)。主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象， 对它们做上标记，然后对于代码环境中`使用的变量`以及被`强引用`的变量取消标记，剩下的就是要删除的变量了，在随后的`清除阶段`对其进行空间的回收。然后在清除阶段结束后，把存活的对象全部往一端靠拢以解决内存碎片的问题。
+ 引用计数：当某一变量被引用时引用次数加1，取消引用则引用次数-1，当引用次数为0时，就会被垃圾回收。存在的问题：出现循环引用，例如a对象和b对象互相引用时：var a = {};var b  = {};a.b = b;b.a = a;这样a和b的引用次数都是2，永远也不会变成0，也就永远不会被垃圾回收。但是IE中的dom、bom对象底层是C++一COM的对象形式实现的，其垃圾回收机制是基于引用计数的，所以在使用完dom对象后需要将其置为null



### 函数柯里化

```js
// 通用方法，length是参数长度
function currying(fn,length){
  let len = length || fn.length
  let arr = []
  return function temp(){
    arr.push(...arguments)
    if(arr.length >= len){
      let res = fn(...arr)
      arr = []
      return res
    }else{
      return temp
    }
  }
}
// 调用：
function add(a,b,c,d){
     return a+ b+c+d;
}
add = currying(add,4)
console.log(add(1)(2)(3)(4))
console.log(add(1,2)(3)(4))

// 直接写一个add类型的curring函数：
function add(){
  var _args = Array.prototype.slice.call(arguments)
  function _add(){
    _args.push(...arguments)
    return _add
  }
  _add.toString = () => {
    return _args.reduce((a,b) => {
      return a + b
    })
  }
  return _add
}
// 调用：
add(1,2)(3)(4)
```



## 框架部分

### 自己搭建一个vue-cli脚手架

#### 使用到的第三方包解析

+ commander：用来编写指令，处理命令行
+ inquirer：交互式命令行工具
+ chalk：修改控制台输出样式，比如颜色等
+ ora;好看的加载，下载的时候出现转圈
+ download-git-repo:下载远程模板

#### 具体步骤

1. 首先，创建文件夹，命名为lqh-demo-cli

2. 进入文件夹，输入命令npm init，生成package.json文件

3. 安装上述第三方包

4. 在主目录下新建template.json，内写入一个{}即可，这个文件用于保存项目模板及其github地址

5. 在主目录下新建文件夹bin，在bin中创建文件：“lqh.js”、“lqh-add.js”、“lqh-delete.js”、“lqh-list.js”、“lqh-init.js”

6. package.json文件中添加：

   ```json
   "bin":{
   	"lqh": "bin/lqh.js",
     "lqh-add": "bin/lqh-add.js",
     "lqh-delete": "bin/lqh-delete.js",
     "lqh-list": "bin/lqh-list.js",
     "lqh-init": "bin/lqh-init.js"
   }
   ```

   作用是配置命令。然后输入命令npm link，将添加的命令配置到全局，往后在所有文件夹中都可以通过lqh /lqh add/lqh init....来使用脚手架

7. lqh.js文件：

   ```js
   #!/usr/bin/env node
   const program = require('commander')
   
   // 定义当前版本
   // 定义使用方法
   // 定义四个指令
   program
     .version(require('../package').version)
     .usage('<command> [options]')
     .command('add', 'add a new template')
     .command('delete', 'delete a template')
     .command('list', 'list all the templates')
     .command('init', 'generate a new project from a template')
     
   // 解析命令行参数
   program.parse(process.argv)
   
   ```

8. lqh-add.js文件：

   ```js
   #!/usr/bin/env node
   
   // 交互式命令行
   const inquirer = require('inquirer')
   // 修改控制台字符串的样式
   const chalk = require('chalk')
   // node 内置文件模块
   const fs = require('fs')
   // 读取根目录下的 template.json
   const tplObj = require(`${__dirname}/../template`)
   
   // 自定义交互式命令行的问题及简单的校验
   let question = [
     {
       name: "name",
       type: 'input',
       message: "请输入模板名称",
       validate (val) {
         if (val === '') {
           return 'Name is required!'
         } else if (tplObj[val]) {
           return 'Template has already existed!'
         } else {
           return true
         }
       }
     },
     {
       name: "url",
       type: 'input',
       message: "请输入模板地址",
       validate (val) {
         if (val === '') return 'The url is required!'
         return true
       }
     }
   ]
   
   inquirer
     .prompt(question).then(answers => {
       // answers 就是用户输入的内容，是个对象
       let { name, url } = answers;
       // 过滤 unicode 字符
       tplObj[name] = url.replace(/[\u0000-\u0019]/g, '')
       // 把模板信息写入 template.json 文件中
       fs.writeFile(`${__dirname}/../template.json`, JSON.stringify(tplObj), 'utf-8', err => {
         if (err) console.log(err)
         console.log('\n')
         console.log(chalk.green('Added successfully!\n'))
         console.log(chalk.grey('The latest template list is: \n'))
         console.log(tplObj)
         console.log('\n')
       })
     })
   
   ```

9. lqh-delete.js文件：

   ```js
   #!/usr/bin/env node
   
   const inquirer = require('inquirer')
   const chalk = require('chalk')
   const fs = require('fs')
   const tplObj = require(`${__dirname}/../template`)
   
   let question = [
     {
       name: "name",
       message: "请输入要删除的模板名称",
       validate (val) {
         if (val === '') {
           return 'Name is required!'
         } else if (!tplObj[val]) {
           return 'Template does not exist!'
         } else  {
           return true
         }
       }
     }
   ]
   
   inquirer
     .prompt(question).then(answers => {
       let { name } = answers;
       delete tplObj[name]
       // 更新 template.json 文件
       fs.writeFile(`${__dirname}/../template.json`, JSON.stringify(tplObj), 'utf-8', err => {
         if (err) console.log(err)
         console.log('\n')
         console.log(chalk.green('Deleted successfully!\n'))
         console.log(chalk.grey('The latest template list is: \n'))
         console.log(tplObj)
         console.log('\n')
       })
     })
   
   ```

10. lqh-list.js文件：

    ```js
    #!/usr/bin/env node
    
    const tplObj = require(`${__dirname}/../template`)
    console.log(tplObj)
    ```

11. lqh-init文件：

    ```js
    #!/usr/bin/env node
    
    const program = require('commander')
    const chalk = require('chalk')
    const ora = require('ora')
    const download = require('download-git-repo')
    const tplObj = require(`${__dirname}/../template`)
    
    program
      .usage('<template-name> [project-name]')
    program.parse(process.argv)
    // 当没有输入参数的时候给个提示
    if (program.args.length < 1) return program.help()
    
    // 好比 vue init webpack project-name 的命令一样，第一个参数是 webpack，第二个参数是 project-name
    let templateName = program.args[0]
    let projectName = program.args[1]
    // 小小校验一下参数
    if (!tplObj[templateName]) {
      console.log(chalk.red('\n Template does not exit! \n '))
      return
    }
    if (!projectName) {
      console.log(chalk.red('\n Project should not be empty! \n '))
      return
    }
    
    url = tplObj[templateName]
    
    console.log(chalk.white('\n Start generating... \n'))
    // 出现加载图标
    const spinner = ora("Downloading...");
    spinner.start();
    // 执行下载方法并传入参数
    download (
      url,
      projectName,
      err => {
        if (err) {
          spinner.fail();
          console.log(chalk.red(`Generation failed. ${err}`))
          return
        }
        // 结束加载图标
        spinner.succeed();
        console.log(chalk.green('\n Generation completed!'))
        console.log('\n To get started')
        console.log(`\n    cd ${projectName} \n`)
      }
    )
    
    ```

    

### diff算法

#### 传统diff算法

创建一个完整的节点对象的成本的是非常大的，因为DOM对象非常复杂，包含很多属性和内容，这也是采用虚拟dom的原因

传统的diff算法会将每个新旧节点的两两比较，复杂度为O(n\^2)，比较之后还需要计算最小转化方式，所以综合复杂度就是O(n\^3)



#### 框架层diff算法

框架层的diff有个大前提就是WEB中的DOM节点跨层级的操作少，可以忽略不计，所以其核心在于，框架层的diff算法只对同层级节点进行比较 ，忽略跨层级的复用，所以只需要遍历一次新节点，复杂度为O(n)。

数据更新时，对比新数据构建的vnode和老数据构建的oldVnode的差异，如果为可复用节点(sameNode)就通过patchVnode的方式进行打补丁更新，如果不是可复用节点，则创建新节点进行替换旧的节点的子节点也不考虑复用。

1. 判断是否可复用：大概是通过tag、key、inputType进行，完全相同则说明可以复用

2. patchVnode的逻辑如下：先找到对应的dom节点elm并赋值给vnode.elm；判断节点类型，是文本节点就跟新elm文本即可；非文本节点则看子节点，如果新老节点都右子节点，则走子节点的同层比较流程updateChildren；如果只有新节点有子节点，直接使用addVnodes为elm添加子节点(需要先删除文本)；如果只有旧节点有子节点，使用removeVnodes删除即可；如果都没有子节点，判断旧数据是否有文本节点，有则清空

3. updateChildren逻辑如下：![image-20210610164101430](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210610164101430.png)

   暂且将StartIdx、endIdx称为左指针、右指针，startVnode、endVnode称为左节点和右节点

   当左指针小于等右指针循环遍历(说明上下区间都有节点)，判断老节点边界为null的情况，向内移动指针；判断新旧左节点是否可以复用，可以则为节点打补丁(递归调用patchVnode)，向右移动指针；否则判断新旧右节点是否可以复用，可以则打补丁，并向左移动指针；否则判断新右节点和旧左节点是否可以复用，可以则打补丁，同时旧左节点移动旧右节点之前，再向内移动指针(移动过程会淘汰右节点)；同理，判断新左节点和旧右节点，进行类似操作；若以上情况都无法复用，则使用key来进行判断，key也不行创建新节点



### 虚拟dom vdom

#### 虚拟dom的作用

js无法直接操作真实的dom，需要借助dom模块，这会带来很高的性能代价，且频繁的操作odom会导致页面重绘或者回流。虚拟dom便于我们掌握dom结构，优化dom操作内容，原来直接操作dom的多次操作可以经过虚拟dom优化成一次操作，起到了优化性能的作用

#### vdom更新界面的过程

初次渲染时，首先将数据渲染为vdom，然后由该vdom生成dom。

数据更新时，渲染得到新的vdom，与上一次的vdom进行diff算法比较，得到需要进行更新的dom，然后在patch的过程中应用到dom上实现界面的同步更新

#### 一个简单的vdom：

```javascript
// 真实的dom节点：
<ul id="list">
	<li class="item">item1</li>
  <li class="item">item2</li>
  <li class="item">item3</li>
</ul>

// 转换为vnode后：
const vnode = {
	tag:'ul',
	attrs:{id:'list'},
	children:[
		{
			tag:'li',
			attrs:{class:'item'},
			children:['item1']
		},
		{
			tag:'li',
			attrs:{class:'item'},
			children:['item2']
		},
		{
			tag:'li',
			attrs:{class:'item'},
			children:['item3']
		}
	]
}
```

#### 更新界面的过程简单代码实现：

```javascript
// 第一次patch，也就是首次渲染时：
function createElement(vnode) {
    var tag = vnode.tag  // 'ul'
    var attrs = vnode.attrs || {}
    var children = vnode.children || []
    if (!tag) {
        return null
    }

    // 创建真实的 DOM 元素
    var elem = document.createElement(tag)
    // 属性
    var attrName
    for (attrName in attrs) {
        if (attrs.hasOwnProperty(attrName)) {
            // 给 elem 添加属性
            elem.setAttribute(attrName, attrs[attrName])
        }
    }
    // 子元素
    children.forEach(function (childVnode) {
        // 给 elem 添加子元素
        elem.appendChild(createElement(childVnode))  // 递归
    })

    // 返回真实的 DOM 元素
    return elem
}
// 第二次patch，也就是根据diff算法更新dom：
function updateChildren(vnode,newNode){
  var children = vnode.children || []
  var newChildren = newNode.children || []
  children.forEach((childNode,index) => {
    var newChildNode = newChildren[index]
    if(childNode.tag === newChildNode.tag){
      updateChildren(childNode,newChildNode)
    }else{
      replaceNode(childNode,newChildNode)
    }
  })
}
function replaceNode(node,newNode){
  var elem = vnode.elem
  var newElem = createElement(newNode)
  //然后进行替换
}
```

### vue 模板解析流程

#### 对于runtime+compiler的构建方式

1. 先将template解析(parse)成ast(abstract syntax tree)抽象语法树

2. 将抽象语法树编译(compile)成render字符串函数，这里的render还是字符串形式的函数

   下面看一下具体的html对应的render：

```js
// html部分：
<div id="app">
    <div>
      <input v-model="title" type="text">
      <button v-on:click="add">submit</button>
    </div>
    <div>
      <ul>
        <li v-for="item in list">{{item}}</li>
      </ul>
    </div>
 </div>
// 对应的render函数：
// 其中_c就是创建标签  _v创建文本节点   _s创建{{}}数据   _l对应v-for
with (this) 
{ return _c(
  'div', 
  { 
    attrs: { "id": "app" } 
  }, 
  [
    _c(
      'div', 
      [
        _c(
          'input', 
          { 
            directives: [
              { 
                name: "model", 
                rawName: "v-model", 
                value: (title),
                expression: "title" 
              }
            ], 
            attrs: { 
              "type": "text" 
            }, 
            domProps: { 
              "value": (title) 
            },
            on: { 
              "input": function ($event) { 
                if ($event.target.composing) return; 
                title = $event.target.value 
              } 
            } 
          }),
        _v(" "), 
        _c(
          'button', 
          { 
            on: { 
              "click": add 
            } 
          }, 
          [_v("submit")])
      ]), 
      _v(" "), 
      _c('div', 
        [
          _c(
            'ul',
            _l((list), 
              function (item) { 
                return _c('li', [_v(_s(item))]) 
              }), 
              0)]
          )]
          ) 
        }
```



3. render转换成真正的函数(new function)并执行会返回一个VNode对象，也就是虚拟dom

4. 将虚拟dom执行一系列操作如diff算法等，渲染成真实的UI界面

```js
vm._update(vnode){
	const prevVnode = vm._vnode
  vm._vnode = vnode
  if(!prevVnode){
    vm.$el = vm._patch_(vm.$el,vnode)
  }else{
    vm.$el = vm._patch_(prevVnode,vnode)
  }
}
// 页面每一次渲染或者data每一次修改内容都会触发下面的函数
function updateComponent(){
  //  下面的render就是第二步的render函数，返回一个Vnode
  vm._update(vm._render())
}
```



#### 对于runtime-only的构建方式

**runtime-only省去了template -> ast ->render 函数的过程，直接将执行render函数返回一个Vnode**

1. 执行render函数

   ```js
   new Vue({
   	router,
   	vuex,
   	render:h => h(App)  //这里的h就是创建VNode的函数，返回VNode，叫h可能是对应snabbdom
   }).$mount('#app')
   ```

2. 将render函数返回的VNode对象执行操作渲染出真实的UI界面



### vue整个的实现流程

解析模板成render函数  -->   开启响应式监听   -->   初次渲染，显示页面并绑定依赖   -->  data属性变化，再次执行渲染    -->

#### 一、解析模板成render函数

就是上面vue 模板解析的过程，将模板解析称为render函数，模板中的逻辑都变成了js代码，render函数执行会返回vnode

#### 二、开启响应式监听

根据render函数监听数据的变化（Object.defineProperty）并将data 的属性代理到vm上

#### 三、进行初次渲染，显示页面并绑定依赖

```js
// 页面每一次渲染或者data每一次修改内容都会触发下面的函数
function updateComponent(){
  //  下面的render就是第二步的render函数，返回一个Vnode
  vm._update(vm._render())
}

vm._update(vnode){
	const prevVnode = vm._vnode
  vm._vnode = vnode
  if(!prevVnode){
    // 初次渲染
    vm.$el = vm._patch_(vm.$el,vnode)
  }else{
    // 再次渲染
    vm.$el = vm._patch_(prevVnode,vnode)
  }
}
```

执行render函数会访问到内部的数据，就会被响应式的get方法监听到

#### 四、data属性变化引发再次渲染

修改属性会被set方法监听到，然后就会再次执行updateComponent()函数



### Vue生命周期

<img src="https://img-blog.csdnimg.cn/20200921202303225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tvbmdLb25nX1JhYw==,size_16,color_FFFFFF,t_70#pic_center" alt="Vue生命周期" style="zoom:40%;" />

+ beforeCreate :   实例初始化之后，数据观测、event、watcher事件配置之前
+ created ：  实例创建完成之后被调用。这一步已经完成了数据观测，属性计算和事件绑定
+ beforeMount ： 挂载之前调用，相关的render函数首次被调用
+ mounted ： el替换
+ beforeUpdate ： 数据更新时调用，发生在虚拟dom重新渲染和打补丁之前，可以进一步的修改状态，不会触发重复的渲染过程
+ updated ： 数据和虚拟Dom已经重新渲染完成
+ activated ：keep-alive组件激活时调用
+ deactivated ：keep-alive组件停用时调用
+ beforeDestroy ： 实例销毁前调用，这里实例仍然可用
+ destroyed：实例完全销毁后，所有事件等都被移除绑定

1. 创建实例，new Vue() 的过程中，首先执行 init()

2. init() 过程首先是执行 beforeCreate ，初始化data、 props、 watch、computed,这些执行都是在 beforeCreate 阶段和 create 阶段，也是创建响应式数据的阶段，这个阶段不要去修改数据
3. create 阶段结束，会去判断实例中有无 el option 选项，如果没有会执行 \$mount(), 如果有，直接执行下一步
4. 判断 template, 若有，会把 template 打成一个个 render function ,其中的传参h就是vue.createElement， 参数为 标签，对象(可以是props或事件)，内容
5. render函数发生在 beforemounted 和 mounted 之间，所以当 beforeMount 时，$el 还只是HTML上的节点，mounted 时才把渲染的内容挂载到 DOM 上，实际就是执行了 renderfunction
6. beforeMount 有了 renderfunction 才执行，执行完执行 mount , mounted 执行完，整个生命周期中主动执行的函数就已经完毕，剩下的比如 beforeUpdata、updata、beforDestory、destory 需要外部触发

### Vue中的v-for循环中key的作用

当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。

为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。

key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。

由于Diff算法，如果需要在多个节点中插入一个节点，diff算法会默认将原来的节点一一替换，而不是直接插入。当有了key这个唯一标识的时候，diff算法就可以正确识别节点并在正确的位置插入。

**所以，v-for中的key是为了更新Dom时更高效**

不建议使用index作为key的原因是：当以数组的下标index作为key值时，其中一个元素发生了变化 就有可能导致所有元素的key值发生改变 。diff算法是比较同级之间的不同并以key值来进行关联。当对数组进行下标的变换时，比如删除第一条数据，那么以后所有的Index都会发生改变，那么key值自然也跟着全部发生改变，所以，index作为key值和没加index是一样的，并不能提升性能。 



### Vue中computed和watch的区别

#### computed：

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算

2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化

3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值

4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed

5. 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

#### watch：

1. 不支持缓存，数据变，直接会触发相应的操作；

2. watch支持异步；

3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

4. 当一个属性发生变化时，需要执行对应的操作；一对多；

5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：



### Vue组件化步骤

+ 创建组件构造器Vue.extend() ->  
+ 注册组件Vue.component() ->
+ 使用组件



### Vue-loader是什么

vue文件的一个加载器，跟template/js/style转换成js模块。



### $nextTick作用？

vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。

nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM



### Vue中双向数据绑定的原理

vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：

> 1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化

> 2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

> 3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

> 4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。



### vue如何监听数组或者对象的变化

两种方式：

+ this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)
+ 调用以下几个数组的方法：splice、push、pop、shift、unshift、sort、reverse






### React的流程

#### 一、JSX语法解析

JXS语法会隐式的调用React.createEleme()函数，该函数会返回一个vNode对象，类似于vue中的render函数。当遇到自定义组件时，会调用自定义组件的render方法，再次触发React.createElement函数

#### 二、setState流程

React中数据的修改与vue中都是异步的，在setState完成之后，react会隐式的调用renderComponent()函数，函数内部会再一次执行render触发React.createElement函数返回一个新的Vnode，然后执行patch渲染。



### 父子组件通信

#### Vue中父子组件通信

**vue中，父传子通过props进行传递，子传父通过emit，如果有多级传递，在Vue2中用\$on/$emit，在Vue3中需要引入第三方的mitt通过mitt的on和emit进行。同时，父组件还可以通过v-slot获取到子组件的数据：在子组件中\<slot name="test" :data="count">在父组件中：\<template v-slot:test="sonData" >这样就可以通过sonData.data获取到子组件的count**

**还可以通过本地存储的方式：vuex（刷新会重置）、localStorage**

####react中父子组件通信

**react中父传子也是通过props传递，子传父通过父组件将方法通过props传递给子组件，子组件调用该方法实现。多层通信可以通过手写发布订阅或者React.createContext**



### 前端路由的原理

主要使用的原理是URL与UI的映射关系，即改变URL并不引起页面的刷新

1. history：history.pushState()、history.replaceState()  这两种方式都会引起URL的变化但页面不会刷新。
2. hash：hash就是URL的#后面部分，使用window.location.hash处理哈希的改变时不会重新渲染页面，监听hashchange事件即可



## webpack配置部分

### 初始化

首先在项目中输入npm init 初始化，之后会出现一个package.json文件表示初始化完成

### babel的配置

babel的作用：将ES的高版本转换成适合浏览器运行支持的低版本，其中@babel/parser生成AST抽象语法树，然后利用@babel/traverse进行AST遍历，记录依赖关系，最后通过@babel/core和@babel/preset-env进行代码的转换

1. 首先安装：npm install babel-core   bable-preset-es2015   babel-preset-latest。
2. 然后在package.json的同级目录下创建.babelrc文件，在文件内输入：

```json
{
  "presets":[
    ["latest",{
      "es2015":{
        "modules":false
      }
    }]
  ],
  "plugins":[]
}
```

3. 通过babel  xxxx（文件地址）即可将文件转为浏览器可识别的语法

### 模块化相应配置

1. 首先安装webpack以及babel-loader：npm install wabpack   babel-loader.
2. 在根目录下(也就是package.json同级)新建一个webpack.config.js，文件内输入基本的(js)配置：

```js
module.exports = {
	entry:'./src/index.js',//设置入口文件
  output:{  //设置出口配置
    path:__dirname,
    filename:'./build/bundle.js'
  },
  module:{ //定义不同文件的规则
    rules:[{
      test:/\.js?$/,  //以js为结尾的
      exclude:/node_modules/,
      loader:'bable-loader' //使用的loader：bable-loader
    }]
  }
}
```

3. 在package.json中添加：

```json
"scripts":{
	+"start":"webpack"
}
```

之后运行npm start 测试js代码的配置是否成功（包括jsimport模块化以及babel语法转换是否生效）

4. css模块化配置，在webpack.config.js文件的module{rules中添加}：

```js
module:{
	rules:[
    {
    test:/\.js?$/,
    exclude:/node_modules/,
    loader:'bable-loader'
  },+ {
    + test:/\.css?$/,
    + exclude:/node_modules/,
    + loader:'css-loader'
  + }
  ]
}
```

然后别忘记安装：npm install css-loader

### babel-runtime和babel-polyfill的区别

babel默认只转换新的javascript语法，而不转换新的API，例如Iterator、Symbol、Promise等，如果要使用这些新的对象和方法，就需要使用babel-polyfill

而babel-runtime是为了减少重复的代码，能够将工具函数diamante转换成require语句，

### bundle、module、chunk的区别

+ 我们手写的一个个文件都可以看做是一个module
+ 将module源文件传到webpack进行打包时，会根据文件引用关系生成chunk文件
+ webpack处理好chunk之后，最终会根据文件类型(css/js...)输出bundle文件，可以直接在浏览器中运行

### plugin和loader的区别

loader：webpack默认只能识别js文件，如果需要打包其他文件，就需要使用到loader，loader的作用就是让webpack拥有了加载和解析非javascript文件的能力

plugin：扩展webpack的功能，让webpack具有更多的灵活性

几个plugin：'CompressionPlugin'(对文件开启gzip打包)/'htmlWebpackPlugin(创建一个html模板，并自动引入chunk包)'、‘UglifyJsPlugin(压缩js代码)’



## 计算机网络部分

**TCP/IP的五层模型：物理层、数据链路层(MAC地址、以太网协议)、网络层(IP协议)、传输层(TCP/UDP协议)、应用层(HTTP协议)**

### HTTP协议

#### HTTP常见的状态码

+ 1xx 提示信息 表示目前是协议处理的中间状态，还需要后续的操作
+ 2xx 服务器成功处理了客户端的请求
+ + 200 OK  表示一切正常，如果是非HEAD请求，返回的响应头中都会有body数据
  + 204 No Content   也是常见的成功状态码，响应头中没有body数据
  + 206 Partial Content 应用于分块下载或者断点续传，表示当前返回的数据不是全部资源
+ 3xx  表示客户端请求的资源发生了变动，需要重定向
+ + 301 Moved Permanently  永久重定向，请求的资源已经不存在了，需要使用新的URL，在响应头中会有Location字段，指明后续要跳转的URL，浏览器会自动重定向过去。浏览器会做缓存优化，下一次会直接跳转到新的地址中去
  + 302 Found  表示临时重定向，请求的资源还在，但是暂时需要另一个URl访问，在响应头中会有Location字段，指明后续要跳转的URL，浏览器会自动重定向过去
  + 304 Not Modified  不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，用于缓存控制.表示本地存在缓存文件且该缓存文件还在有效期内未失效
+ 4xx  表示客户端发送的报文有错误，服务器无法处理
+ + 400 Bad Request 表示报文有错误。但只是个笼统的错误
  + 401 No authentication token found  token错误/未找到
  + 403 Forbidden   表示服务器禁止访问资源
  + 404 Not Found 表示请求的资源在服务器上未找到
  + 405 Method Not Allowed 请求方法不被服务器允许
+ 5xx  表示客户端报文正常，但服务器内部发生了错误
+ + 500 Internal Server Error 服务内部错误
  + 501 Not Implmented  客户端请求的功能还不支持。
  + 502 Bad GateWay  服务器作为网关或者代理返回的错误码，表示从上游服务器收到了无效的相应
  + 503 Service Unavailable 表示服务器繁忙，暂时无法响应
  + 504 服务器作为网关或者代理时，未能及时从上游服务器收到回应（网关超时）
  + 505 协议不匹配

#### HTTP常见的请求头

**头部信息每一行以\r\n结尾，头部与体之间的信息以一个空行隔开，也就是空行\r\n，当检测到两对\r\n是，下一个字符开始就是体了**

**request header：**

```json
Host: www.test.com/  //请求的目标域名和端口号
Origin: http://localhost:8081/  //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）
Referer: https:/localhost:8081/link?query=xxxxx  //请求资源的完整URI
User-Agent //浏览器信息
Cookie: //当前域名下的Cookie
Accept: text/html,image/apng  //代表客户端希望接受的数据类型是html或者是png图片类型 
Accept-Encoding: gzip, deflate  //代表客户端能支持gzip和deflate格式的压缩
Accept-Language: zh-CN,zh;q=0.9  //代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)
Connection: keep-alive  //告诉服务器，客户端需要的tcp连接是一个长连接
If-None-Match  //如果内容未改变返回304代码，对应Etag
If-Modified-Since //对应last-modified，未被修改则返回304代码
Content-Type: text/html; charset=utf-8  //编码格式 还有aplication/x-www-form-urlencoded(普通表单); multipart/form-data(文件上传);  apllication/json(json字符串)
```

**response header：**

```json
Date: //服务端发送资源时的服务器时间
Expires: //缓存过期时间
Cache-Control:  no-cache  // 缓存方式
Etag  // 文件内容hash
Last-Modified  //最近一次文件修改时间
Content-Type: text/html; charset=utf-8  //编码格式 还有aplication/x-www-form-urlencoded; multipart/form-data;  apllication/json
Content-Encoding: gzip  //采用gzip对资源进行解码
Connection: keep-alive  //tcp是长连接
Set-Cookie //设置Http Cookie 
```

#### HTTP1.1

1. 引入了长连接：Connection:keep-alive以及Connection：close
2. 引入管道机制，即在同一个TCP连接内可以同时发送多个请求，但服务器还是会按照顺序一次回应
3. Content-Length，声明本次回应的数据长度，区分数据包是属于哪个回应的
4. 还新增了许多动词方法：PUT、PATCH、DELETE，客户端请求头还新增了Host用来指定服务器域名
5. **缺点：**虽然有管道机制，但服务器回应时依旧可能造成队头堵塞。为了解决这一问题，有两种办法：减少请求数和同时多开持久连接

#### HTTP2

1. 头信息和数据体都是二进制，并且将它们统称为“帧”(frame): 头信息帧和数据帧
2. 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应且不用按顺序一一回应，这样避免了“队头堵塞”。这样双向的、实时的通信就叫做多工
3. 由于HTTP2的数据包是不按顺序发送的，所以必须要对数据包做标记。将属于一个请求或者回应的所有数据包称为一个**数据流(stream)**,每个数据流都有着独一无二的编号，在数据包发送时会标记这个编号来区分属于哪个数据流
4. HTTP2可以取消某一次请求而不关闭TCP连接，客户端还可以指定数据流的优先级，优先级越高，服务器就会越早相应
5. 引入头信息压缩机制，一方面头信息需要使用gzip或者compress压缩后再发送；另一方面，客户端和服务器同时维护一张信息表，所有字段都会存入这张表，往后只需要发送索引号即可
6. 允许服务器主动发送资源，叫做server push

#### HTTPS

1. HTTPS为了解决HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL/TSL安全协议，使得报文能够加密传输。加密的原理：混合加密（对称加密+非对称加密）
2. HTTPS在TCP三次握手之后还需要进行SSL/TSL的握手过程，才能进入加密报文传输
3. HTTP的端口是80，HTTPS的端口是443
4. 混合加密过程：服务端预先会生成好非对称加密的私有密钥A‘和多把公开密钥A，服务端本身保持着私有密钥，将公开密钥A分发给多个需要进行交互的客户端，客户端拿到公开密钥A后，客户端通过对称加密生成一个共享密钥X，将此密钥X使用密钥A进行非对称加密，然后发送给服务端，服务端拿到加密后的共享密钥后，用私有密钥A’进行解密获取到客户端真实的共享密钥，然后通过共享密钥加密需要传输的文本内容，后续与服务端交互就是采用共享密钥加密解密来完成。在HTTPS中，服务器的公钥A藏在数字证书中。
5. HTTPS证书如何保证不被篡改？数字签名。数字签名就是对明文数据进行hash后私钥加密得到的。浏览器通过比对得到的明文数据的hash以及数字签名解密的结果是否相同来验证HTTPS证书没有被篡改
6. 前端加密：md5加密

#### HTTP缓存

http缓存分为强制缓存和协议缓存

1. 强制缓存：通过Expires、Cache-Control、Pragma控制，三者同时出现时：pragma > cache-control > expires。浏览器在发送请求之前会判断当前的时间是否在Cache-Control：max-age内.或者响应会返回200 Cache。Cache-Control有以下几个值：max-age（时间）、private（只有客户端缓存）、public（客户端和代理服务器都缓存）、immutable（缓存就算用户按下f5也不会重新请求，不写这个如果用户按下f5会向服务器发出请求）、no-cache（跳过强制缓存）、no-store（都不缓存，跳过强制缓存和协商缓存）
2. 协议缓存：当设置了no-cache的情况下，如果上一次的response中存在ETag或者Last-Modified字段，则表示开启协议缓存，浏览器在发送请求时会带上If-None-Match：ETag和If-Modified-Since：Last-Modified字段给服务器，服务器通过判断是否过期，如果没过期则返回304表示使用缓存。
3. 对于前端，可以在入口页面使用no-cache或max-age设置为较短时间，js.css本身设置max-age较长时间，引用js、css通过打包工具自动加上hash版本号的方式，这样浏览器只会请求修改的文件。



### TCP协议

#### 七层网络模型与四层网络模型

**OSI七层网络模型：**物理层、数据链路层、网络层、传输层、表示层、会话层、应用层

**TCP/IP四层网络模型：**网络接口层、网际层、传输层、应用层

**五层体系结构**：物理层、数据链路层、网络层、传输层、应用层，实际上是OSI和TCP/IP的总和、





1. tcp协议是传输层的协议，也就是说是以太网协议和IP协议的上层协议，http的下层协议
2. tcp协议的作用：保证数据通信的完整性和可靠性，防止丢包



#### TCP为什么能防止丢包（快重传与快恢复）

接收端每一次收到包都会记录并发送ACK，如果收到的包不是对应的ACK，就不会变化，这样，接收方就会反复发送多个重复的ACk给发送方，当发送方收到连续三个重复的ACk后就会确认丢包，将丢失的数据包重新发送，接收端接收到正确的包后才会更新ACK。

#### TCP三次握手

+ 第一次握手：建立连接时，客户端发送syn包(syn = x)到服务器并进入SYN_SEND状态，等待服务器确认；SYN：同步序列编号
+ 第二次握手：服务器收到syn包，必须确认客户的syn并发送一个ACK(ack = x + 1),同时自己也发送一个syn包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态
+ 第三次握手：客户端收到SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器都进入ESTABLISHED(TCP连接成功)状态，完成三次握手



####TCP四次挥手（断开连接可以是客户端也可以是服务端）

+ 假设是客户端断开连接，发送FIN报文，表示Client端没有数据发送，请求断开连接
+ 服务器收到后，可能自己还有数据没有发送完毕，就先发送一个ACK表示收到请求，请等待我发送完毕，这时客户端进入FIN_WAit状态，继续等待服务器的FIN报文。
+ 当服务器完成所有数据的发送后，向客户端发送FIN报文，告诉客户端我数据发送完毕，准备关闭连接
+ 客户端收到FIN后，向服务器发送ACK报文，表示收到，然后进入TIME_WAIT等待状态。服务器收到客户端的ACK后就关闭连接。客户端等待2MSL后没有数据就自行关闭连接



#### 为什么连接时只需要三次握手而断开连接却需要四次挥手？

因为在建立连接时，服务器在接收到客户端的SYN包后可以将自己的SYN和ACK包一并发送给客户端。但是在关闭连接时，服务器可能还有数据尚未发送完毕，只能先发送ACK包确认收到客户端请求，等到自己的数据传输完成后才能发送FIN包给客户端。

#### 建立连接的过程可不可以只有两次握手？这样会发生什么

不行。如果只有两次握手，如果第二次握手时服务器的某一个包(SYN/ACK)包丢失，客户端将无法得知服务器是否准备好了，将会一直等待服务器的确认；而服务器却认为自己准备就绪开始想客户端发送数据，客户端会因为一直等待服务器确认而忽略服务器发送的数据，服务器就会一直发送重复的数据，这样就会造成死锁。

#### 为什么关闭连接时TIME_WAIT需要经过2MSL才真正关闭

网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

#### TCP可靠传输的机制有哪些

1. 三次握手建立连接
2. 停止等待协议：每发送完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组，若接收方收到重复分组，就丢弃该分组，但同时还需要发送确认
3. 连续ARQ协议：**通常要结合滑动窗口协议**。发送方会有一个窗口，窗口的大小假设为5，窗口内的分组是未确认的分组，当发送方收到一个分组的确认后会向后移动一个分组，后面的分组会进入窗口，前面的分组会自动被释放。如果长时间没有收到确认，就会回退到上一次收到确认的地方重新开始发送
4. 流量控制：**流量控制也需要结合滑动窗口协议**。当接收方跟不上发送方的速度时就会强制让发送方慢下来，基于窗口的流量控制，窗口的大小会随着时间变动，从而实现流量控制
5. 拥塞控制：发送速率超过路由器的能力而导致丢包，就需要通过拥塞控制。拥塞控制采用了四种算法：慢开始、快重传、快恢复、拥塞避免：
   + 慢开始：发送方会从小到大逐渐增大发送窗口
   + 快重传与快恢复：当接收方接收到一个不按顺序的数据，就会给发送方发送一个重复确认，如果收到三个重复确认，就会认为数据丢失，并重传丢失的数据



#### 在浏览器输入网址到页面展示经历了什么

输入网址后，浏览器会查看本地是否有域名对应的ip地址，没有则去DNS服务器上获取到对应的ip地址。之后浏览器会向对应的ip地址发送TCP连接请求，经过三次握手后，TCP连接成功。之后发起一个http请求，服务器会根据http请求返回对应的html等文件。之后浏览器开始解析这些文件。首先会解析html生成dom树，之后与css生成的cssom树结合生成render tree，最后渲染render tree。在解析的过程中，遇到js文件，会挂起渲染过程，转而加载并解析js文件，等到js解析完成后，再继续后面的渲染过程。这个过程中往往图片等外部资源文件是最后加载完成的



### get和post的区别

1. 最直观的区别，get参数包含在url中，post一般在body中

2. 通常来说会认为post比get更安全。由于get参数往往放在url中直接传递，post参数通常放在body中传递，表面上看起来post更安全，但实际上http协议下都是明文传输，都是不安全的

3. 通常来说会认为post发送的数据会比get多。get参数一般写在url中进行传递。而浏览器对url有长度限制所以才导致了get发送的数据有长度限制。

4. get为一次请求，post会有两次请求。get会在tcp第三次握手时将发送get请求头和数据；而post会在第三次握手时先发送post请求头，再发送数据分两次发送

5. get会被主动缓存，post不设置不会缓存
6. get通常用来进行查询等不产生危害的操作，post通常用来进行修改数据等会产生危害的操作



### SSL握手的过程





### 性能优化

#### 性能优化的方法

+ 减少HTTP请求
+ + 将文件适当的合并，但也不能过渡合并使得某一个文件过大。静态文件可以使用CDN

+ + 适当使用缓存(localStorage)/内存(Vuex.state)，将请求的数据进行保存，需要时可以从缓存/内存中取。
  + 频繁触发时使用节流和防抖
  + 使用websocket，配置Gzip压缩
  + 图片使用雪碧图或者svg
  + 如果有audio或者video设置他们的preload，播放时在进行加载
+ 浏览器渲染方面
+ + 当样式很多时，设置className而不是直接操作Style
+ + 避免空的src和href，CSS放到顶部，js放到底部同时避免使用CSS表达式，尽量少使用@import
+ + 对于大图片或者多图片使用懒加载，或者使用雪碧图或者svg
+ +   使用defer，async属性的脚本，异步加载的方式，会先发请求，然后JS引擎会继续解析下面的内容。async脚本在加载完成后立即执行，defer会等待html解析完成后执行
  + js避免使用eval
+ + 使用requestAnimationFrame
+ + 尽量使用三维transform，会开启硬件加速 

#### CDN

基于内容的分布式分发网络（Content Delivery Network）

简单的说CDN就是让原本上海的浏览器要访问北京主站内容的请求转而由部署在上海或南京的缓存来受理，这样请求的数据只需经过一跳或有限的几跳就能到达请求端，有效利用带宽并且降低主站压力，对于电子商务网站和搜索引擎网站以及门户网站，CDN的合理应用显得尤为重要。



## git部分

### git合并分支之merge

**下面讨论的条件为：master和bugfix两个分支，要将bugfix合并到master**

1. 如果bugfix分支创建出来后master分支没有经过任何更改。merge名利就会把master分支的位置移动到bugfix上，称为fast-forward合并![image-20210601175748404](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601175748404.png)

2. 如果bugfix分支创建出来后master分支经过了更改和提交。合并两个分支会生成一个提交，这时master分支的HEAD会移动到该提交上。![image-20210601175846035](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601175846035.png)

   ![image-20210601175854221](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601175854221.png)

   

### git合并分支之rebase

同样是master和bugfix两个分支，需要合并。此时master分支在bugfix分支创建出来后经过了修改，如下图所示：

<img src="C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601180207802.png" alt="image-20210601180207802" style="zoom:67%;" />

rebase命令执行后，会将bugfix 的两个提交添加到master分支的末尾，形成一条线（需要解决产生冲突的部分），之后将master 的HEAD移动到bugfix 的HEAD处。![image-20210601180334413](C:\Users\刘清华\AppData\Roaming\Typora\typora-user-images\image-20210601180334413.png)







## 算法部分

### 数组去重

1. 使用set的特性：不能重复

```js
function unique(arr){
	return [...new Set(arr)]
}
```

2. 与第一种类似，采用对象的属性不能重复的特性：这种方式存在问题，例如两个不一样的对象就会被去掉一个

```javascript
function unique(arr){
	let temp = {}
	let res = []
	for(let i of arr){
		if(!temp[i]){
			res.push(i)
			temp[i] = 1;
		}
	}
	return res
}
```

3. 利用map

```js
function unique(arr){
  let map = new Map()
  let res = []
  for(let i = 0;i < arr.length;i ++){
    if(map.has(arr[i])){
      map.set(arr[i],true)
    }else{
      map.set(arr[i],false)
      res.push(arr[i])
    }
  }
  return res
}
```

4. 双层循环然后splice去重,这种方式要注意NaN的问题

```js
function unique(arr){
  let flag = false
  for(let i = 0;i < arr.length;i ++){
    flag = false
    if(typeof arr[i] === "number" && isNaN(arr[i])){
      flag = true
    }
    for(let j = i + 1;j < arr.length;j ++){
      if(arr[i] === arr[j] || (flag && typeof arr[j] === "number" && isNaN(arr[j]))){
        arr.splice(j,1)
        j --
      }
    }
  }
  return arr
}
```





### 深拷贝

```js
function deepClone(origin,target){
  var target = target || new origin.constructor
  var toStr = Object.prototype.toString
  var arrStr = '[object Array]'
  for(let prop in origin){
    if(origin.hasOwnProperty(prop)){
      if(typeof origin[prop] === 'object'){
        if(origin[prop] instanceof RegExp){
          target[prop] = new RegExp(origin[prop])
        }else{
          target[prop] = (toStr.call(origin[prop])) === arrStr ? [] :{}
          deepClone(origin[prop],target[prop])
        }
      }else{
        target[prop] = origin[prop]
      }
    }
  }
  return target
}
```



### 数组的排序

1. 冒泡排序

```js
function babbleSort(arr){
  let temp;
  for(let i = 0;i < arr.length - 1;i ++){
    for(let j = 0;j < arr.length - 1 -i;j ++){
      if(arr[j] > arr[j+1]){
        temp = arr[j]
        arr[j] = arr[j+1]
        arr[j+1] = temp
      }
    }
  }
  return arr
}
```

2. 插入排序

```js
function insertSort(arr){
  let insertIndex;
  let insertVal;
  for(let i = 1;i < arr.length;i ++){
    insertIndex = i - 1;
    insertVal = arr[i]
    while(insertIndex >= 0 && insertVal < arr[insertIndex]){
      arr[insertIndex + 1] = arr[insertIndex]
      insertIndex --
    }
    arr[insertIndex + 1] = insertVal
  }
  return arr
}
```

3. 快速排序

```js
function quickSort(arr){
  helper(arr,0,arr.length - 1)
  return arr;
}

function helper(arr,left,right){
  let l = left
  let r = right
  let pivot = arr[Math.floor((left+right) / 2)]
  while(l < r){
    while(arr[l] <pivot){
      l ++
    }
    while(arr[r] > pivot){
      r --
    }
    if(l >= r){
      break
    }
    temp = arr[l]
    arr[l] = arr[r]
    arr[r] = temp
    if(arr[l] == pivot){
      r --
    }
    if(arr[r] == pivot){
      l ++
    }
  }
  if(r > left){
    helper(arr,left,r)
  }
  if(l < right){
    helper(arr,l,right)
  }
}
```

4. 选择排序

```js
function selectSort(arr){
  for(let i = 0;i < arr.length; i++){
    let minIndex = i
    let min = arr[i]
    for(let j = i + 1;j < arr.length;j ++){
      if(arr[j] < min){
        min = arr[j]
        minIndex = j
      }
    }
    arr[minIndex] = arr[i]
    arr[i] = min
  }
}
```



### 数组的扁平化处理

**扁平化就是将数组变成一维的数组**

1. ES6的flat方法，flat方法可以直接将数组扁平化，接受一个参数是扁平化几级，一般使用最大值Infinity即可

```js
arr.flat(Infinity)
```

2. toString方法，缺点是数组内只能包含字符串或者数字

```javascript
arr.toString().split(',').map(item => parseFloat(item))
```

3. reduce方法

```js
function flatten(arr){
  return arr.reduce((a,b) => a.concat(Array.isArray(b) ? flatten(b) : b),[])
}
```

4. 利用正则表达式

```js
function flatten(arr){
  let str = JSON.stringify(arr)
  str.replace(/(\[|\])/g,'')
  str = '[' + str + ']'
  return JSON.parse(str)
}
```



### 将arguments类数组转数组

1. 使用ES6方法Array.from

   ```js
   function sum(a, b) {
     let args = Array.from(arguments);
     console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
   }
   sum(1, 2);//3
   ```

   使用这种方法还可以将Set和Map转换为数组

2. 使用slice

   ```js
   function sum(a, b) {
     let args = Array.prototype.slice.call(arguments);
     console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
   }
   sum(1, 2);//3
   ```

3. 使用扩展运算符

   ```js
   function sum(a, b) {
     let args = [...arguments];
     console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
   }
   sum(1, 2);//3
   ```



### 判断数组中是否含有某一个值

1. indexOf

   ```js
   arr.indexOf(x)//返回-1代表不包含
   ```

2. includes

   ```js
   arr.includes(x)//返回false代表不包含
   ```

3. find

   ```js
   arr.find(item => item == 3) // 返回undefined表示不含
   ```

4. findIndex

   ```js
   arr.findIndex(item => item === 3)// 返回-1表示不含
   ```

   

### 防抖函数

一次请求在x秒内没有新的请求出现再发送，如果x秒内出现新的请求则继续等待x秒发送新的请求

```javascript
function debounce(func,timeout){
	let timer;
  return function(){
    let context = this
    let args = arguments
    if(timer) clearTimeout(timer)
    timer = setTimeout(() =>{
      func.apply(context,args)
    },timeout)
  }
}
```



### 节流函数

x秒内只发送一次请求，也就是在发送一次请求后x秒内不会再发送新的请求

```js
function throttle(func,timeout){
  let timer;
  return function(){
    let context = this
    let args = arguments
    if(!timer){
      timer = setTimeout(() => {
        func.apply(context,args)
      },timeout)
    }
  }
}
```



### 实现字符串的indexOf

```js
//  使用正则方式：
function myIndexOf1(target){
  return this.match(new RegExp(target)) ? this.match(new RegExp(target)).index : -1
}
String.prototype.myIndexOf1 = myIndexOf1;
// 不使用正则表达式：
function myIndexOf2(target){
  let hArr = this.split('')
  for(let i = 0;i < this.length - target.length + 1;i ++){
			if(hArr.slice(i,i + target.length).join('') === target){
        return i;
      }    
  }
  return -1;
}
String.prototype.myIndexOf2 = myIndexOf2;
```



### 1000瓶毒药老鼠问题

答案：10只老鼠

解析：典型的二进制问题。将1000瓶毒药按照二进制的方式进行编号，十位二进制就可编号完毕。给10只老鼠也分别编号1,2....10

让老鼠喝下对应编号为1的药水，比如2号老鼠喝下所有二号位为1的药水

最后得到死亡的老鼠编号，将对应的编号置为1，其余为0，再转为十进制即为毒药编号。比如1,5,8老鼠死亡，则毒药的二进制编号为：0010010001转换为十进制为145

### 用两个栈实现队列

设两个栈A、B，其中A负责队列的入队操作push，B负责出队操作pop

入队：将元素压入A栈中

出队：

+ 判断B栈是否为空
+ + 若B栈空，看A栈。A栈也空则抛出错误。A栈不空，将A栈元素取出 并压入B栈中，执行B栈的pop
  + 若B栈不空，直接执行B栈的pop即可

### 爬楼梯问题

有n级楼梯，两种爬法，1次1级或者1次2级求n级楼梯有多少种爬法

1. 递归法

n=1时只有一种爬法，n=2时有两种爬法，n=3时有1+2=3中爬法。所以n级楼梯有f(n-1)+f(n-2)种爬法

```js
function jump(n){
  if(n <= 0){
    return -1
  }else if(n <= 2){
    return n
  }else{
    return jump(n-1) + jump(n-2)
  }
}
```

这种方式内存占用大，可能会造成栈溢出

2. 迭代法

与递归法类似，只不过换成了迭代的形式

```js
function jump(n){
  if(n < 0)return -1
  if(n <= 2)return n
  let a = 1
  let b = 2
  let res = 0
  for(let i = 3;i <= n;i ++){
    res = a + b
    a = b
    b = res
  }
  return res
}
```



3. 动态规划

```js
function jump(n){
  if(n == 0)return -1
  if(n <= 2)return n
  let dp = []
  dp.push(1)
  dp.push(2)
  for(let i = 0;i <n-2;i ++){
    dp.push(dp[i]+dp[i+1])
  }
  return dp[n-1]
}
```

### 实现一个LRU

LRU就是least recently used

```js
function LRU(count){
  this.cache = []
  this.count = count
}

LRU.prototype.get = function(key){
  if(this.cache.has(key)){
    let temp = this.cache.get(key)
    this.cache.delete(key)
    this.cache.set(key,temp)
    return temp
  }
  return -1
}

LRU.prototype.put = function(key,value){
  if(this.cache.has(key)){
    this.cache.delete(key)
  }else if(this.cache.size >= this.count){
    this.cache.delete(this.cache.keys().next().value)
  }
  this.cache.set(key,value)
}
```

